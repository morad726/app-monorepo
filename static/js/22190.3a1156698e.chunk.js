(self.webpackChunkweb=self.webpackChunkweb||[]).push([[22190],{940916:(e,t,r)=>{"use strict";r.d(t,{G:()=>w});var n=r(482451),i=r.n(n),o=r(324586),s=r(586330),a=r(230414),c=r(507140),u=r(606777),d=r(554902),p=r(404727),l=r(180556),f=r(929296),h=r(195309),v=r(972715),y=r(901048).Buffer;function _createSuper(e){var t=_isNativeReflectConstruct();return function _createSuperInternal(){var r,n=(0,v.A)(e);if(t){var i=(0,v.A)(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return(0,h.A)(this,r)}}function _isNativeReflectConstruct(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(_isNativeReflectConstruct=function(){return!!e})()}var g=function(e){(0,f.A)(ChainSigner,e);var t=_createSuper(ChainSigner);function ChainSigner(e,r,n){var i,o=(0,d.N)(n,{key:e,chainCode:y.alloc(32)},r).key.toString("hex");return(i=t.call(this,o,n)).encryptedPrivateKey=e,i.password=r,i.curve=n,i}var r,n=ChainSigner.prototype;return n.getPrvkey=function getPrvkey(){return Promise.resolve((0,d.Yc)(this.password,this.encryptedPrivateKey))},n.getPrvkeyHex=(r=(0,s.A)((function*(){return u.A.bytesToHex(yield this.getPrvkey())})),function getPrvkeyHex(){return r.apply(this,arguments)}),n.sign=function sign(e){var t=(0,d._S)(this.curve,this.encryptedPrivateKey,e,this.password);return"secp256k1"===this.curve?Promise.resolve([t.slice(0,-1),t[t.length-1]]):Promise.resolve([t,0])},(0,a.A)(ChainSigner)}(function(){function Verifier(e,t){this.curve=t,this.compressedPublicKey=y.from(e,"hex"),this.uncompressedPublicKey=(0,d.sA)(t,this.compressedPublicKey)}var e,t=Verifier.prototype;return t.getPubkey=function getPubkey(e){return Promise.resolve(e?this.compressedPublicKey:this.uncompressedPublicKey)},t.getPubkeyHex=(e=(0,s.A)((function*(e){return u.A.bytesToHex(yield this.getPubkey(e))})),function getPubkeyHex(t){return e.apply(this,arguments)}),t.verify=function verify(){return Promise.resolve(y.from([]))},t.verifySignature=function verifySignature({publicKey:e,digest:t,signature:r}){var n=u.A.toBuffer(e),i=u.A.toBuffer(t),o=u.A.toBuffer(r),{curve:s}=this,a=(0,d.MX)(s,n,i,o);return Promise.resolve(a)},(0,a.A)(Verifier)}());function ownKeys(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function _objectSpread(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?ownKeys(Object(r),!0).forEach((function(t){(0,o.A)(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):ownKeys(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}var w=function(){function CoreChainApiBase(){}var e,t,r,n,o,f,h,v,y=CoreChainApiBase.prototype;return y.baseGetCurve=function baseGetCurve(e){switch(e){case"ed25519":return d.ev;case"secp256k1":return d.bI;case"nistp256":return d.OX;default:throw new c.He("Unsupported curve")}},y.baseCreateSigner=(e=(0,s.A)((function*({curve:e,privateKey:t,password:r}){if(void 0===r)throw new c.He("Software signing requires a password.");var n=u.A.toBuffer(t);return Promise.resolve(new g(n,r,e))})),function baseCreateSigner(t){return e.apply(this,arguments)}),y.baseGetSingleSigner=(t=(0,s.A)((function*({payload:e,curve:t}){var r=yield this.getPrivateKeys(e),n=e.account.path,i=r[n],o=e?.relPaths?.[0];if(!i&&o&&(i=r[[n,o].join("/")]),!i)throw new Error(`No private key found: ${n}`);return this.baseCreateSigner({curve:t,privateKey:i,password:e.password})})),function baseGetSingleSigner(e){return t.apply(this,arguments)}),y.baseGetPrivateKeys=(r=(0,s.A)((function*({payload:e,curve:t}){var{credentials:r,account:n,password:i,relPaths:o}=e,s={};if(r.hd&&r.imported)throw new c.He("getPrivateKeys ERROR: hd and imported credentials can NOT both set.");if(r.hd&&(s=yield this.baseGetPrivateKeysHd({curve:t,account:n,hdCredential:r.hd,password:i,relPaths:o})),r.imported){var{privateKey:a}=(0,d.VV)({password:i,credential:r.imported}),p=u.A.bytesToHex((0,d.w)(i,a));s[n.path]=p,s[""]=p}if(!Object.keys(s).length)throw new Error("No private keys found");return s})),function baseGetPrivateKeys(e){return r.apply(this,arguments)}),y.baseGetPrivateKeysHd=(n=(0,s.A)((function*({curve:e,password:t,account:r,relPaths:n,hdCredential:i}){var{path:o}=r,s=o.split("/"),a=n||[s.pop()],p=s.join("/");if(0===a.length)throw new c.He("getPrivateKeysHd ERROR: relPaths is empty.");return(0,d.Wu)(e,i,t,p,a).reduce((function(e,t){return _objectSpread(_objectSpread({},e),{},{[t.path]:u.A.bytesToHex(t.extendedKey.key)})}),{})})),function baseGetPrivateKeysHd(e){return n.apply(this,arguments)}),y.baseGetAddressesFromHd=(o=(0,s.A)((function*(e,t){var r=this,{curve:n,generateFrom:o}=t,{template:a,hdCredential:p,password:f,indexes:h}=e,{pathPrefix:v,pathSuffix:y}=(0,l.Ah)(a),g=h.map((function(e){return y.replace("{index}",e.toString())})),w="privateKey"===o,b=[],P=[];w?P=(0,d.Wu)(n,p,f,v,g):b=(0,d.W6)(n,p,f,v,g);var k=w?P:b;if(k.length!==h.length)throw new c.He("Unable to get publick key.");var x,A=yield Promise.all(k.map((x=(0,s.A)((function*(t){var n,o,{path:s,extendedKey:{key:a}}=t;if(w){var c=u.A.bytesToHex((0,d.Yc)(f,a));o=yield r.getAddressFromPrivate({networkInfo:e.networkInfo,privateKeyRaw:c,privateKeyInfo:t})}else n=a.toString("hex"),o=yield r.getAddressFromPublic({networkInfo:e.networkInfo,publicKey:n,publicKeyInfo:t});return i()({publicKey:n,path:s},o)})),function(e){return x.apply(this,arguments)})));return{addresses:A}})),function baseGetAddressesFromHd(e,t){return o.apply(this,arguments)}),y.baseGetCredentialsType=function baseGetCredentialsType({credentials:e}){if(e.hd&&e.imported)throw new c.He("getCredentialsType ERROR: hd and imported credentials can NOT both set.");if(e.hd)return p.ECoreCredentialType.hd;if(e.imported)return p.ECoreCredentialType.imported;throw new c.He("getCredentialsType ERROR: no credentials found")},y.baseGetDefaultPrivateKey=(f=(0,s.A)((function*(e){var t=yield this.getPrivateKeys(e),[r]=Object.values(t);return{privateKeyRaw:r}})),function baseGetDefaultPrivateKey(e){return f.apply(this,arguments)}),y.validateXpub=(h=(0,s.A)((function*(e){throw new c.MS})),function validateXpub(e){return h.apply(this,arguments)}),y.validateXprvt=(v=(0,s.A)((function*(e){throw new c.MS})),function validateXprvt(e){return v.apply(this,arguments)}),(0,a.A)(CoreChainApiBase)}()},862157:(e,t,r)=>{"use strict";r.r(t),r.d(t,{default:()=>a});var n=r(230414),i=r(929296),o=r(195309),s=r(972715);function _createSuper(e){var t=_isNativeReflectConstruct();return function _createSuperInternal(){var r,n=(0,s.A)(e);if(t){var i=(0,s.A)(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return(0,o.A)(this,r)}}function _isNativeReflectConstruct(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(_isNativeReflectConstruct=function(){return!!e})()}var a=function(e){(0,i.A)(CoreChainHd,e);var t=_createSuper(CoreChainHd);function CoreChainHd(){return t.apply(this,arguments)}return(0,n.A)(CoreChainHd)}(r(681092).A)},681092:(e,t,r)=>{"use strict";r.d(t,{A:()=>E});var n=r(586330),i=r(230414),o=r(929296),s=r(195309),a=r(972715),c=r(717288),u=r(167612),d=r(826412),p=r(236989),l=r.n(p),f=r(529848),h=r.n(f),v=r(377820),y=r(557503),g=r(928557),w=r(507140),b=r(825145),P=r(606777),k=r(161024),x=r(940916),A=r(554902),S=r(404727),m=r(180556),C=r(824116),T=r(305719),K=r(901048).Buffer;function _createSuper(e){var t=_isNativeReflectConstruct();return function _createSuperInternal(){var r,n=(0,a.A)(e);if(t){var i=(0,a.A)(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return(0,s.A)(this,r)}}function _isNativeReflectConstruct(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(_isNativeReflectConstruct=function(){return!!e})()}var B="secp256k1",validator=function(e,t,r){return(0,A.MX)(B,e,t,r)},bip0322Hash=function(e){var{sha256:t}=u.Et,r=t(K.from("BIP0322-signed-message"));return t(K.concat([r,r,K.from(e)])).toString("hex")},E=function(e){(0,o.A)(CoreChainSoftwareBtc,e);var t=_createSuper(CoreChainSoftwareBtc);function CoreChainSoftwareBtc(){return t.apply(this,arguments)}var r,s,a,p,f,x,E,I,R,F,H,O,N,X,j,_,G,M,V,$,L=CoreChainSoftwareBtc.prototype;return L.getCoinName=(r=(0,n.A)((function*({network:e}){return Promise.resolve(e.isTestnet?"TEST":"BTC")})),function getCoinName(e){return r.apply(this,arguments)}),L.getXpubRegex=(s=(0,n.A)((function*({btcForkNetwork:e}){return e.networkChainCode===y.Tv.btc.code?"^[xyz]pub":e.networkChainCode===y.Tv.tbtc.code||e.networkChainCode===y.Tv.sbtc.code?"^[tuv]pub":""})),function getXpubRegex(e){return s.apply(this,arguments)}),L.getXprvtRegex=(a=(0,n.A)((function*({btcForkNetwork:e}){return e.networkChainCode===y.Tv.btc.code?"^[xyz]prv":e.networkChainCode===y.Tv.tbtc.code||e.networkChainCode===y.Tv.sbtc.code?"^[tuv]prv":""})),function getXprvtRegex(e){return a.apply(this,arguments)}),L.validateXprvt=(p=(0,n.A)((function*(e){var{xprvt:t,btcForkNetwork:r}=e;return Promise.resolve((0,C.validateBtcXprvt)({xprvt:t,regex:yield this.getXprvtRegex({btcForkNetwork:r})}))})),function validateXprvt(e){return p.apply(this,arguments)}),L.validateXpub=(f=(0,n.A)((function*(e){var{xpub:t,btcForkNetwork:r}=e;return Promise.resolve((0,C.validateBtcXpub)({xpub:t,regex:yield this.getXpubRegex({btcForkNetwork:r})}))})),function validateXpub(e){return f.apply(this,arguments)}),L.decodeAddress=function decodeAddress(e){return e},L.encodeAddress=function encodeAddress(e){return e},L.getPsbt=function getPsbt({network:e}){return new u.iL({network:e})},L.getExportedSecretKey=(x=(0,n.A)((function*(e){var{account:t,keyType:r,addressEncoding:n,networkInfo:i,password:o,credentials:s}=e,{privateKeyRaw:a}=yield this.baseGetDefaultPrivateKey(e);if(!a)throw new Error("privateKeyRaw is required");if(r===S.ECoreApiExportedSecretKeyType.xprvt){if(s.hd){if(!n)throw new Error("addressEncoding is required");if(!t.xpub)throw new Error("xpub is required");var c=(0,C.getBtcForkNetwork)(i?.networkChainCode),u=(0,C.getBtcForkVersionBytesByAddressEncoding)({addressEncoding:n,btcForkNetwork:c}).private;if(!u)throw new Error("xprvVersionBytes not found");return h().encode(K.from(h().decode(t.xpub)).fill((0,C.btcForkVersionBytesToBuffer)({versionBytes:u}),0,4).fill(K.concat([K.from([0]),(0,A.Yc)(o,a)]),45,78))}if(s.imported)return h().encode((0,A.Yc)(o,a))}throw new Error(`SecretKey type not support: ${r}`)})),function getExportedSecretKey(e){return x.apply(this,arguments)}),L.getAddressFromPublic=(E=(0,n.A)((function*(e){var{networkInfo:t,publicKey:r,addressEncoding:n}=e,i=(0,C.getBtcForkNetwork)(t.networkChainCode),o=r,{addresses:s,xpubSegwit:a}=yield this.getAddressFromXpub({network:i,xpub:o,relativePaths:["0/0"],addressEncoding:n});return{address:s["0/0"],publicKey:"",xpub:o,xpubSegwit:a,addresses:s}})),function getAddressFromPublic(e){return E.apply(this,arguments)}),L.getAddressFromXpub=(I=(0,n.A)((function*({network:e,xpub:t,relativePaths:r,addressEncoding:n}){return(0,C.getAddressFromXpub)({curve:B,network:e,xpub:t,relativePaths:r,addressEncoding:n,encodeAddress:this.encodeAddress.bind(this)})})),function getAddressFromXpub(e){return I.apply(this,arguments)}),L.buildSignersMap=(R=(0,n.A)((function*({payload:e}){var{password:t}=e,r=yield this.getPrivateKeysInFullPath({payload:e}),n=e?.btcExtraInfo?.pathToAddresses,i={};for(var[o,s]of Object.entries(r)){var a=n?.[o]?.address;if(!a)throw new Error("getSignersMap ERROR: address is required, is privateKeys including fullPath?");var c=yield this.buildSignerBtc({privateKey:s,password:t});i[a]=c}return i})),function buildSignersMap(e){return R.apply(this,arguments)}),L.buildSignerBtc=function buildSignerBtc({privateKey:e,password:t}){return this.baseCreateSigner({curve:B,privateKey:e,password:t})},L.getBitcoinSignerPro=(F=(0,n.A)((function*({network:e,signer:t,input:r}){var i,o=yield t.getPubkey(!0);if((0,d.isTaprootInput)(r)){var s=!0;if(r.tapLeafScript&&r.tapLeafScript?.length>0&&!r.tapMerkleRoot&&r.tapLeafScript.forEach((function(e){e.controlBlock&&e.script&&(s=!1)})),r.tapInternalKey){var a=yield t.getPrvkey();return(0,C.tweakSigner)(a,o,{network:e,needTweak:s})}}return{publicKey:o,sign:(i=(0,n.A)((function*(e){var[r]=yield t.sign(e);return r})),function sign(e){return i.apply(this,arguments)})}})),function getBitcoinSignerPro(e){return F.apply(this,arguments)}),L.packTransactionToPSBT=(H=(0,n.A)((function*({network:e,signers:t,payload:r}){var i,o=this,{unsignedTx:s,btcExtraInfo:a}=r,c=yield(0,T.U7)({network:e,unsignedTx:s,btcExtraInfo:a,getPsbt:function(e){return o.getPsbt({network:e.network})},buildInputMixinInfo:(i=(0,n.A)((function*({address:e}){var r=o.pickSigner(t,e);return Promise.resolve({pubkey:yield r.getPubkey(!0)})})),function buildInputMixinInfo(e){return i.apply(this,arguments)})});return c})),function packTransactionToPSBT(e){return H.apply(this,arguments)}),L.appendImportedRelPathPrivateKeys=function appendImportedRelPathPrivateKeys({privateKeys:e,password:t,relPaths:r}){var n=new A.UV(K.from("Bitcoin seed"),A.bI),i=e[""],o=(0,A.Yc)(t,P.A.toBuffer(i)),s={chainCode:o.slice(13,45),key:o.slice(46,78)},a={};return r?.forEach((function(r){var i=r.split("/"),o="",c=s;i.forEach((function(e){if(o=o.length>0?`${o}/${e}`:e,void 0===a[o]){var t=e.endsWith("'")?parseInt(e.slice(0,-1),10)+2**31:parseInt(e,10),r=n.CKDPriv(c,t);a[o]=r}c=a[o]})),e[r]=P.A.bytesToHex((0,A.w)(t,a[r].key))})),e},L.getPrivateKeysInFullPath=(O=(0,n.A)((function*({payload:e}){var t=(0,b.wT)(e.btcExtraInfo),r=yield this.getPrivateKeys(e),n=!!e.credentials.imported,{pathToAddresses:i}=t,o=(0,b.wT)(e.networkInfo.networkImpl),s={};for(var[a,{address:c,relPath:u}]of Object.entries(i)){var d=n?u:a,p=r[d];if(o===g.Jj&&(p||(p=r[d.replace("m/86'/0'/","m/86'/1'/")]),p||(p=r[d.replace("m/86'/1'/","m/86'/0'/")])),c!=c)throw new Error("addressFromPrivateKey and utxoAddress not matched");if(!p)throw new Error(`privateKey not found: ${c} ${a}`);s[a]=p}return s})),function getPrivateKeysInFullPath(e){return O.apply(this,arguments)}),L.signBip322MessageSimple=(N=(0,n.A)((function*({encodedTx:e,account:t,message:r,signers:n,psbtNetwork:i}){(0,C.initBitcoinEcc)();var o=(0,C.validateBtcAddress)({address:t.address,network:i});if(!o.isValid)throw new Error("Invalid address");var s=[S.EAddressEncodings.P2WPKH,S.EAddressEncodings.P2TR];if(!o.encoding||o.encoding&&!s.includes(o.encoding))throw new w.Jz;var a=u.hl.toOutputScript(t.address,i),c=K.from("0000000000000000000000000000000000000000000000000000000000000000","hex"),d=K.concat([K.from("0020","hex"),K.from(bip0322Hash(r),"hex")]),p=new u.ZX;p.version=0,p.addInput(c,4294967295,0,d),p.addOutput(a,0);var l=new u.iL;l.setVersion(0),l.addInput({hash:p.getHash(),index:0,sequence:0,witnessUtxo:{script:a,value:0}}),l.addOutput({script:K.from("6a","hex"),value:0});var f=(0,C.getInputsToSignFromPsbt)({psbt:l,psbtNetwork:i,account:t,isBtcWalletProvider:!1});yield this.signPsbt({encodedTx:e,psbt:l,signers:n,inputsToSign:f,network:i}),f.forEach((function(e){l.finalizeInput(e.index)}));var h=l.extractTransaction(),y=(0,v.encode)(h.ins[0].witness.length);return K.concat([y,...h.ins[0].witness.map((function(e){return t=e,K.concat([(0,v.encode)(t.byteLength),t]);var t}))])})),function signBip322MessageSimple(e){return N.apply(this,arguments)}),L.signPsbt=(X=(0,n.A)((function*({encodedTx:e,network:t,psbt:r,signers:n,inputsToSign:i}){for(var o=0,s=i.length;o<s;o+=1){var a=i[o],c=this.pickSigner(n,a.address),u=yield this.getBitcoinSignerPro({network:t,signer:c,input:r.data.inputs[a.index]});yield r.signInputAsync(a.index,u,a.sighashTypes)}return{encodedTx:e,txid:"",rawTx:"",psbtHex:r.toHex()}})),function signPsbt(e){return X.apply(this,arguments)}),L.getPrivateKeys=(j=(0,n.A)((function*(e){var{password:t,relPaths:r}=e,n=!!e.credentials.imported,i=yield this.baseGetPrivateKeys({payload:e,curve:B});return n&&this.appendImportedRelPathPrivateKeys({privateKeys:i,password:t,relPaths:r}),i})),function getPrivateKeys(e){return j.apply(this,arguments)}),L.getAddressFromPrivate=(_=(0,n.A)((function*(e){var{privateKeyRaw:t,networkInfo:r,addressEncoding:n}=e,i=(0,C.getBtcForkNetwork)(r.networkChainCode),{xpub:o}=(0,C.getBtcXpubFromXprvt)({privateKeyRaw:t,network:i}),s=(0,C.getPublicKeyFromXpub)({xpub:o,network:i,relPath:"0/0"}),a=n,c="0/0",{addresses:u,xpubSegwit:d}=yield this.getAddressFromXpub({network:i,xpub:o,relativePaths:[c],addressEncoding:a}),{[c]:p}=u;return Promise.resolve({publicKey:s,xpub:o,xpubSegwit:d,relPath:c,address:p,addresses:u})})),function getAddressFromPrivate(e){return _.apply(this,arguments)}),L.getAddressesFromHd=(G=(0,n.A)((function*(e){var t=this,{template:r,hdCredential:i,password:o,indexes:s,networkInfo:{networkChainCode:a},addressEncoding:u}=e,{pathPrefix:d}=(0,m.Ah)(r),p=s.map((function(e){return`${e.toString()}'`})),l=(0,A.W6)(B,i,o,d,p);if(l.length!==s.length)throw new w.He("Unable to get publick key.");if(!a)throw new Error("networkChainCode is required");var f,v=(0,C.getBtcForkNetwork)(a),{public:y}=(v.segwitVersionBytes||{})[u]||v.bip32,g=(0,A.s8)(i,o),b=(0,C.getBitcoinBip32)().fromSeed((0,c.mnemonicToSeedSync)(g)),P=[K.from(y.toString(16).padStart(8,"0"),"hex"),K.from([3])],k=yield Promise.all(l.map((f=(0,n.A)((function*(e,r){var{path:n,parentFingerPrint:a,extendedKey:c}=e,d=b.derivePath(`${n}/0/0`),p=(0,C.getBitcoinECPair)().fromWIF(d.toWIF()).publicKey.toString("hex"),l=h().encode(K.concat([...P,a,K.from((s[r]+2**31).toString(16).padStart(8,"0"),"hex"),c.chainCode,c.key])),f="0/0",y=[f],{addresses:g,xpubSegwit:w}=yield t.getAddressFromXpub({network:v,xpub:l,relativePaths:y,addressEncoding:u}),{[f]:k}=g;return{address:k,publicKey:p,path:n,relPath:f,xpub:l,xpubSegwit:(0,C.buildBtcXpubSegwit)({xpub:l,addressEncoding:u,hdAccountPayload:{curveName:B,hdCredential:i,password:o,path:n}}),addresses:{[f]:k}}})),function(e,t){return f.apply(this,arguments)})));return{addresses:k}})),function getAddressesFromHd(e){return G.apply(this,arguments)}),L.signTransaction=(M=(0,n.A)((function*(e){var{unsignedTx:t,networkInfo:{networkChainCode:r},relPaths:n}=e,i=t.encodedTx,{psbtHex:o,inputsToSign:s}=i;if(!n?.length)throw new Error("BTC sign transaction need relPaths");var a=(0,C.getBtcForkNetwork)(r),c=yield this.buildSignersMap({payload:e});if(o&&s){u.iL;var d=u.iL.fromHex(o,{network:a}),p=(d.data.inputs[0].witnessScript,d.data.inputs[0].witnessUtxo?.script),l=u.KT;try{var f=l.p2tr({output:p,network:a});f?.pubkey?.toString("hex")}catch(e){}try{var h=u.KT.p2pkh({output:p,network:a});h?.pubkey?.toString("hex")}catch(e){}try{var v=u.KT.p2sh({output:p,network:a});v?.pubkey?.toString("hex")}catch(e){}try{var y=u.KT.p2wpkh({output:p,network:a});y?.pubkey?.toString("hex")}catch(e){}try{var g=u.KT.p2wsh({output:p,network:a});g?.pubkey?.toString("hex")}catch(e){}return this.signPsbt({encodedTx:t.encodedTx,network:a,psbt:d,signers:c,inputsToSign:s})}for(var w=yield this.packTransactionToPSBT({network:a,signers:c,payload:e}),b=0;b<i.inputs.length;++b){var{address:P}=i.inputs[b],k=this.pickSigner(c,P),x=w.data.inputs[0],A=yield this.getBitcoinSignerPro({signer:k,input:x,network:a});yield w.signInputAsync(b,A)}var{txid:S,rawTx:m}=yield this.extractPsbtToSignedTx({psbt:w});return{encodedTx:t.encodedTx,txid:S,rawTx:m,psbtHex:void 0}})),function signTransaction(e){return M.apply(this,arguments)}),L.extractPsbtToSignedTx=(V=(0,n.A)((function*({psbt:e}){var t;e.validateSignaturesOfAllInputs(validator);try{t=e.finalizeAllInputs().extractTransaction()}catch(e){throw e}var r={txid:t.getId(),rawTx:t.toHex()};return Promise.resolve(r)})),function extractPsbtToSignedTx(e){return V.apply(this,arguments)}),L.pickSigner=function pickSigner(e,t){var r=e[t];if(!r)throw new Error(`BTC signer not found: ${t}`);return r},L.signMessage=($=(0,n.A)((function*(e){var{account:t,networkInfo:{networkChainCode:r},relPaths:n}=e;if(!n?.length)throw new Error("BTC sign message need relPaths");var i=e.unsignedMsg,o=(0,C.getBtcForkNetwork)(r),s=yield this.buildSignersMap({payload:e});if(i.type===k.nc.BIP322_SIMPLE){var a=yield this.signBip322MessageSimple({encodedTx:null,account:t,message:i.message,signers:s,psbtNetwork:o});return P.A.bytesToHex(a)}var c=this.pickSigner(s,t.address),u=yield c.getPrvkey(),d=(0,C.getBitcoinECPair)().fromPrivateKey(u,{network:o}),p=i.sigOptions||{segwitType:"p2wpkh"},f=l().sign(i.message,(0,b.wT)(d.privateKey),d.compressed,p);return P.A.bytesToHex(f)})),function signMessage(e){return $.apply(this,arguments)}),(0,i.A)(CoreChainSoftwareBtc)}(x.G)},180556:(e,t,r)=>{"use strict";r.d(t,{Ac:()=>estimateTxSize,Ah:()=>slicePathTemplate,vN:()=>getUtxoAccountPrefixPath,zf:()=>getBIP44Path});var n=r(90366),i=r.n(n),o=r(928557);function slicePathTemplate(e){var[t,r]=e.split(o.h2);return{pathPrefix:t.slice(0,-1),pathSuffix:`{index}${r}`}}function getUtxoAccountPrefixPath({fullPath:e}){var t=e.split("/");return t.pop(),t.pop(),t.join("/")}function getBIP44Path(e,t){var r="";for(var[n,i]of Object.entries(e.addresses))if(i===t){r=n;break}return`${e.path}/${r}`}function estimateTxSize(e,t){return i().transactionBytes(e,t)}},879314:()=>{}}]);