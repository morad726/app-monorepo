/*! For license information please see 12024.ee0aa33747.chunk.js.LICENSE.txt */
"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[12024],{110069:(e,r,n)=>{n.r(r),n.d(r,{ACCOUNT_DISCRIMINATOR_SIZE:()=>Hi,AccountClient:()=>En,AnchorError:()=>vt,AnchorProvider:()=>st,BN:()=>w(),BorshAccountsCoder:()=>Nt,BorshCoder:()=>Kt,BorshEventCoder:()=>Rt,BorshInstructionCoder:()=>Tt,BorshStateCoder:()=>Ut,EventManager:()=>xn,EventParser:()=>Pn,IdlError:()=>gt,LangErrorCode:()=>Wi,LangErrorMessage:()=>qi,MethodsBuilderFactory:()=>Nn,Native:()=>Yn,Program:()=>Vn,ProgramError:()=>bt,ProgramErrorStack:()=>wt,Spl:()=>Jn,SplTokenCoder:()=>Ne,StateClient:()=>_n,SystemCoder:()=>Qe,eventDiscriminator:()=>Vt,getProvider:()=>lt,parseIdlErrors:()=>M,setProvider:()=>dt,splitArgsAndCtx:()=>wn,stateDiscriminator:()=>jt,toInstruction:()=>x,translateAddress:()=>L,translateError:()=>At,utils:()=>fo,validateAccounts:()=>P,web3:()=>s});var i=n(901048),s=n(384431),a=n(682823),w=n.n(a),k=n(939216),I=n.n(k),we=n(807991),Ae=n(675832),Ce=n.n(Ae),Be=n(180235),ze=n(208674);function zero$1(e){let r=e.length;for(;--r>=0;)e[r]=0}const qe=256,$e=286,Ye=30,Je=15,et=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),rt=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),it=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),ot=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),ht=new Array(576);zero$1(ht);const ft=new Array(60);zero$1(ft);const pt=new Array(512);zero$1(pt);const yt=new Array(256);zero$1(yt);const _t=new Array(29);zero$1(_t);const St=new Array(Ye);function StaticTreeDesc(e,r,n,i,s){this.static_tree=e,this.extra_bits=r,this.extra_base=n,this.elems=i,this.max_length=s,this.has_stree=e&&e.length}let kt,Dt,Mt;function TreeDesc(e,r){this.dyn_tree=e,this.max_code=0,this.stat_desc=r}zero$1(St);const d_code=e=>e<256?pt[e]:pt[256+(e>>>7)],put_short=(e,r)=>{e.pending_buf[e.pending++]=255&r,e.pending_buf[e.pending++]=r>>>8&255},send_bits=(e,r,n)=>{e.bi_valid>16-n?(e.bi_buf|=r<<e.bi_valid&65535,put_short(e,e.bi_buf),e.bi_buf=r>>16-e.bi_valid,e.bi_valid+=n-16):(e.bi_buf|=r<<e.bi_valid&65535,e.bi_valid+=n)},send_code=(e,r,n)=>{send_bits(e,n[2*r],n[2*r+1])},bi_reverse=(e,r)=>{let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--r>0);return n>>>1},gen_codes=(e,r,n)=>{const i=new Array(16);let s,a,w=0;for(s=1;s<=Je;s++)w=w+n[s-1]<<1,i[s]=w;for(a=0;a<=r;a++){let r=e[2*a+1];0!==r&&(e[2*a]=bi_reverse(i[r]++,r))}},init_block=e=>{let r;for(r=0;r<$e;r++)e.dyn_ltree[2*r]=0;for(r=0;r<Ye;r++)e.dyn_dtree[2*r]=0;for(r=0;r<19;r++)e.bl_tree[2*r]=0;e.dyn_ltree[512]=1,e.opt_len=e.static_len=0,e.sym_next=e.matches=0},bi_windup=e=>{e.bi_valid>8?put_short(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0},smaller=(e,r,n,i)=>{const s=2*r,a=2*n;return e[s]<e[a]||e[s]===e[a]&&i[r]<=i[n]},pqdownheap=(e,r,n)=>{const i=e.heap[n];let s=n<<1;for(;s<=e.heap_len&&(s<e.heap_len&&smaller(r,e.heap[s+1],e.heap[s],e.depth)&&s++,!smaller(r,i,e.heap[s],e.depth));)e.heap[n]=e.heap[s],n=s,s<<=1;e.heap[n]=i},compress_block=(e,r,n)=>{let i,s,a,w,k=0;if(0!==e.sym_next)do{i=255&e.pending_buf[e.sym_buf+k++],i+=(255&e.pending_buf[e.sym_buf+k++])<<8,s=e.pending_buf[e.sym_buf+k++],0===i?send_code(e,s,r):(a=yt[s],send_code(e,a+qe+1,r),w=et[a],0!==w&&(s-=_t[a],send_bits(e,s,w)),i--,a=d_code(i),send_code(e,a,n),w=rt[a],0!==w&&(i-=St[a],send_bits(e,i,w)))}while(k<e.sym_next);send_code(e,256,r)},build_tree=(e,r)=>{const n=r.dyn_tree,i=r.stat_desc.static_tree,s=r.stat_desc.has_stree,a=r.stat_desc.elems;let w,k,I,we=-1;for(e.heap_len=0,e.heap_max=573,w=0;w<a;w++)0!==n[2*w]?(e.heap[++e.heap_len]=we=w,e.depth[w]=0):n[2*w+1]=0;for(;e.heap_len<2;)I=e.heap[++e.heap_len]=we<2?++we:0,n[2*I]=1,e.depth[I]=0,e.opt_len--,s&&(e.static_len-=i[2*I+1]);for(r.max_code=we,w=e.heap_len>>1;w>=1;w--)pqdownheap(e,n,w);I=a;do{w=e.heap[1],e.heap[1]=e.heap[e.heap_len--],pqdownheap(e,n,1),k=e.heap[1],e.heap[--e.heap_max]=w,e.heap[--e.heap_max]=k,n[2*I]=n[2*w]+n[2*k],e.depth[I]=(e.depth[w]>=e.depth[k]?e.depth[w]:e.depth[k])+1,n[2*w+1]=n[2*k+1]=I,e.heap[1]=I++,pqdownheap(e,n,1)}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],((e,r)=>{const n=r.dyn_tree,i=r.max_code,s=r.stat_desc.static_tree,a=r.stat_desc.has_stree,w=r.stat_desc.extra_bits,k=r.stat_desc.extra_base,I=r.stat_desc.max_length;let we,Ae,Ce,Be,ze,qe,$e=0;for(Be=0;Be<=Je;Be++)e.bl_count[Be]=0;for(n[2*e.heap[e.heap_max]+1]=0,we=e.heap_max+1;we<573;we++)Ae=e.heap[we],Be=n[2*n[2*Ae+1]+1]+1,Be>I&&(Be=I,$e++),n[2*Ae+1]=Be,Ae>i||(e.bl_count[Be]++,ze=0,Ae>=k&&(ze=w[Ae-k]),qe=n[2*Ae],e.opt_len+=qe*(Be+ze),a&&(e.static_len+=qe*(s[2*Ae+1]+ze)));if(0!==$e){do{for(Be=I-1;0===e.bl_count[Be];)Be--;e.bl_count[Be]--,e.bl_count[Be+1]+=2,e.bl_count[I]--,$e-=2}while($e>0);for(Be=I;0!==Be;Be--)for(Ae=e.bl_count[Be];0!==Ae;)Ce=e.heap[--we],Ce>i||(n[2*Ce+1]!==Be&&(e.opt_len+=(Be-n[2*Ce+1])*n[2*Ce],n[2*Ce+1]=Be),Ae--)}})(e,r),gen_codes(n,we,e.bl_count)},scan_tree=(e,r,n)=>{let i,s,a=-1,w=r[1],k=0,I=7,we=4;for(0===w&&(I=138,we=3),r[2*(n+1)+1]=65535,i=0;i<=n;i++)s=w,w=r[2*(i+1)+1],++k<I&&s===w||(k<we?e.bl_tree[2*s]+=k:0!==s?(s!==a&&e.bl_tree[2*s]++,e.bl_tree[32]++):k<=10?e.bl_tree[34]++:e.bl_tree[36]++,k=0,a=s,0===w?(I=138,we=3):s===w?(I=6,we=3):(I=7,we=4))},send_tree=(e,r,n)=>{let i,s,a=-1,w=r[1],k=0,I=7,we=4;for(0===w&&(I=138,we=3),i=0;i<=n;i++)if(s=w,w=r[2*(i+1)+1],!(++k<I&&s===w)){if(k<we)do{send_code(e,s,e.bl_tree)}while(0!=--k);else 0!==s?(s!==a&&(send_code(e,s,e.bl_tree),k--),send_code(e,16,e.bl_tree),send_bits(e,k-3,2)):k<=10?(send_code(e,17,e.bl_tree),send_bits(e,k-3,3)):(send_code(e,18,e.bl_tree),send_bits(e,k-11,7));k=0,a=s,0===w?(I=138,we=3):s===w?(I=6,we=3):(I=7,we=4)}};let qt=!1;const _tr_stored_block$1=(e,r,n,i)=>{send_bits(e,0+(i?1:0),3),bi_windup(e),put_short(e,n),put_short(e,~n),n&&e.pending_buf.set(e.window.subarray(r,r+n),e.pending),e.pending+=n};var _tr_flush_block_1=(e,r,n,i)=>{let s,a,w=0;e.level>0?(2===e.strm.data_type&&(e.strm.data_type=(e=>{let r,n=4093624447;for(r=0;r<=31;r++,n>>>=1)if(1&n&&0!==e.dyn_ltree[2*r])return 0;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return 1;for(r=32;r<qe;r++)if(0!==e.dyn_ltree[2*r])return 1;return 0})(e)),build_tree(e,e.l_desc),build_tree(e,e.d_desc),w=(e=>{let r;for(scan_tree(e,e.dyn_ltree,e.l_desc.max_code),scan_tree(e,e.dyn_dtree,e.d_desc.max_code),build_tree(e,e.bl_desc),r=18;r>=3&&0===e.bl_tree[2*ot[r]+1];r--);return e.opt_len+=3*(r+1)+5+5+4,r})(e),s=e.opt_len+3+7>>>3,a=e.static_len+3+7>>>3,a<=s&&(s=a)):s=a=n+5,n+4<=s&&-1!==r?_tr_stored_block$1(e,r,n,i):4===e.strategy||a===s?(send_bits(e,2+(i?1:0),3),compress_block(e,ht,ft)):(send_bits(e,4+(i?1:0),3),((e,r,n,i)=>{let s;for(send_bits(e,r-257,5),send_bits(e,n-1,5),send_bits(e,i-4,4),s=0;s<i;s++)send_bits(e,e.bl_tree[2*ot[s]+1],3);send_tree(e,e.dyn_ltree,r-1),send_tree(e,e.dyn_dtree,n-1)})(e,e.l_desc.max_code+1,e.d_desc.max_code+1,w+1),compress_block(e,e.dyn_ltree,e.dyn_dtree)),init_block(e),i&&bi_windup(e)},Gt={_tr_init:e=>{qt||((()=>{let e,r,n,i,s;const a=new Array(16);for(n=0,i=0;i<28;i++)for(_t[i]=n,e=0;e<1<<et[i];e++)yt[n++]=i;for(yt[n-1]=i,s=0,i=0;i<16;i++)for(St[i]=s,e=0;e<1<<rt[i];e++)pt[s++]=i;for(s>>=7;i<Ye;i++)for(St[i]=s<<7,e=0;e<1<<rt[i]-7;e++)pt[256+s++]=i;for(r=0;r<=Je;r++)a[r]=0;for(e=0;e<=143;)ht[2*e+1]=8,e++,a[8]++;for(;e<=255;)ht[2*e+1]=9,e++,a[9]++;for(;e<=279;)ht[2*e+1]=7,e++,a[7]++;for(;e<=287;)ht[2*e+1]=8,e++,a[8]++;for(gen_codes(ht,287,a),e=0;e<Ye;e++)ft[2*e+1]=5,ft[2*e]=bi_reverse(e,5);kt=new StaticTreeDesc(ht,et,257,$e,Je),Dt=new StaticTreeDesc(ft,rt,0,Ye,Je),Mt=new StaticTreeDesc(new Array(0),it,0,19,7)})(),qt=!0),e.l_desc=new TreeDesc(e.dyn_ltree,kt),e.d_desc=new TreeDesc(e.dyn_dtree,Dt),e.bl_desc=new TreeDesc(e.bl_tree,Mt),e.bi_buf=0,e.bi_valid=0,init_block(e)},_tr_stored_block:_tr_stored_block$1,_tr_flush_block:_tr_flush_block_1,_tr_tally:(e,r,n)=>(e.pending_buf[e.sym_buf+e.sym_next++]=r,e.pending_buf[e.sym_buf+e.sym_next++]=r>>8,e.pending_buf[e.sym_buf+e.sym_next++]=n,0===r?e.dyn_ltree[2*n]++:(e.matches++,r--,e.dyn_ltree[2*(yt[n]+qe+1)]++,e.dyn_dtree[2*d_code(r)]++),e.sym_next===e.sym_end),_tr_align:e=>{send_bits(e,2,3),send_code(e,256,ht),(e=>{16===e.bi_valid?(put_short(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)})(e)}};var adler32_1=(e,r,n,i)=>{let s=65535&e,a=e>>>16&65535,w=0;for(;0!==n;){w=n>2e3?2e3:n,n-=w;do{s=s+r[i++]|0,a=a+s|0}while(--w);s%=65521,a%=65521}return s|a<<16};const Qt=new Uint32Array((()=>{let e,r=[];for(var n=0;n<256;n++){e=n;for(var i=0;i<8;i++)e=1&e?3988292384^e>>>1:e>>>1;r[n]=e}return r})());var crc32_1=(e,r,n,i)=>{const s=Qt,a=i+n;e^=-1;for(let n=i;n<a;n++)e=e>>>8^s[255&(e^r[n])];return~e},er={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},tr={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:rr,_tr_stored_block:nr,_tr_flush_block:ir,_tr_tally:or,_tr_align:sr}=Gt,{Z_NO_FLUSH:ar,Z_PARTIAL_FLUSH:cr,Z_FULL_FLUSH:ur,Z_FINISH:dr,Z_BLOCK:lr,Z_OK:hr,Z_STREAM_END:fr,Z_STREAM_ERROR:gr,Z_DATA_ERROR:pr,Z_BUF_ERROR:mr,Z_DEFAULT_COMPRESSION:yr,Z_FILTERED:br,Z_HUFFMAN_ONLY:_r,Z_RLE:wr,Z_FIXED:Sr,Z_DEFAULT_STRATEGY:Er,Z_UNKNOWN:kr,Z_DEFLATED:Ar}=tr,Ir=258,Rr=262,vr=42,Or=113,xr=666,err=(e,r)=>(e.msg=er[r],r),rank=e=>2*e-(e>4?9:0),zero=e=>{let r=e.length;for(;--r>=0;)e[r]=0},slide_hash=e=>{let r,n,i,s=e.w_size;r=e.hash_size,i=r;do{n=e.head[--i],e.head[i]=n>=s?n-s:0}while(--r);r=s,i=r;do{n=e.prev[--i],e.prev[i]=n>=s?n-s:0}while(--r)};let HASH=(e,r,n)=>(r<<e.hash_shift^n)&e.hash_mask;const flush_pending=e=>{const r=e.state;let n=r.pending;n>e.avail_out&&(n=e.avail_out),0!==n&&(e.output.set(r.pending_buf.subarray(r.pending_out,r.pending_out+n),e.next_out),e.next_out+=n,r.pending_out+=n,e.total_out+=n,e.avail_out-=n,r.pending-=n,0===r.pending&&(r.pending_out=0))},flush_block_only=(e,r)=>{ir(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,r),e.block_start=e.strstart,flush_pending(e.strm)},put_byte=(e,r)=>{e.pending_buf[e.pending++]=r},putShortMSB=(e,r)=>{e.pending_buf[e.pending++]=r>>>8&255,e.pending_buf[e.pending++]=255&r},read_buf=(e,r,n,i)=>{let s=e.avail_in;return s>i&&(s=i),0===s?0:(e.avail_in-=s,r.set(e.input.subarray(e.next_in,e.next_in+s),n),1===e.state.wrap?e.adler=adler32_1(e.adler,r,s,n):2===e.state.wrap&&(e.adler=crc32_1(e.adler,r,s,n)),e.next_in+=s,e.total_in+=s,s)},longest_match=(e,r)=>{let n,i,s=e.max_chain_length,a=e.strstart,w=e.prev_length,k=e.nice_match;const I=e.strstart>e.w_size-Rr?e.strstart-(e.w_size-Rr):0,we=e.window,Ae=e.w_mask,Ce=e.prev,Be=e.strstart+Ir;let ze=we[a+w-1],qe=we[a+w];e.prev_length>=e.good_match&&(s>>=2),k>e.lookahead&&(k=e.lookahead);do{if(n=r,we[n+w]===qe&&we[n+w-1]===ze&&we[n]===we[a]&&we[++n]===we[a+1]){a+=2,n++;do{}while(we[++a]===we[++n]&&we[++a]===we[++n]&&we[++a]===we[++n]&&we[++a]===we[++n]&&we[++a]===we[++n]&&we[++a]===we[++n]&&we[++a]===we[++n]&&we[++a]===we[++n]&&a<Be);if(i=Ir-(Be-a),a=Be-Ir,i>w){if(e.match_start=r,w=i,i>=k)break;ze=we[a+w-1],qe=we[a+w]}}}while((r=Ce[r&Ae])>I&&0!=--s);return w<=e.lookahead?w:e.lookahead},fill_window=e=>{const r=e.w_size;let n,i,s;do{if(i=e.window_size-e.lookahead-e.strstart,e.strstart>=r+(r-Rr)&&(e.window.set(e.window.subarray(r,r+r-i),0),e.match_start-=r,e.strstart-=r,e.block_start-=r,e.insert>e.strstart&&(e.insert=e.strstart),slide_hash(e),i+=r),0===e.strm.avail_in)break;if(n=read_buf(e.strm,e.window,e.strstart+e.lookahead,i),e.lookahead+=n,e.lookahead+e.insert>=3)for(s=e.strstart-e.insert,e.ins_h=e.window[s],e.ins_h=HASH(e,e.ins_h,e.window[s+1]);e.insert&&(e.ins_h=HASH(e,e.ins_h,e.window[s+3-1]),e.prev[s&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=s,s++,e.insert--,!(e.lookahead+e.insert<3)););}while(e.lookahead<Rr&&0!==e.strm.avail_in)},deflate_stored=(e,r)=>{let n,i,s,a=e.pending_buf_size-5>e.w_size?e.w_size:e.pending_buf_size-5,w=0,k=e.strm.avail_in;do{if(n=65535,s=e.bi_valid+42>>3,e.strm.avail_out<s)break;if(s=e.strm.avail_out-s,i=e.strstart-e.block_start,n>i+e.strm.avail_in&&(n=i+e.strm.avail_in),n>s&&(n=s),n<a&&(0===n&&r!==dr||r===ar||n!==i+e.strm.avail_in))break;w=r===dr&&n===i+e.strm.avail_in?1:0,nr(e,0,0,w),e.pending_buf[e.pending-4]=n,e.pending_buf[e.pending-3]=n>>8,e.pending_buf[e.pending-2]=~n,e.pending_buf[e.pending-1]=~n>>8,flush_pending(e.strm),i&&(i>n&&(i=n),e.strm.output.set(e.window.subarray(e.block_start,e.block_start+i),e.strm.next_out),e.strm.next_out+=i,e.strm.avail_out-=i,e.strm.total_out+=i,e.block_start+=i,n-=i),n&&(read_buf(e.strm,e.strm.output,e.strm.next_out,n),e.strm.next_out+=n,e.strm.avail_out-=n,e.strm.total_out+=n)}while(0===w);return k-=e.strm.avail_in,k&&(k>=e.w_size?(e.matches=2,e.window.set(e.strm.input.subarray(e.strm.next_in-e.w_size,e.strm.next_in),0),e.strstart=e.w_size,e.insert=e.strstart):(e.window_size-e.strstart<=k&&(e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,e.insert>e.strstart&&(e.insert=e.strstart)),e.window.set(e.strm.input.subarray(e.strm.next_in-k,e.strm.next_in),e.strstart),e.strstart+=k,e.insert+=k>e.w_size-e.insert?e.w_size-e.insert:k),e.block_start=e.strstart),e.high_water<e.strstart&&(e.high_water=e.strstart),w?4:r!==ar&&r!==dr&&0===e.strm.avail_in&&e.strstart===e.block_start?2:(s=e.window_size-e.strstart,e.strm.avail_in>s&&e.block_start>=e.w_size&&(e.block_start-=e.w_size,e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,s+=e.w_size,e.insert>e.strstart&&(e.insert=e.strstart)),s>e.strm.avail_in&&(s=e.strm.avail_in),s&&(read_buf(e.strm,e.window,e.strstart,s),e.strstart+=s,e.insert+=s>e.w_size-e.insert?e.w_size-e.insert:s),e.high_water<e.strstart&&(e.high_water=e.strstart),s=e.bi_valid+42>>3,s=e.pending_buf_size-s>65535?65535:e.pending_buf_size-s,a=s>e.w_size?e.w_size:s,i=e.strstart-e.block_start,(i>=a||(i||r===dr)&&r!==ar&&0===e.strm.avail_in&&i<=s)&&(n=i>s?s:i,w=r===dr&&0===e.strm.avail_in&&n===i?1:0,nr(e,e.block_start,n,w),e.block_start+=n,flush_pending(e.strm)),w?3:1)},deflate_fast=(e,r)=>{let n,i;for(;;){if(e.lookahead<Rr){if(fill_window(e),e.lookahead<Rr&&r===ar)return 1;if(0===e.lookahead)break}if(n=0,e.lookahead>=3&&(e.ins_h=HASH(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==n&&e.strstart-n<=e.w_size-Rr&&(e.match_length=longest_match(e,n)),e.match_length>=3)if(i=or(e,e.strstart-e.match_start,e.match_length-3),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=3){e.match_length--;do{e.strstart++,e.ins_h=HASH(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart}while(0!=--e.match_length);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=HASH(e,e.ins_h,e.window[e.strstart+1]);else i=or(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(i&&(flush_block_only(e,!1),0===e.strm.avail_out))return 1}return e.insert=e.strstart<2?e.strstart:2,r===dr?(flush_block_only(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(flush_block_only(e,!1),0===e.strm.avail_out)?1:2},deflate_slow=(e,r)=>{let n,i,s;for(;;){if(e.lookahead<Rr){if(fill_window(e),e.lookahead<Rr&&r===ar)return 1;if(0===e.lookahead)break}if(n=0,e.lookahead>=3&&(e.ins_h=HASH(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=2,0!==n&&e.prev_length<e.max_lazy_match&&e.strstart-n<=e.w_size-Rr&&(e.match_length=longest_match(e,n),e.match_length<=5&&(e.strategy===br||3===e.match_length&&e.strstart-e.match_start>4096)&&(e.match_length=2)),e.prev_length>=3&&e.match_length<=e.prev_length){s=e.strstart+e.lookahead-3,i=or(e,e.strstart-1-e.prev_match,e.prev_length-3),e.lookahead-=e.prev_length-1,e.prev_length-=2;do{++e.strstart<=s&&(e.ins_h=HASH(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart)}while(0!=--e.prev_length);if(e.match_available=0,e.match_length=2,e.strstart++,i&&(flush_block_only(e,!1),0===e.strm.avail_out))return 1}else if(e.match_available){if(i=or(e,0,e.window[e.strstart-1]),i&&flush_block_only(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return 1}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(i=or(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<2?e.strstart:2,r===dr?(flush_block_only(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(flush_block_only(e,!1),0===e.strm.avail_out)?1:2};function Config(e,r,n,i,s){this.good_length=e,this.max_lazy=r,this.nice_length=n,this.max_chain=i,this.func=s}const Tr=[new Config(0,0,0,0,deflate_stored),new Config(4,4,8,4,deflate_fast),new Config(4,5,16,8,deflate_fast),new Config(4,6,32,32,deflate_fast),new Config(4,4,16,16,deflate_slow),new Config(8,16,32,32,deflate_slow),new Config(8,16,128,128,deflate_slow),new Config(8,32,128,256,deflate_slow),new Config(32,128,258,1024,deflate_slow),new Config(32,258,258,4096,deflate_slow)];function DeflateState(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Ar,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),zero(this.dyn_ltree),zero(this.dyn_dtree),zero(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),zero(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),zero(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const deflateStateCheck=e=>{if(!e)return 1;const r=e.state;return!r||r.strm!==e||r.status!==vr&&57!==r.status&&69!==r.status&&73!==r.status&&91!==r.status&&103!==r.status&&r.status!==Or&&r.status!==xr?1:0},deflateResetKeep=e=>{if(deflateStateCheck(e))return err(e,gr);e.total_in=e.total_out=0,e.data_type=kr;const r=e.state;return r.pending=0,r.pending_out=0,r.wrap<0&&(r.wrap=-r.wrap),r.status=2===r.wrap?57:r.wrap?vr:Or,e.adler=2===r.wrap?0:1,r.last_flush=-2,rr(r),hr},deflateReset=e=>{const r=deflateResetKeep(e);var n;return r===hr&&((n=e.state).window_size=2*n.w_size,zero(n.head),n.max_lazy_match=Tr[n.level].max_lazy,n.good_match=Tr[n.level].good_length,n.nice_match=Tr[n.level].nice_length,n.max_chain_length=Tr[n.level].max_chain,n.strstart=0,n.block_start=0,n.lookahead=0,n.insert=0,n.match_length=n.prev_length=2,n.match_available=0,n.ins_h=0),r},deflateInit2=(e,r,n,i,s,a)=>{if(!e)return gr;let w=1;if(r===yr&&(r=6),i<0?(w=0,i=-i):i>15&&(w=2,i-=16),s<1||s>9||n!==Ar||i<8||i>15||r<0||r>9||a<0||a>Sr||8===i&&1!==w)return err(e,gr);8===i&&(i=9);const k=new DeflateState;return e.state=k,k.strm=e,k.status=vr,k.wrap=w,k.gzhead=null,k.w_bits=i,k.w_size=1<<k.w_bits,k.w_mask=k.w_size-1,k.hash_bits=s+7,k.hash_size=1<<k.hash_bits,k.hash_mask=k.hash_size-1,k.hash_shift=~~((k.hash_bits+3-1)/3),k.window=new Uint8Array(2*k.w_size),k.head=new Uint16Array(k.hash_size),k.prev=new Uint16Array(k.w_size),k.lit_bufsize=1<<s+6,k.pending_buf_size=4*k.lit_bufsize,k.pending_buf=new Uint8Array(k.pending_buf_size),k.sym_buf=k.lit_bufsize,k.sym_end=3*(k.lit_bufsize-1),k.level=r,k.strategy=a,k.method=n,deflateReset(e)};var Nr={deflateInit:(e,r)=>deflateInit2(e,r,Ar,15,8,Er),deflateInit2,deflateReset,deflateResetKeep,deflateSetHeader:(e,r)=>deflateStateCheck(e)||2!==e.state.wrap?gr:(e.state.gzhead=r,hr),deflate:(e,r)=>{if(deflateStateCheck(e)||r>lr||r<0)return e?err(e,gr):gr;const n=e.state;if(!e.output||0!==e.avail_in&&!e.input||n.status===xr&&r!==dr)return err(e,0===e.avail_out?mr:gr);const i=n.last_flush;if(n.last_flush=r,0!==n.pending){if(flush_pending(e),0===e.avail_out)return n.last_flush=-1,hr}else if(0===e.avail_in&&rank(r)<=rank(i)&&r!==dr)return err(e,mr);if(n.status===xr&&0!==e.avail_in)return err(e,mr);if(n.status===vr&&0===n.wrap&&(n.status=Or),n.status===vr){let r=Ar+(n.w_bits-8<<4)<<8,i=-1;if(i=n.strategy>=_r||n.level<2?0:n.level<6?1:6===n.level?2:3,r|=i<<6,0!==n.strstart&&(r|=32),r+=31-r%31,putShortMSB(n,r),0!==n.strstart&&(putShortMSB(n,e.adler>>>16),putShortMSB(n,65535&e.adler)),e.adler=1,n.status=Or,flush_pending(e),0!==n.pending)return n.last_flush=-1,hr}if(57===n.status)if(e.adler=0,put_byte(n,31),put_byte(n,139),put_byte(n,8),n.gzhead)put_byte(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),put_byte(n,255&n.gzhead.time),put_byte(n,n.gzhead.time>>8&255),put_byte(n,n.gzhead.time>>16&255),put_byte(n,n.gzhead.time>>24&255),put_byte(n,9===n.level?2:n.strategy>=_r||n.level<2?4:0),put_byte(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(put_byte(n,255&n.gzhead.extra.length),put_byte(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=crc32_1(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=69;else if(put_byte(n,0),put_byte(n,0),put_byte(n,0),put_byte(n,0),put_byte(n,0),put_byte(n,9===n.level?2:n.strategy>=_r||n.level<2?4:0),put_byte(n,3),n.status=Or,flush_pending(e),0!==n.pending)return n.last_flush=-1,hr;if(69===n.status){if(n.gzhead.extra){let r=n.pending,i=(65535&n.gzhead.extra.length)-n.gzindex;for(;n.pending+i>n.pending_buf_size;){let s=n.pending_buf_size-n.pending;if(n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex,n.gzindex+s),n.pending),n.pending=n.pending_buf_size,n.gzhead.hcrc&&n.pending>r&&(e.adler=crc32_1(e.adler,n.pending_buf,n.pending-r,r)),n.gzindex+=s,flush_pending(e),0!==n.pending)return n.last_flush=-1,hr;r=0,i-=s}let s=new Uint8Array(n.gzhead.extra);n.pending_buf.set(s.subarray(n.gzindex,n.gzindex+i),n.pending),n.pending+=i,n.gzhead.hcrc&&n.pending>r&&(e.adler=crc32_1(e.adler,n.pending_buf,n.pending-r,r)),n.gzindex=0}n.status=73}if(73===n.status){if(n.gzhead.name){let r,i=n.pending;do{if(n.pending===n.pending_buf_size){if(n.gzhead.hcrc&&n.pending>i&&(e.adler=crc32_1(e.adler,n.pending_buf,n.pending-i,i)),flush_pending(e),0!==n.pending)return n.last_flush=-1,hr;i=0}r=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,put_byte(n,r)}while(0!==r);n.gzhead.hcrc&&n.pending>i&&(e.adler=crc32_1(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex=0}n.status=91}if(91===n.status){if(n.gzhead.comment){let r,i=n.pending;do{if(n.pending===n.pending_buf_size){if(n.gzhead.hcrc&&n.pending>i&&(e.adler=crc32_1(e.adler,n.pending_buf,n.pending-i,i)),flush_pending(e),0!==n.pending)return n.last_flush=-1,hr;i=0}r=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,put_byte(n,r)}while(0!==r);n.gzhead.hcrc&&n.pending>i&&(e.adler=crc32_1(e.adler,n.pending_buf,n.pending-i,i))}n.status=103}if(103===n.status){if(n.gzhead.hcrc){if(n.pending+2>n.pending_buf_size&&(flush_pending(e),0!==n.pending))return n.last_flush=-1,hr;put_byte(n,255&e.adler),put_byte(n,e.adler>>8&255),e.adler=0}if(n.status=Or,flush_pending(e),0!==n.pending)return n.last_flush=-1,hr}if(0!==e.avail_in||0!==n.lookahead||r!==ar&&n.status!==xr){let i=0===n.level?deflate_stored(n,r):n.strategy===_r?((e,r)=>{let n;for(;;){if(0===e.lookahead&&(fill_window(e),0===e.lookahead)){if(r===ar)return 1;break}if(e.match_length=0,n=or(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,n&&(flush_block_only(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,r===dr?(flush_block_only(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(flush_block_only(e,!1),0===e.strm.avail_out)?1:2})(n,r):n.strategy===wr?((e,r)=>{let n,i,s,a;const w=e.window;for(;;){if(e.lookahead<=Ir){if(fill_window(e),e.lookahead<=Ir&&r===ar)return 1;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=3&&e.strstart>0&&(s=e.strstart-1,i=w[s],i===w[++s]&&i===w[++s]&&i===w[++s])){a=e.strstart+Ir;do{}while(i===w[++s]&&i===w[++s]&&i===w[++s]&&i===w[++s]&&i===w[++s]&&i===w[++s]&&i===w[++s]&&i===w[++s]&&s<a);e.match_length=Ir-(a-s),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=3?(n=or(e,1,e.match_length-3),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(n=or(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),n&&(flush_block_only(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,r===dr?(flush_block_only(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(flush_block_only(e,!1),0===e.strm.avail_out)?1:2})(n,r):Tr[n.level].func(n,r);if(3!==i&&4!==i||(n.status=xr),1===i||3===i)return 0===e.avail_out&&(n.last_flush=-1),hr;if(2===i&&(r===cr?sr(n):r!==lr&&(nr(n,0,0,!1),r===ur&&(zero(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),flush_pending(e),0===e.avail_out))return n.last_flush=-1,hr}return r!==dr?hr:n.wrap<=0?fr:(2===n.wrap?(put_byte(n,255&e.adler),put_byte(n,e.adler>>8&255),put_byte(n,e.adler>>16&255),put_byte(n,e.adler>>24&255),put_byte(n,255&e.total_in),put_byte(n,e.total_in>>8&255),put_byte(n,e.total_in>>16&255),put_byte(n,e.total_in>>24&255)):(putShortMSB(n,e.adler>>>16),putShortMSB(n,65535&e.adler)),flush_pending(e),n.wrap>0&&(n.wrap=-n.wrap),0!==n.pending?hr:fr)},deflateEnd:e=>{if(deflateStateCheck(e))return gr;const r=e.state.status;return e.state=null,r===Or?err(e,pr):hr},deflateSetDictionary:(e,r)=>{let n=r.length;if(deflateStateCheck(e))return gr;const i=e.state,s=i.wrap;if(2===s||1===s&&i.status!==vr||i.lookahead)return gr;if(1===s&&(e.adler=adler32_1(e.adler,r,n,0)),i.wrap=0,n>=i.w_size){0===s&&(zero(i.head),i.strstart=0,i.block_start=0,i.insert=0);let e=new Uint8Array(i.w_size);e.set(r.subarray(n-i.w_size,n),0),r=e,n=i.w_size}const a=e.avail_in,w=e.next_in,k=e.input;for(e.avail_in=n,e.next_in=0,e.input=r,fill_window(i);i.lookahead>=3;){let e=i.strstart,r=i.lookahead-2;do{i.ins_h=HASH(i,i.ins_h,i.window[e+3-1]),i.prev[e&i.w_mask]=i.head[i.ins_h],i.head[i.ins_h]=e,e++}while(--r);i.strstart=e,i.lookahead=2,fill_window(i)}return i.strstart+=i.lookahead,i.block_start=i.strstart,i.insert=i.lookahead,i.lookahead=0,i.match_length=i.prev_length=2,i.match_available=0,e.next_in=w,e.input=k,e.avail_in=a,i.wrap=s,hr},deflateInfo:"pako deflate (from Nodeca project)"};const _has=(e,r)=>Object.prototype.hasOwnProperty.call(e,r);var Pr={assign:function(e){const r=Array.prototype.slice.call(arguments,1);for(;r.length;){const n=r.shift();if(n){if("object"!=typeof n)throw new TypeError(n+"must be non-object");for(const r in n)_has(n,r)&&(e[r]=n[r])}}return e},flattenChunks:e=>{let r=0;for(let n=0,i=e.length;n<i;n++)r+=e[n].length;const n=new Uint8Array(r);for(let r=0,i=0,s=e.length;r<s;r++){let s=e[r];n.set(s,i),i+=s.length}return n}};let Cr=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){Cr=!1}const Br=new Uint8Array(256);for(let e=0;e<256;e++)Br[e]=e>=252?6:e>=248?5:e>=240?4:e>=224?3:e>=192?2:1;Br[254]=Br[254]=1;var Lr={string2buf:e=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(e);let r,n,i,s,a,w=e.length,k=0;for(s=0;s<w;s++)n=e.charCodeAt(s),55296==(64512&n)&&s+1<w&&(i=e.charCodeAt(s+1),56320==(64512&i)&&(n=65536+(n-55296<<10)+(i-56320),s++)),k+=n<128?1:n<2048?2:n<65536?3:4;for(r=new Uint8Array(k),a=0,s=0;a<k;s++)n=e.charCodeAt(s),55296==(64512&n)&&s+1<w&&(i=e.charCodeAt(s+1),56320==(64512&i)&&(n=65536+(n-55296<<10)+(i-56320),s++)),n<128?r[a++]=n:n<2048?(r[a++]=192|n>>>6,r[a++]=128|63&n):n<65536?(r[a++]=224|n>>>12,r[a++]=128|n>>>6&63,r[a++]=128|63&n):(r[a++]=240|n>>>18,r[a++]=128|n>>>12&63,r[a++]=128|n>>>6&63,r[a++]=128|63&n);return r},buf2string:(e,r)=>{const n=r||e.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(e.subarray(0,r));let i,s;const a=new Array(2*n);for(s=0,i=0;i<n;){let r=e[i++];if(r<128){a[s++]=r;continue}let w=Br[r];if(w>4)a[s++]=65533,i+=w-1;else{for(r&=2===w?31:3===w?15:7;w>1&&i<n;)r=r<<6|63&e[i++],w--;w>1?a[s++]=65533:r<65536?a[s++]=r:(r-=65536,a[s++]=55296|r>>10&1023,a[s++]=56320|1023&r)}}return((e,r)=>{if(r<65534&&e.subarray&&Cr)return String.fromCharCode.apply(null,e.length===r?e:e.subarray(0,r));let n="";for(let i=0;i<r;i++)n+=String.fromCharCode(e[i]);return n})(a,s)},utf8border:(e,r)=>{(r=r||e.length)>e.length&&(r=e.length);let n=r-1;for(;n>=0&&128==(192&e[n]);)n--;return n<0||0===n?r:n+Br[e[n]]>r?n:r}};var zr=function ZStream(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0};const Dr=Object.prototype.toString,{Z_NO_FLUSH:Kr,Z_SYNC_FLUSH:Ur,Z_FULL_FLUSH:Mr,Z_FINISH:Fr,Z_OK:Wr,Z_STREAM_END:qr,Z_DEFAULT_COMPRESSION:Vr,Z_DEFAULT_STRATEGY:jr,Z_DEFLATED:Hr}=tr;function Deflate$1(e){this.options=Pr.assign({level:Vr,method:Hr,chunkSize:16384,windowBits:15,memLevel:8,strategy:jr},e||{});let r=this.options;r.raw&&r.windowBits>0?r.windowBits=-r.windowBits:r.gzip&&r.windowBits>0&&r.windowBits<16&&(r.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zr,this.strm.avail_out=0;let n=Nr.deflateInit2(this.strm,r.level,r.method,r.windowBits,r.memLevel,r.strategy);if(n!==Wr)throw new Error(er[n]);if(r.header&&Nr.deflateSetHeader(this.strm,r.header),r.dictionary){let e;if(e="string"==typeof r.dictionary?Lr.string2buf(r.dictionary):"[object ArrayBuffer]"===Dr.call(r.dictionary)?new Uint8Array(r.dictionary):r.dictionary,n=Nr.deflateSetDictionary(this.strm,e),n!==Wr)throw new Error(er[n]);this._dict_set=!0}}function deflate$1(e,r){const n=new Deflate$1(r);if(n.push(e,!0),n.err)throw n.msg||er[n.err];return n.result}Deflate$1.prototype.push=function(e,r){const n=this.strm,i=this.options.chunkSize;let s,a;if(this.ended)return!1;for(a=r===~~r?r:!0===r?Fr:Kr,"string"==typeof e?n.input=Lr.string2buf(e):"[object ArrayBuffer]"===Dr.call(e)?n.input=new Uint8Array(e):n.input=e,n.next_in=0,n.avail_in=n.input.length;;)if(0===n.avail_out&&(n.output=new Uint8Array(i),n.next_out=0,n.avail_out=i),(a===Ur||a===Mr)&&n.avail_out<=6)this.onData(n.output.subarray(0,n.next_out)),n.avail_out=0;else{if(s=Nr.deflate(n,a),s===qr)return n.next_out>0&&this.onData(n.output.subarray(0,n.next_out)),s=Nr.deflateEnd(this.strm),this.onEnd(s),this.ended=!0,s===Wr;if(0!==n.avail_out){if(a>0&&n.next_out>0)this.onData(n.output.subarray(0,n.next_out)),n.avail_out=0;else if(0===n.avail_in)break}else this.onData(n.output)}return!0},Deflate$1.prototype.onData=function(e){this.chunks.push(e)},Deflate$1.prototype.onEnd=function(e){e===Wr&&(this.result=Pr.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var $r={Deflate:Deflate$1,deflate:deflate$1,deflateRaw:function deflateRaw$1(e,r){return(r=r||{}).raw=!0,deflate$1(e,r)},gzip:function gzip$1(e,r){return(r=r||{}).gzip=!0,deflate$1(e,r)},constants:tr};const Yr=16209;var Gr=function inflate_fast(e,r){let n,i,s,a,w,k,I,we,Ae,Ce,Be,ze,qe,$e,Ye,Je,et,rt,it,ot,ht,ft,pt,yt;const _t=e.state;n=e.next_in,pt=e.input,i=n+(e.avail_in-5),s=e.next_out,yt=e.output,a=s-(r-e.avail_out),w=s+(e.avail_out-257),k=_t.dmax,I=_t.wsize,we=_t.whave,Ae=_t.wnext,Ce=_t.window,Be=_t.hold,ze=_t.bits,qe=_t.lencode,$e=_t.distcode,Ye=(1<<_t.lenbits)-1,Je=(1<<_t.distbits)-1;e:do{ze<15&&(Be+=pt[n++]<<ze,ze+=8,Be+=pt[n++]<<ze,ze+=8),et=qe[Be&Ye];t:for(;;){if(rt=et>>>24,Be>>>=rt,ze-=rt,rt=et>>>16&255,0===rt)yt[s++]=65535&et;else{if(!(16&rt)){if(64&rt){if(32&rt){_t.mode=16191;break e}e.msg="invalid literal/length code",_t.mode=Yr;break e}et=qe[(65535&et)+(Be&(1<<rt)-1)];continue t}for(it=65535&et,rt&=15,rt&&(ze<rt&&(Be+=pt[n++]<<ze,ze+=8),it+=Be&(1<<rt)-1,Be>>>=rt,ze-=rt),ze<15&&(Be+=pt[n++]<<ze,ze+=8,Be+=pt[n++]<<ze,ze+=8),et=$e[Be&Je];;){if(rt=et>>>24,Be>>>=rt,ze-=rt,rt=et>>>16&255,16&rt){if(ot=65535&et,rt&=15,ze<rt&&(Be+=pt[n++]<<ze,ze+=8,ze<rt&&(Be+=pt[n++]<<ze,ze+=8)),ot+=Be&(1<<rt)-1,ot>k){e.msg="invalid distance too far back",_t.mode=Yr;break e}if(Be>>>=rt,ze-=rt,rt=s-a,ot>rt){if(rt=ot-rt,rt>we&&_t.sane){e.msg="invalid distance too far back",_t.mode=Yr;break e}if(ht=0,ft=Ce,0===Ae){if(ht+=I-rt,rt<it){it-=rt;do{yt[s++]=Ce[ht++]}while(--rt);ht=s-ot,ft=yt}}else if(Ae<rt){if(ht+=I+Ae-rt,rt-=Ae,rt<it){it-=rt;do{yt[s++]=Ce[ht++]}while(--rt);if(ht=0,Ae<it){rt=Ae,it-=rt;do{yt[s++]=Ce[ht++]}while(--rt);ht=s-ot,ft=yt}}}else if(ht+=Ae-rt,rt<it){it-=rt;do{yt[s++]=Ce[ht++]}while(--rt);ht=s-ot,ft=yt}for(;it>2;)yt[s++]=ft[ht++],yt[s++]=ft[ht++],yt[s++]=ft[ht++],it-=3;it&&(yt[s++]=ft[ht++],it>1&&(yt[s++]=ft[ht++]))}else{ht=s-ot;do{yt[s++]=yt[ht++],yt[s++]=yt[ht++],yt[s++]=yt[ht++],it-=3}while(it>2);it&&(yt[s++]=yt[ht++],it>1&&(yt[s++]=yt[ht++]))}break}if(64&rt){e.msg="invalid distance code",_t.mode=Yr;break e}et=$e[(65535&et)+(Be&(1<<rt)-1)]}}break}}while(n<i&&s<w);it=ze>>3,n-=it,ze-=it<<3,Be&=(1<<ze)-1,e.next_in=n,e.next_out=s,e.avail_in=n<i?i-n+5:5-(n-i),e.avail_out=s<w?w-s+257:257-(s-w),_t.hold=Be,_t.bits=ze};const Jr=15,Zr=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Xr=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),Qr=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),sn=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var inftrees=(e,r,n,i,s,a,w,k)=>{const I=k.bits;let we,Ae,Ce,Be,ze,qe,$e=0,Ye=0,Je=0,et=0,rt=0,it=0,ot=0,ht=0,ft=0,pt=0,yt=null;const _t=new Uint16Array(16),St=new Uint16Array(16);let kt,Dt,Mt,qt=null;for($e=0;$e<=Jr;$e++)_t[$e]=0;for(Ye=0;Ye<i;Ye++)_t[r[n+Ye]]++;for(rt=I,et=Jr;et>=1&&0===_t[et];et--);if(rt>et&&(rt=et),0===et)return s[a++]=20971520,s[a++]=20971520,k.bits=1,0;for(Je=1;Je<et&&0===_t[Je];Je++);for(rt<Je&&(rt=Je),ht=1,$e=1;$e<=Jr;$e++)if(ht<<=1,ht-=_t[$e],ht<0)return-1;if(ht>0&&(0===e||1!==et))return-1;for(St[1]=0,$e=1;$e<Jr;$e++)St[$e+1]=St[$e]+_t[$e];for(Ye=0;Ye<i;Ye++)0!==r[n+Ye]&&(w[St[r[n+Ye]]++]=Ye);if(0===e?(yt=qt=w,qe=20):1===e?(yt=Zr,qt=Xr,qe=257):(yt=Qr,qt=sn,qe=0),pt=0,Ye=0,$e=Je,ze=a,it=rt,ot=0,Ce=-1,ft=1<<rt,Be=ft-1,1===e&&ft>852||2===e&&ft>592)return 1;for(;;){kt=$e-ot,w[Ye]+1<qe?(Dt=0,Mt=w[Ye]):w[Ye]>=qe?(Dt=qt[w[Ye]-qe],Mt=yt[w[Ye]-qe]):(Dt=96,Mt=0),we=1<<$e-ot,Ae=1<<it,Je=Ae;do{Ae-=we,s[ze+(pt>>ot)+Ae]=kt<<24|Dt<<16|Mt}while(0!==Ae);for(we=1<<$e-1;pt&we;)we>>=1;if(0!==we?(pt&=we-1,pt+=we):pt=0,Ye++,0==--_t[$e]){if($e===et)break;$e=r[n+w[Ye]]}if($e>rt&&(pt&Be)!==Ce){for(0===ot&&(ot=rt),ze+=Je,it=$e-ot,ht=1<<it;it+ot<et&&(ht-=_t[it+ot],!(ht<=0));)it++,ht<<=1;if(ft+=1<<it,1===e&&ft>852||2===e&&ft>592)return 1;Ce=pt&Be,s[Ce]=rt<<24|it<<16|ze-a}}return 0!==pt&&(s[ze+pt]=$e-ot<<24|64<<16),k.bits=rt,0};const{Z_FINISH:an,Z_BLOCK:cn,Z_TREES:un,Z_OK:dn,Z_STREAM_END:ln,Z_NEED_DICT:gn,Z_STREAM_ERROR:pn,Z_DATA_ERROR:mn,Z_MEM_ERROR:yn,Z_BUF_ERROR:bn,Z_DEFLATED:kn}=tr,In=16180,Cn=16190,Bn=16191,Mn=16192,Wn=16194,Hn=16199,Zn=16200,Qn=16206,ei=16209,zswap32=e=>(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24);function InflateState(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const inflateStateCheck=e=>{if(!e)return 1;const r=e.state;return!r||r.strm!==e||r.mode<In||r.mode>16211?1:0},inflateResetKeep=e=>{if(inflateStateCheck(e))return pn;const r=e.state;return e.total_in=e.total_out=r.total=0,e.msg="",r.wrap&&(e.adler=1&r.wrap),r.mode=In,r.last=0,r.havedict=0,r.flags=-1,r.dmax=32768,r.head=null,r.hold=0,r.bits=0,r.lencode=r.lendyn=new Int32Array(852),r.distcode=r.distdyn=new Int32Array(592),r.sane=1,r.back=-1,dn},inflateReset=e=>{if(inflateStateCheck(e))return pn;const r=e.state;return r.wsize=0,r.whave=0,r.wnext=0,inflateResetKeep(e)},inflateReset2=(e,r)=>{let n;if(inflateStateCheck(e))return pn;const i=e.state;return r<0?(n=0,r=-r):(n=5+(r>>4),r<48&&(r&=15)),r&&(r<8||r>15)?pn:(null!==i.window&&i.wbits!==r&&(i.window=null),i.wrap=n,i.wbits=r,inflateReset(e))},inflateInit2=(e,r)=>{if(!e)return pn;const n=new InflateState;e.state=n,n.strm=e,n.window=null,n.mode=In;const i=inflateReset2(e,r);return i!==dn&&(e.state=null),i};let ti,ri,ni=!0;const fixedtables=e=>{if(ni){ti=new Int32Array(512),ri=new Int32Array(32);let r=0;for(;r<144;)e.lens[r++]=8;for(;r<256;)e.lens[r++]=9;for(;r<280;)e.lens[r++]=7;for(;r<288;)e.lens[r++]=8;for(inftrees(1,e.lens,0,288,ti,0,e.work,{bits:9}),r=0;r<32;)e.lens[r++]=5;inftrees(2,e.lens,0,32,ri,0,e.work,{bits:5}),ni=!1}e.lencode=ti,e.lenbits=9,e.distcode=ri,e.distbits=5},updatewindow=(e,r,n,i)=>{let s;const a=e.state;return null===a.window&&(a.wsize=1<<a.wbits,a.wnext=0,a.whave=0,a.window=new Uint8Array(a.wsize)),i>=a.wsize?(a.window.set(r.subarray(n-a.wsize,n),0),a.wnext=0,a.whave=a.wsize):(s=a.wsize-a.wnext,s>i&&(s=i),a.window.set(r.subarray(n-i,n-i+s),a.wnext),(i-=s)?(a.window.set(r.subarray(n-i,n),0),a.wnext=i,a.whave=a.wsize):(a.wnext+=s,a.wnext===a.wsize&&(a.wnext=0),a.whave<a.wsize&&(a.whave+=s))),0};var ii={inflateReset,inflateReset2,inflateResetKeep,inflateInit:e=>inflateInit2(e,15),inflateInit2,inflate:(e,r)=>{let n,i,s,a,w,k,I,we,Ae,Ce,Be,ze,qe,$e,Ye,Je,et,rt,it,ot,ht,ft,pt=0;const yt=new Uint8Array(4);let _t,St;const kt=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(inflateStateCheck(e)||!e.output||!e.input&&0!==e.avail_in)return pn;n=e.state,n.mode===Bn&&(n.mode=Mn),w=e.next_out,s=e.output,I=e.avail_out,a=e.next_in,i=e.input,k=e.avail_in,we=n.hold,Ae=n.bits,Ce=k,Be=I,ft=dn;e:for(;;)switch(n.mode){case In:if(0===n.wrap){n.mode=Mn;break}for(;Ae<16;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}if(2&n.wrap&&35615===we){0===n.wbits&&(n.wbits=15),n.check=0,yt[0]=255&we,yt[1]=we>>>8&255,n.check=crc32_1(n.check,yt,2,0),we=0,Ae=0,n.mode=16181;break}if(n.head&&(n.head.done=!1),!(1&n.wrap)||(((255&we)<<8)+(we>>8))%31){e.msg="incorrect header check",n.mode=ei;break}if((15&we)!==kn){e.msg="unknown compression method",n.mode=ei;break}if(we>>>=4,Ae-=4,ht=8+(15&we),0===n.wbits&&(n.wbits=ht),ht>15||ht>n.wbits){e.msg="invalid window size",n.mode=ei;break}n.dmax=1<<n.wbits,n.flags=0,e.adler=n.check=1,n.mode=512&we?16189:Bn,we=0,Ae=0;break;case 16181:for(;Ae<16;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}if(n.flags=we,(255&n.flags)!==kn){e.msg="unknown compression method",n.mode=ei;break}if(57344&n.flags){e.msg="unknown header flags set",n.mode=ei;break}n.head&&(n.head.text=we>>8&1),512&n.flags&&4&n.wrap&&(yt[0]=255&we,yt[1]=we>>>8&255,n.check=crc32_1(n.check,yt,2,0)),we=0,Ae=0,n.mode=16182;case 16182:for(;Ae<32;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}n.head&&(n.head.time=we),512&n.flags&&4&n.wrap&&(yt[0]=255&we,yt[1]=we>>>8&255,yt[2]=we>>>16&255,yt[3]=we>>>24&255,n.check=crc32_1(n.check,yt,4,0)),we=0,Ae=0,n.mode=16183;case 16183:for(;Ae<16;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}n.head&&(n.head.xflags=255&we,n.head.os=we>>8),512&n.flags&&4&n.wrap&&(yt[0]=255&we,yt[1]=we>>>8&255,n.check=crc32_1(n.check,yt,2,0)),we=0,Ae=0,n.mode=16184;case 16184:if(1024&n.flags){for(;Ae<16;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}n.length=we,n.head&&(n.head.extra_len=we),512&n.flags&&4&n.wrap&&(yt[0]=255&we,yt[1]=we>>>8&255,n.check=crc32_1(n.check,yt,2,0)),we=0,Ae=0}else n.head&&(n.head.extra=null);n.mode=16185;case 16185:if(1024&n.flags&&(ze=n.length,ze>k&&(ze=k),ze&&(n.head&&(ht=n.head.extra_len-n.length,n.head.extra||(n.head.extra=new Uint8Array(n.head.extra_len)),n.head.extra.set(i.subarray(a,a+ze),ht)),512&n.flags&&4&n.wrap&&(n.check=crc32_1(n.check,i,ze,a)),k-=ze,a+=ze,n.length-=ze),n.length))break e;n.length=0,n.mode=16186;case 16186:if(2048&n.flags){if(0===k)break e;ze=0;do{ht=i[a+ze++],n.head&&ht&&n.length<65536&&(n.head.name+=String.fromCharCode(ht))}while(ht&&ze<k);if(512&n.flags&&4&n.wrap&&(n.check=crc32_1(n.check,i,ze,a)),k-=ze,a+=ze,ht)break e}else n.head&&(n.head.name=null);n.length=0,n.mode=16187;case 16187:if(4096&n.flags){if(0===k)break e;ze=0;do{ht=i[a+ze++],n.head&&ht&&n.length<65536&&(n.head.comment+=String.fromCharCode(ht))}while(ht&&ze<k);if(512&n.flags&&4&n.wrap&&(n.check=crc32_1(n.check,i,ze,a)),k-=ze,a+=ze,ht)break e}else n.head&&(n.head.comment=null);n.mode=16188;case 16188:if(512&n.flags){for(;Ae<16;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}if(4&n.wrap&&we!==(65535&n.check)){e.msg="header crc mismatch",n.mode=ei;break}we=0,Ae=0}n.head&&(n.head.hcrc=n.flags>>9&1,n.head.done=!0),e.adler=n.check=0,n.mode=Bn;break;case 16189:for(;Ae<32;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}e.adler=n.check=zswap32(we),we=0,Ae=0,n.mode=Cn;case Cn:if(0===n.havedict)return e.next_out=w,e.avail_out=I,e.next_in=a,e.avail_in=k,n.hold=we,n.bits=Ae,gn;e.adler=n.check=1,n.mode=Bn;case Bn:if(r===cn||r===un)break e;case Mn:if(n.last){we>>>=7&Ae,Ae-=7&Ae,n.mode=Qn;break}for(;Ae<3;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}switch(n.last=1&we,we>>>=1,Ae-=1,3&we){case 0:n.mode=16193;break;case 1:if(fixedtables(n),n.mode=Hn,r===un){we>>>=2,Ae-=2;break e}break;case 2:n.mode=16196;break;case 3:e.msg="invalid block type",n.mode=ei}we>>>=2,Ae-=2;break;case 16193:for(we>>>=7&Ae,Ae-=7&Ae;Ae<32;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}if((65535&we)!=(we>>>16^65535)){e.msg="invalid stored block lengths",n.mode=ei;break}if(n.length=65535&we,we=0,Ae=0,n.mode=Wn,r===un)break e;case Wn:n.mode=16195;case 16195:if(ze=n.length,ze){if(ze>k&&(ze=k),ze>I&&(ze=I),0===ze)break e;s.set(i.subarray(a,a+ze),w),k-=ze,a+=ze,I-=ze,w+=ze,n.length-=ze;break}n.mode=Bn;break;case 16196:for(;Ae<14;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}if(n.nlen=257+(31&we),we>>>=5,Ae-=5,n.ndist=1+(31&we),we>>>=5,Ae-=5,n.ncode=4+(15&we),we>>>=4,Ae-=4,n.nlen>286||n.ndist>30){e.msg="too many length or distance symbols",n.mode=ei;break}n.have=0,n.mode=16197;case 16197:for(;n.have<n.ncode;){for(;Ae<3;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}n.lens[kt[n.have++]]=7&we,we>>>=3,Ae-=3}for(;n.have<19;)n.lens[kt[n.have++]]=0;if(n.lencode=n.lendyn,n.lenbits=7,_t={bits:n.lenbits},ft=inftrees(0,n.lens,0,19,n.lencode,0,n.work,_t),n.lenbits=_t.bits,ft){e.msg="invalid code lengths set",n.mode=ei;break}n.have=0,n.mode=16198;case 16198:for(;n.have<n.nlen+n.ndist;){for(;pt=n.lencode[we&(1<<n.lenbits)-1],Ye=pt>>>24,Je=pt>>>16&255,et=65535&pt,!(Ye<=Ae);){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}if(et<16)we>>>=Ye,Ae-=Ye,n.lens[n.have++]=et;else{if(16===et){for(St=Ye+2;Ae<St;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}if(we>>>=Ye,Ae-=Ye,0===n.have){e.msg="invalid bit length repeat",n.mode=ei;break}ht=n.lens[n.have-1],ze=3+(3&we),we>>>=2,Ae-=2}else if(17===et){for(St=Ye+3;Ae<St;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}we>>>=Ye,Ae-=Ye,ht=0,ze=3+(7&we),we>>>=3,Ae-=3}else{for(St=Ye+7;Ae<St;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}we>>>=Ye,Ae-=Ye,ht=0,ze=11+(127&we),we>>>=7,Ae-=7}if(n.have+ze>n.nlen+n.ndist){e.msg="invalid bit length repeat",n.mode=ei;break}for(;ze--;)n.lens[n.have++]=ht}}if(n.mode===ei)break;if(0===n.lens[256]){e.msg="invalid code -- missing end-of-block",n.mode=ei;break}if(n.lenbits=9,_t={bits:n.lenbits},ft=inftrees(1,n.lens,0,n.nlen,n.lencode,0,n.work,_t),n.lenbits=_t.bits,ft){e.msg="invalid literal/lengths set",n.mode=ei;break}if(n.distbits=6,n.distcode=n.distdyn,_t={bits:n.distbits},ft=inftrees(2,n.lens,n.nlen,n.ndist,n.distcode,0,n.work,_t),n.distbits=_t.bits,ft){e.msg="invalid distances set",n.mode=ei;break}if(n.mode=Hn,r===un)break e;case Hn:n.mode=Zn;case Zn:if(k>=6&&I>=258){e.next_out=w,e.avail_out=I,e.next_in=a,e.avail_in=k,n.hold=we,n.bits=Ae,Gr(e,Be),w=e.next_out,s=e.output,I=e.avail_out,a=e.next_in,i=e.input,k=e.avail_in,we=n.hold,Ae=n.bits,n.mode===Bn&&(n.back=-1);break}for(n.back=0;pt=n.lencode[we&(1<<n.lenbits)-1],Ye=pt>>>24,Je=pt>>>16&255,et=65535&pt,!(Ye<=Ae);){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}if(Je&&!(240&Je)){for(rt=Ye,it=Je,ot=et;pt=n.lencode[ot+((we&(1<<rt+it)-1)>>rt)],Ye=pt>>>24,Je=pt>>>16&255,et=65535&pt,!(rt+Ye<=Ae);){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}we>>>=rt,Ae-=rt,n.back+=rt}if(we>>>=Ye,Ae-=Ye,n.back+=Ye,n.length=et,0===Je){n.mode=16205;break}if(32&Je){n.back=-1,n.mode=Bn;break}if(64&Je){e.msg="invalid literal/length code",n.mode=ei;break}n.extra=15&Je,n.mode=16201;case 16201:if(n.extra){for(St=n.extra;Ae<St;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}n.length+=we&(1<<n.extra)-1,we>>>=n.extra,Ae-=n.extra,n.back+=n.extra}n.was=n.length,n.mode=16202;case 16202:for(;pt=n.distcode[we&(1<<n.distbits)-1],Ye=pt>>>24,Je=pt>>>16&255,et=65535&pt,!(Ye<=Ae);){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}if(!(240&Je)){for(rt=Ye,it=Je,ot=et;pt=n.distcode[ot+((we&(1<<rt+it)-1)>>rt)],Ye=pt>>>24,Je=pt>>>16&255,et=65535&pt,!(rt+Ye<=Ae);){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}we>>>=rt,Ae-=rt,n.back+=rt}if(we>>>=Ye,Ae-=Ye,n.back+=Ye,64&Je){e.msg="invalid distance code",n.mode=ei;break}n.offset=et,n.extra=15&Je,n.mode=16203;case 16203:if(n.extra){for(St=n.extra;Ae<St;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}n.offset+=we&(1<<n.extra)-1,we>>>=n.extra,Ae-=n.extra,n.back+=n.extra}if(n.offset>n.dmax){e.msg="invalid distance too far back",n.mode=ei;break}n.mode=16204;case 16204:if(0===I)break e;if(ze=Be-I,n.offset>ze){if(ze=n.offset-ze,ze>n.whave&&n.sane){e.msg="invalid distance too far back",n.mode=ei;break}ze>n.wnext?(ze-=n.wnext,qe=n.wsize-ze):qe=n.wnext-ze,ze>n.length&&(ze=n.length),$e=n.window}else $e=s,qe=w-n.offset,ze=n.length;ze>I&&(ze=I),I-=ze,n.length-=ze;do{s[w++]=$e[qe++]}while(--ze);0===n.length&&(n.mode=Zn);break;case 16205:if(0===I)break e;s[w++]=n.length,I--,n.mode=Zn;break;case Qn:if(n.wrap){for(;Ae<32;){if(0===k)break e;k--,we|=i[a++]<<Ae,Ae+=8}if(Be-=I,e.total_out+=Be,n.total+=Be,4&n.wrap&&Be&&(e.adler=n.check=n.flags?crc32_1(n.check,s,Be,w-Be):adler32_1(n.check,s,Be,w-Be)),Be=I,4&n.wrap&&(n.flags?we:zswap32(we))!==n.check){e.msg="incorrect data check",n.mode=ei;break}we=0,Ae=0}n.mode=16207;case 16207:if(n.wrap&&n.flags){for(;Ae<32;){if(0===k)break e;k--,we+=i[a++]<<Ae,Ae+=8}if(4&n.wrap&&we!==(4294967295&n.total)){e.msg="incorrect length check",n.mode=ei;break}we=0,Ae=0}n.mode=16208;case 16208:ft=ln;break e;case ei:ft=mn;break e;case 16210:return yn;default:return pn}return e.next_out=w,e.avail_out=I,e.next_in=a,e.avail_in=k,n.hold=we,n.bits=Ae,(n.wsize||Be!==e.avail_out&&n.mode<ei&&(n.mode<Qn||r!==an))&&updatewindow(e,e.output,e.next_out,Be-e.avail_out),Ce-=e.avail_in,Be-=e.avail_out,e.total_in+=Ce,e.total_out+=Be,n.total+=Be,4&n.wrap&&Be&&(e.adler=n.check=n.flags?crc32_1(n.check,s,Be,e.next_out-Be):adler32_1(n.check,s,Be,e.next_out-Be)),e.data_type=n.bits+(n.last?64:0)+(n.mode===Bn?128:0)+(n.mode===Hn||n.mode===Wn?256:0),(0===Ce&&0===Be||r===an)&&ft===dn&&(ft=bn),ft},inflateEnd:e=>{if(inflateStateCheck(e))return pn;let r=e.state;return r.window&&(r.window=null),e.state=null,dn},inflateGetHeader:(e,r)=>{if(inflateStateCheck(e))return pn;const n=e.state;return 2&n.wrap?(n.head=r,r.done=!1,dn):pn},inflateSetDictionary:(e,r)=>{const n=r.length;let i,s,a;return inflateStateCheck(e)?pn:(i=e.state,0!==i.wrap&&i.mode!==Cn?pn:i.mode===Cn&&(s=1,s=adler32_1(s,r,n,0),s!==i.check)?mn:(a=updatewindow(e,r,n,n),a?(i.mode=16210,yn):(i.havedict=1,dn)))},inflateInfo:"pako inflate (from Nodeca project)"};var oi=function GZheader(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1};const si=Object.prototype.toString,{Z_NO_FLUSH:ai,Z_FINISH:ci,Z_OK:ui,Z_STREAM_END:di,Z_NEED_DICT:li,Z_STREAM_ERROR:hi,Z_DATA_ERROR:fi,Z_MEM_ERROR:gi}=tr;function Inflate$1(e){this.options=Pr.assign({chunkSize:65536,windowBits:15,to:""},e||{});const r=this.options;r.raw&&r.windowBits>=0&&r.windowBits<16&&(r.windowBits=-r.windowBits,0===r.windowBits&&(r.windowBits=-15)),!(r.windowBits>=0&&r.windowBits<16)||e&&e.windowBits||(r.windowBits+=32),r.windowBits>15&&r.windowBits<48&&(15&r.windowBits||(r.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zr,this.strm.avail_out=0;let n=ii.inflateInit2(this.strm,r.windowBits);if(n!==ui)throw new Error(er[n]);if(this.header=new oi,ii.inflateGetHeader(this.strm,this.header),r.dictionary&&("string"==typeof r.dictionary?r.dictionary=Lr.string2buf(r.dictionary):"[object ArrayBuffer]"===si.call(r.dictionary)&&(r.dictionary=new Uint8Array(r.dictionary)),r.raw&&(n=ii.inflateSetDictionary(this.strm,r.dictionary),n!==ui)))throw new Error(er[n])}function inflate$1(e,r){const n=new Inflate$1(r);if(n.push(e),n.err)throw n.msg||er[n.err];return n.result}Inflate$1.prototype.push=function(e,r){const n=this.strm,i=this.options.chunkSize,s=this.options.dictionary;let a,w,k;if(this.ended)return!1;for(w=r===~~r?r:!0===r?ci:ai,"[object ArrayBuffer]"===si.call(e)?n.input=new Uint8Array(e):n.input=e,n.next_in=0,n.avail_in=n.input.length;;){for(0===n.avail_out&&(n.output=new Uint8Array(i),n.next_out=0,n.avail_out=i),a=ii.inflate(n,w),a===li&&s&&(a=ii.inflateSetDictionary(n,s),a===ui?a=ii.inflate(n,w):a===fi&&(a=li));n.avail_in>0&&a===di&&n.state.wrap>0&&0!==e[n.next_in];)ii.inflateReset(n),a=ii.inflate(n,w);switch(a){case hi:case fi:case li:case gi:return this.onEnd(a),this.ended=!0,!1}if(k=n.avail_out,n.next_out&&(0===n.avail_out||a===di))if("string"===this.options.to){let e=Lr.utf8border(n.output,n.next_out),r=n.next_out-e,s=Lr.buf2string(n.output,e);n.next_out=r,n.avail_out=i-r,r&&n.output.set(n.output.subarray(e,e+r),0),this.onData(s)}else this.onData(n.output.length===n.next_out?n.output:n.output.subarray(0,n.next_out));if(a!==ui||0!==k){if(a===di)return a=ii.inflateEnd(this.strm),this.onEnd(a),this.ended=!0,!0;if(0===n.avail_in)break}}return!0},Inflate$1.prototype.onData=function(e){this.chunks.push(e)},Inflate$1.prototype.onEnd=function(e){e===ui&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=Pr.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var pi={Inflate:Inflate$1,inflate:inflate$1,inflateRaw:function inflateRaw$1(e,r){return(r=r||{}).raw=!0,inflate$1(e,r)},ungzip:inflate$1,constants:tr};const{Deflate:mi,deflate:yi,deflateRaw:bi,gzip:_i}=$r,{Inflate:wi,inflate:Si,inflateRaw:Ei,ungzip:ki}=pi;var Ai=Si,Ii=n(828985),Ri=n.n(Ii),vi=n(626093),Oi=n(901048).Buffer,xi=Object.freeze({__proto__:null,encode:function(e){return e.reduce(((e,r)=>e+r.toString(16).padStart(2,"0")),"0x")},decode:function(e){0===e.indexOf("0x")&&(e=e.substr(2)),e.length%2==1&&(e="0"+e);let r=e.match(/.{2}/g);return null===r?i.Buffer.from([]):i.Buffer.from(r.map((e=>parseInt(e,16))))}});function v(e){return new TextDecoder("utf-8").decode(e)}function b(e){return(new TextEncoder).encode(e)}var Ti=Object.freeze({__proto__:null,decode:v,encode:b});function _(e){return I().encode(e)}var Ni=Object.freeze({__proto__:null,encode:_,decode:function(e){return I().decode(e)}});function E(e){return i.Buffer.from(we.toByteArray(e))}var Pi=Object.freeze({__proto__:null,encode:function(e){return we.fromByteArray(e)},decode:E}),Ci=Object.freeze({__proto__:null,hex:xi,utf8:Ti,bs58:Ni,base64:Pi});function M(e){const r=new Map;return e.errors&&e.errors.forEach((e=>{var n;let i=null!==(n=e.msg)&&void 0!==n?n:e.name;r.set(e.code,i)})),r}function x(e,...r){if(e.args.length!=r.length)throw new Error("Invalid argument length");const n={};let i=0;return e.args.forEach((e=>{n[e.name]=r[i],i+=1})),n}function P(e,r={}){e.forEach((e=>{if("accounts"in e)P(e.accounts,r[e.name]);else if(void 0===r[e.name])throw new Error(`Invalid arguments: ${e.name} not provided.`)}))}function L(e){return e instanceof s.PublicKey?e:new s.PublicKey(e)}class T extends TypeError{constructor(e,r){let n;const{message:i,...s}=e,{path:a}=e;super(0===a.length?i:"At path: "+a.join(".")+" -- "+i),this.value=void 0,this.key=void 0,this.type=void 0,this.refinement=void 0,this.path=void 0,this.branch=void 0,this.failures=void 0,Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>{var i;return null!=(i=n)?i:n=[e,...r()]}}}function C(e){return"object"==typeof e&&null!=e}function z(e){return"string"==typeof e?JSON.stringify(e):""+e}function B(e,r,n,i){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:s,branch:a}=r,{type:w}=n,{refinement:k,message:I="Expected a value of type `"+w+"`"+(k?" with refinement `"+k+"`":"")+", but received: `"+z(i)+"`"}=e;return{value:i,type:w,refinement:k,key:s[s.length-1],path:s,branch:a,...e,message:I}}function*O(e,r,n,i){var s;C(s=e)&&"function"==typeof s[Symbol.iterator]||(e=[e]);for(const s of e){const e=B(s,r,n,i);e&&(yield e)}}function*D(e,r,n){void 0===n&&(n={});const{path:i=[],branch:s=[e],coerce:a=!1,mask:w=!1}=n,k={path:i,branch:s};if(a&&(e=r.coercer(e,k),w&&"type"!==r.type&&C(r.schema)&&C(e)&&!Array.isArray(e)))for(const n in e)void 0===r.schema[n]&&delete e[n];let I=!0;for(const n of r.validator(e,k))I=!1,yield[n,void 0];for(let[n,we,Ae]of r.entries(e,k)){const r=D(we,Ae,{path:void 0===n?i:[...i,n],branch:void 0===n?s:[...s,we],coerce:a,mask:w});for(const i of r)i[0]?(I=!1,yield[i[0],void 0]):a&&(we=i[1],void 0===n?e=we:e instanceof Map?e.set(n,we):e instanceof Set?e.add(we):C(e)&&(e[n]=we))}if(I)for(const n of r.refiner(e,k))I=!1,yield[n,void 0];I&&(yield[void 0,e])}class N{constructor(e){this.TYPE=void 0,this.type=void 0,this.schema=void 0,this.coercer=void 0,this.validator=void 0,this.refiner=void 0,this.entries=void 0;const{type:r,schema:n,validator:i,refiner:s,coercer:a=(e=>e),entries:w=function*(){}}=e;this.type=r,this.schema=n,this.entries=w,this.coercer=a,this.validator=i?(e,r)=>O(i(e,r),r,this,e):()=>[],this.refiner=s?(e,r)=>O(s(e,r),r,this,e):()=>[]}assert(e){return function(e,r){const n=U(e,r);if(n[0])throw n[0]}(e,this)}create(e){return R(e,this)}is(e){return V(e,this)}mask(e){return function(e,r){const n=U(e,r,{coerce:!0,mask:!0});if(n[0])throw n[0];return n[1]}(e,this)}validate(e,r){return void 0===r&&(r={}),U(e,this,r)}}function R(e,r){const n=U(e,r,{coerce:!0});if(n[0])throw n[0];return n[1]}function V(e,r){return!U(e,r)[0]}function U(e,r,n){void 0===n&&(n={});const i=D(e,r,n),s=function(e){const{done:r,value:n}=e.next();return r?void 0:n}(i);return s[0]?[new T(s[0],(function*(){for(const e of i)e[0]&&(yield e[0])})),void 0]:[void 0,s[1]]}function j(e,r){return new N({type:e,schema:null,validator:r})}function $(e){return new N({type:"array",schema:e,*entries(r){if(e&&Array.isArray(r))for(const[n,i]of r.entries())yield[n,i,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||"Expected an array value, but received: "+z(e)})}function K(e){const r=z(e),n=typeof e;return new N({type:"literal",schema:"string"===n||"number"===n||"boolean"===n?e:null,validator:n=>n===e||"Expected the literal `"+r+"`, but received: "+z(n)})}function q(e){return new N({...e,validator:(r,n)=>null===r||e.validator(r,n),refiner:(r,n)=>null===r||e.refiner(r,n)})}function F(){return j("number",(e=>"number"==typeof e&&!isNaN(e)||"Expected a number, but received: "+z(e)))}function W(e){return new N({...e,validator:(r,n)=>void 0===r||e.validator(r,n),refiner:(r,n)=>void 0===r||e.refiner(r,n)})}function G(){return j("string",(e=>"string"==typeof e||"Expected a string, but received: "+z(e)))}function H(e){const r=Object.keys(e);return new N({type:"type",schema:e,*entries(n){if(C(n))for(const i of r)yield[i,n[i],e[i]]},validator:e=>C(e)||"Expected an object, but received: "+z(e)})}function J(e){const r=e.map((e=>e.type)).join(" | ");return new N({type:"union",schema:null,coercer:(r,n)=>(e.find((e=>{const[n]=e.validate(r,{coerce:!0});return!n}))||Z()).coercer(r,n),validator(n,i){const s=[];for(const r of e){const[...e]=D(n,r,i),[a]=e;if(!a[0])return[];for(const[r]of e)r&&s.push(r)}return["Expected the value to satisfy a union of `"+r+"`, but received: "+z(n),...s]}})}function Z(){return j("unknown",(()=>!0))}async function X(e,r,n){if(r.length<=99)return await Q(e,r,n);{const i=function(e,r){return Array.apply(0,new Array(Math.ceil(e.length/99))).map(((r,n)=>e.slice(99*n,99*(n+1))))}(r);return(await Promise.all(i.map((r=>Q(e,r,n))))).flat()}}async function Q(e,r,n){const i=null!=n?n:e.commitment;return(await e.getMultipleAccountsInfo(r,i)).map(((e,n)=>null===e?null:{publicKey:r[n],account:e}))}async function Y(e,r,n,i,a){n&&n.length>0&&r.sign(...n);const w=r._compile(),k=w.serialize(),I=r._serialize(k).toString("base64"),we={encoding:"base64",commitment:null!=i?i:e.commitment};if(a){const e=(Array.isArray(a)?a:w.nonProgramIds()).map((e=>e.toBase58()));we.accounts={encoding:"base64",addresses:e}}n&&(we.sigVerify=!0);const Ae=[I,we],Ce=R(await e._rpcRequest("simulateTransaction",Ae),Li);if("error"in Ce){let e;if("data"in Ce.error&&(e=Ce.error.data.logs,e&&Array.isArray(e))){const r="\n    ",n=r+e.join(r);console.error(Ce.error.message,n)}throw new s.SendTransactionError("failed to simulate transaction: "+Ce.error.message,e)}return Ce.result}const Bi=nt(Z());function nt(e){return J([H({jsonrpc:K("2.0"),id:G(),result:e}),H({jsonrpc:K("2.0"),id:G(),error:H({code:Z(),message:G(),data:W(j("any",(()=>!0)))})})])}const Li=(zi=H({err:q(J([H({}),G()])),logs:q($(G())),accounts:W(q($(q(H({executable:j("boolean",(e=>"boolean"==typeof e)),owner:G(),lamports:F(),data:$(G()),rentEpoch:W(F())}))))),unitsConsumed:W(F())}),function tt(e){return function(e,r,n){return new N({...e,coercer:(i,s)=>V(i,r)?e.coercer(n(i),s):e.coercer(i,s)})}(nt(e),Bi,(r=>"error"in r?r:{...r,result:R(r.result,e)}))}(H({context:H({slot:F()}),value:zi})));var zi,Di=Object.freeze({__proto__:null,invoke:async function(e,r,n,i){e=L(e),i||(i=lt());const a=new s.Transaction;if(a.add(new s.TransactionInstruction({programId:e,keys:null!=r?r:[],data:n})),void 0===i.sendAndConfirm)throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");return await i.sendAndConfirm(a,[])},getMultipleAccounts:X,simulateTransaction:Y});class st{constructor(e,r,n){this.connection=e,this.wallet=r,this.opts=n,this.publicKey=r.publicKey}static defaultOptions(){return{preflightCommitment:"processed",commitment:"processed"}}static local(e,r){throw new Error("Provider local is not available on browser.")}static env(){throw new Error("Provider env is not available on browser.")}async sendAndConfirm(e,r,n){var i;void 0===n&&(n=this.opts),e.feePayer=this.wallet.publicKey,e.recentBlockhash=(await this.connection.getRecentBlockhash(n.preflightCommitment)).blockhash,e=await this.wallet.signTransaction(e),(null!=r?r:[]).forEach((r=>{e.partialSign(r)}));const a=e.serialize();try{return await ct(this.connection,a,n)}catch(r){if(r instanceof ut){const n=await this.connection.getTransaction(_(e.signature),{commitment:"confirmed"});if(n){const e=null===(i=n.meta)||void 0===i?void 0:i.logMessages;throw e?new s.SendTransactionError(r.message,e):r}throw r}throw r}}async sendAll(e,r){void 0===r&&(r=this.opts);const n=await this.connection.getRecentBlockhash(r.preflightCommitment);let i=e.map((e=>{var r;let i=e.tx,s=null!==(r=e.signers)&&void 0!==r?r:[];return i.feePayer=this.wallet.publicKey,i.recentBlockhash=n.blockhash,s.forEach((e=>{i.partialSign(e)})),i}));const s=await this.wallet.signAllTransactions(i),a=[];for(let e=0;e<i.length;e+=1){const n=s[e].serialize();a.push(await ct(this.connection,n,r))}return a}async simulate(e,r,n,i){e.feePayer=this.wallet.publicKey,e.recentBlockhash=(await this.connection.getLatestBlockhash(null!=n?n:this.connection.commitment)).blockhash,e=await this.wallet.signTransaction(e);const s=await Y(this.connection,e,r,n,i);if(s.value.err)throw new at(s.value);return s.value}}class at extends Error{constructor(e,r){super(r),this.simulationResponse=e}}async function ct(e,r,n){const i=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment},s=await e.sendRawTransaction(r,i),a=(await e.confirmTransaction(s,n&&n.commitment)).value;if(a.err)throw new ut(`Raw transaction ${s} failed (${JSON.stringify(a)})`);return s}class ut extends Error{constructor(e){super(e)}}function dt(e){Ki=e}function lt(){return null===Ki?st.local():Ki}let Ki=null;const Ui=new Set(["anchor-deprecated-state","debug-logs"]),Mi=new Map;function mt(e){return void 0!==Mi.get(e)}var Fi=Object.freeze({__proto__:null,set:function(e){if(!Ui.has(e))throw new Error("Invalid feature");Mi.set(e,!0)},isSet:mt});class gt extends Error{constructor(e){super(e),this.name="IdlError"}}class wt{constructor(e){this.stack=e}static parse(e){var r;const n=/^Program (\w*) invoke/,i=/^Program \w* success/,a=[];for(let w=0;w<e.length;w++){if(i.exec(e[w])){a.pop();continue}const k=null===(r=n.exec(e[w]))||void 0===r?void 0:r[1];k&&a.push(new s.PublicKey(k))}return new wt(a)}}class vt extends Error{constructor(e,r,n,i,s,a){super(n.join("\n").replace("Program log: ","")),this.errorLogs=n,this.logs=i,this.error={errorCode:e,errorMessage:r,comparedValues:a,origin:s},this._programErrorStack=wt.parse(i)}static parse(e){if(!e)return null;const r=e.findIndex((e=>e.startsWith("Program log: AnchorError")));if(-1===r)return null;const n=e[r],i=[n];let a;if(r+1<e.length)if("Program log: Left:"===e[r+1]){const n=/^Program log: (.*)$/,w=n.exec(e[r+2])[1],k=n.exec(e[r+4])[1];a=[new s.PublicKey(w),new s.PublicKey(k)],i.push(...e.slice(r+1,r+5))}else if(e[r+1].startsWith("Program log: Left:")){const n=/^Program log: (Left|Right): (.*)$/,s=n.exec(e[r+1])[2],w=n.exec(e[r+2])[2];i.push(...e.slice(r+1,r+3)),a=[s,w]}const w=/^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(n),k=/^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(n),I=/^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(n);if(w){const[r,n,s]=w.slice(1,4),k={code:r,number:parseInt(n)};return new vt(k,s,i,e,void 0,a)}if(k){const[r,n,s,w,I]=k.slice(1,6),we={code:s,number:parseInt(w)},Ae={file:r,line:parseInt(n)};return new vt(we,I,i,e,Ae,a)}if(I){const[r,n,s,w]=I.slice(1,5),k=r,we={code:n,number:parseInt(s)};return new vt(we,w,i,e,k,a)}return null}get program(){return this._programErrorStack.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){return this._programErrorStack.stack}toString(){return this.message}}class bt extends Error{constructor(e,r,n){super(),this.code=e,this.msg=r,this.logs=n,n&&(this._programErrorStack=wt.parse(n))}static parse(e,r){const n=e.toString();let i,s;if(n.includes("custom program error:")){let e=n.split("custom program error: ");if(2!==e.length)return null;i=e[1]}else{const e=n.match(/"Custom":([0-9]+)}/g);if(!e||e.length>1)return null;i=e[0].match(/([0-9]+)/g)[0]}try{s=parseInt(i)}catch(e){return null}let a=r.get(s);return void 0!==a?new bt(s,a,e.logs):(a=qi.get(s),void 0!==a?new bt(s,a,e.logs):null)}get program(){var e;return null===(e=this._programErrorStack)||void 0===e?void 0:e.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){var e;return null===(e=this._programErrorStack)||void 0===e?void 0:e.stack}toString(){return this.msg}}function At(e,r){mt("debug-logs")&&console.log("Translating error:",e);const n=vt.parse(e.logs);if(n)return n;const i=bt.parse(e,r);if(i)return i;if(e.logs){const r={get:function(r,n){return"programErrorStack"===n?r.programErrorStack.stack:"program"===n?r.programErrorStack.stack[e.programErrorStack.stack.length-1]:Reflect.get(...arguments)}};return e.programErrorStack=wt.parse(e.logs),new Proxy(e,r)}return e}const Wi={InstructionMissing:100,InstructionFallbackNotFound:101,InstructionDidNotDeserialize:102,InstructionDidNotSerialize:103,IdlInstructionStub:1e3,IdlInstructionInvalidProgram:1001,ConstraintMut:2e3,ConstraintHasOne:2001,ConstraintSigner:2002,ConstraintRaw:2003,ConstraintOwner:2004,ConstraintRentExempt:2005,ConstraintSeeds:2006,ConstraintExecutable:2007,ConstraintState:2008,ConstraintAssociated:2009,ConstraintAssociatedInit:2010,ConstraintClose:2011,ConstraintAddress:2012,ConstraintZero:2013,ConstraintTokenMint:2014,ConstraintTokenOwner:2015,ConstraintMintMintAuthority:2016,ConstraintMintFreezeAuthority:2017,ConstraintMintDecimals:2018,ConstraintSpace:2019,RequireViolated:2500,RequireEqViolated:2501,RequireKeysEqViolated:2502,RequireNeqViolated:2503,RequireKeysNeqViolated:2504,RequireGtViolated:2505,RequireGteViolated:2506,AccountDiscriminatorAlreadySet:3e3,AccountDiscriminatorNotFound:3001,AccountDiscriminatorMismatch:3002,AccountDidNotDeserialize:3003,AccountDidNotSerialize:3004,AccountNotEnoughKeys:3005,AccountNotMutable:3006,AccountOwnedByWrongProgram:3007,InvalidProgramId:3008,InvalidProgramExecutable:3009,AccountNotSigner:3010,AccountNotSystemOwned:3011,AccountNotInitialized:3012,AccountNotProgramData:3013,AccountNotAssociatedTokenAccount:3014,AccountSysvarMismatch:3015,AccountReallocExceedsLimit:3016,AccountDuplicateReallocs:3017,StateInvalidAddress:4e3,DeclaredProgramIdMismatch:4100,Deprecated:5e3},qi=new Map([[Wi.InstructionMissing,"8 byte instruction identifier not provided"],[Wi.InstructionFallbackNotFound,"Fallback functions are not supported"],[Wi.InstructionDidNotDeserialize,"The program could not deserialize the given instruction"],[Wi.InstructionDidNotSerialize,"The program could not serialize the given instruction"],[Wi.IdlInstructionStub,"The program was compiled without idl instructions"],[Wi.IdlInstructionInvalidProgram,"The transaction was given an invalid program for the IDL instruction"],[Wi.ConstraintMut,"A mut constraint was violated"],[Wi.ConstraintHasOne,"A has_one constraint was violated"],[Wi.ConstraintSigner,"A signer constraint was violated"],[Wi.ConstraintRaw,"A raw constraint was violated"],[Wi.ConstraintOwner,"An owner constraint was violated"],[Wi.ConstraintRentExempt,"A rent exemption constraint was violated"],[Wi.ConstraintSeeds,"A seeds constraint was violated"],[Wi.ConstraintExecutable,"An executable constraint was violated"],[Wi.ConstraintState,"A state constraint was violated"],[Wi.ConstraintAssociated,"An associated constraint was violated"],[Wi.ConstraintAssociatedInit,"An associated init constraint was violated"],[Wi.ConstraintClose,"A close constraint was violated"],[Wi.ConstraintAddress,"An address constraint was violated"],[Wi.ConstraintZero,"Expected zero account discriminant"],[Wi.ConstraintTokenMint,"A token mint constraint was violated"],[Wi.ConstraintTokenOwner,"A token owner constraint was violated"],[Wi.ConstraintMintMintAuthority,"A mint mint authority constraint was violated"],[Wi.ConstraintMintFreezeAuthority,"A mint freeze authority constraint was violated"],[Wi.ConstraintMintDecimals,"A mint decimals constraint was violated"],[Wi.ConstraintSpace,"A space constraint was violated"],[Wi.RequireViolated,"A require expression was violated"],[Wi.RequireEqViolated,"A require_eq expression was violated"],[Wi.RequireKeysEqViolated,"A require_keys_eq expression was violated"],[Wi.RequireNeqViolated,"A require_neq expression was violated"],[Wi.RequireKeysNeqViolated,"A require_keys_neq expression was violated"],[Wi.RequireGtViolated,"A require_gt expression was violated"],[Wi.RequireGteViolated,"A require_gte expression was violated"],[Wi.AccountDiscriminatorAlreadySet,"The account discriminator was already set on this account"],[Wi.AccountDiscriminatorNotFound,"No 8 byte discriminator was found on the account"],[Wi.AccountDiscriminatorMismatch,"8 byte discriminator did not match what was expected"],[Wi.AccountDidNotDeserialize,"Failed to deserialize the account"],[Wi.AccountDidNotSerialize,"Failed to serialize the account"],[Wi.AccountNotEnoughKeys,"Not enough account keys given to the instruction"],[Wi.AccountNotMutable,"The given account is not mutable"],[Wi.AccountOwnedByWrongProgram,"The given account is owned by a different program than expected"],[Wi.InvalidProgramId,"Program ID was not as expected"],[Wi.InvalidProgramExecutable,"Program account is not executable"],[Wi.AccountNotSigner,"The given account did not sign"],[Wi.AccountNotSystemOwned,"The given account is not owned by the system program"],[Wi.AccountNotInitialized,"The program expected this account to be already initialized"],[Wi.AccountNotProgramData,"The given account is not a program data account"],[Wi.AccountNotAssociatedTokenAccount,"The given account is not the associated token account"],[Wi.AccountSysvarMismatch,"The given public key does not match the required sysvar"],[Wi.AccountReallocExceedsLimit,"The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"],[Wi.AccountDuplicateReallocs,"The account was duplicated for more than one reallocation"],[Wi.StateInvalidAddress,"The given state account does not have the correct address"],[Wi.DeclaredProgramIdMismatch,"The declared program id does not match the actual program id"],[Wi.Deprecated,"The API being used is deprecated and should no longer be used"]]);var Et=function(){return Et=Object.assign||function(e){for(var r,n=1,i=arguments.length;n<i;n++)for(var s in r=arguments[n])Object.prototype.hasOwnProperty.call(r,s)&&(e[s]=r[s]);return e},Et.apply(this,arguments)};function It(e){return e.toLowerCase()}var Vi=[/([a-z0-9])([A-Z])/g,/([A-Z])([A-Z][a-z])/g],ji=/[^A-Z0-9]+/gi;function xt(e,r,n){return r instanceof RegExp?e.replace(r,n):r.reduce((function(e,r){return e.replace(r,n)}),e)}class Lt{static fieldLayout(e,r){const n=void 0!==e.name?Ce()(e.name):void 0;switch(e.type){case"bool":return ze.bool(n);case"u8":return ze.u8(n);case"i8":return ze.i8(n);case"u16":return ze.u16(n);case"i16":return ze.i16(n);case"u32":return ze.u32(n);case"i32":return ze.i32(n);case"f32":return ze.f32(n);case"u64":return ze.u64(n);case"i64":return ze.i64(n);case"f64":return ze.f64(n);case"u128":return ze.u128(n);case"i128":return ze.i128(n);case"bytes":return ze.vecU8(n);case"string":return ze.str(n);case"publicKey":return ze.publicKey(n);default:if("vec"in e.type)return ze.vec(Lt.fieldLayout({name:void 0,type:e.type.vec},r),n);if("option"in e.type)return ze.option(Lt.fieldLayout({name:void 0,type:e.type.option},r),n);if("defined"in e.type){const i=e.type.defined;if(void 0===r)throw new gt("User defined types not provided");const s=r.filter((e=>e.name===i));if(1!==s.length)throw new gt(`Type not found: ${JSON.stringify(e)}`);return Lt.typeDefLayout(s[0],r,n)}if("array"in e.type){let i=e.type.array[0],s=e.type.array[1],a=Lt.fieldLayout({name:void 0,type:i},r);return ze.array(a,s,n)}throw new Error(`Not yet implemented: ${e}`)}}static typeDefLayout(e,r=[],n){if("struct"===e.type.kind){const i=e.type.fields.map((e=>Lt.fieldLayout(e,r)));return ze.struct(i,n)}if("enum"===e.type.kind){let i=e.type.variants.map((e=>{const n=Ce()(e.name);if(void 0===e.fields)return ze.struct([],n);const i=e.fields.map((e=>{if(!e.hasOwnProperty("name"))throw new Error("Tuple enum variants not yet implemented.");return Lt.fieldLayout(e,r)}));return ze.struct(i,n)}));return void 0!==n?ze.rustEnum(i).replicate(n):ze.rustEnum(i,n)}throw new Error(`Unknown type kint: ${e}`)}}class Tt{constructor(e){this.idl=e,this.ixLayout=Tt.parseIxLayout(e);const r=new Map;e.instructions.forEach((e=>{const n=zt("global",e.name);r.set(I().encode(n),{layout:this.ixLayout.get(e.name),name:e.name})})),e.state&&e.state.methods.map((e=>{const n=zt("state",e.name);r.set(I().encode(n),{layout:this.ixLayout.get(e.name),name:e.name})})),this.sighashLayouts=r}encode(e,r){return this._encode("global",e,r)}encodeState(e,r){return this._encode("state",e,r)}_encode(e,r,n){const s=i.Buffer.alloc(1e3),a=Ce()(r),w=this.ixLayout.get(a);if(!w)throw new Error(`Unknown method: ${a}`);const k=w.encode(n,s),I=s.slice(0,k);return i.Buffer.concat([zt(e,r),I])}static parseIxLayout(e){const r=(e.state?e.state.methods:[]).map((r=>{let n=r.args.map((r=>{var n,i;return Lt.fieldLayout(r,Array.from([...null!==(n=e.accounts)&&void 0!==n?n:[],...null!==(i=e.types)&&void 0!==i?i:[]]))}));const i=Ce()(r.name);return[i,ze.struct(n,i)]})).concat(e.instructions.map((r=>{let n=r.args.map((r=>{var n,i;return Lt.fieldLayout(r,Array.from([...null!==(n=e.accounts)&&void 0!==n?n:[],...null!==(i=e.types)&&void 0!==i?i:[]]))}));const i=Ce()(r.name);return[i,ze.struct(n,i)]})));return new Map(r)}decode(e,r="hex"){"string"==typeof e&&(e="hex"===r?i.Buffer.from(e,"hex"):I().decode(e));let n=I().encode(e.slice(0,8)),s=e.slice(8);const a=this.sighashLayouts.get(n);return a?{data:a.layout.decode(s),name:a.name}:null}format(e,r){return Ct.format(e,r,this.idl)}}class Ct{static format(e,r,n){const i=n.instructions.filter((r=>e.name===r.name))[0];if(void 0===i)return console.error("Invalid instruction given"),null;const s=i.args.map((r=>({name:r.name,type:Ct.formatIdlType(r.type),data:Ct.formatIdlData(r,e.data[r.name],n.types)}))),a=Ct.flattenIdlAccounts(i.accounts);return{args:s,accounts:r.map(((e,r)=>r<a.length?{name:a[r].name,...e}:{name:void 0,...e}))}}static formatIdlType(e){if("string"==typeof e)return e;if("vec"in e)return`Vec<${this.formatIdlType(e.vec)}>`;if("option"in e)return`Option<${this.formatIdlType(e.option)}>`;if("defined"in e)return e.defined;if("array"in e)return`Array<${e.array[0]}; ${e.array[1]}>`;throw new Error(`Unknown IDL type: ${e}`)}static formatIdlData(e,r,n){if("string"==typeof e.type)return r.toString();if(e.type.hasOwnProperty("vec"))return"["+r.map((r=>this.formatIdlData({name:"",type:e.type.vec},r))).join(", ")+"]";if(e.type.hasOwnProperty("option"))return null===r?"null":this.formatIdlData({name:"",type:e.type.option},r,n);if(e.type.hasOwnProperty("defined")){if(void 0===n)throw new Error("User defined types not provided");const i=n.filter((r=>r.name===e.type.defined));if(1!==i.length)throw new Error(`Type not found: ${e.type.defined}`);return Ct.formatIdlDataDefined(i[0],r,n)}return"unknown"}static formatIdlDataDefined(e,r,n){if("struct"===e.type.kind){const i=e.type;return"{ "+Object.keys(r).map((e=>{const s=i.fields.filter((r=>r.name===e))[0];if(void 0===s)throw new Error("Unable to find type");return e+": "+Ct.formatIdlData(s,r[e],n)})).join(", ")+" }"}if(0===e.type.variants.length)return"{}";if(e.type.variants[0].name){const i=e.type.variants,s=Object.keys(r)[0],a=r[s],w=Object.keys(a).map((e=>{var r;const w=a[e],k=null===(r=i[s])||void 0===r?void 0:r.filter((r=>r.name===e))[0];if(void 0===k)throw new Error("Unable to find variant");return e+": "+Ct.formatIdlData(k,w,n)})).join(", "),k=Ce()(s,{pascalCase:!0});return 0===w.length?k:`${k} { ${w} }`}return"Tuple formatting not yet implemented"}static flattenIdlAccounts(e,r){return e.map((e=>{const n=function(e){const r=e.replace(/([A-Z])/g," $1");return r.charAt(0).toUpperCase()+r.slice(1)}(e.name);if(e.hasOwnProperty("accounts")){const i=r?`${r} > ${n}`:n;return Ct.flattenIdlAccounts(e.accounts,i)}return{...e,name:r?`${r} > ${n}`:n}})).flat()}}function zt(e,r){var n;let s=`${e}:${void 0===n&&(n={}),function Pt(e,r){return void 0===r&&(r={}),function(e,r){void 0===r&&(r={});for(var n=r.splitRegexp,i=void 0===n?Vi:n,s=r.stripRegexp,a=void 0===s?ji:s,w=r.transform,k=void 0===w?It:w,I=r.delimiter,we=void 0===I?" ":I,Ae=xt(xt(e,i,"$1\0$2"),a,"\0"),Ce=0,Be=Ae.length;"\0"===Ae.charAt(Ce);)Ce++;for(;"\0"===Ae.charAt(Be-1);)Be--;return Ae.slice(Ce,Be).split("\0").map(k).join(we)}(e,Et({delimiter:"."},r))}(r,Et({delimiter:"_"},n))}`;return i.Buffer.from(Be.sha256.digest(s)).slice(0,8)}function Bt(e,r){if("enum"===r.type.kind){let n=r.type.variants.map((r=>void 0===r.fields?0:r.fields.map((r=>{if("object"!=typeof r||!("name"in r))throw new Error("Tuple enum variants not yet implemented.");return Ot(e,r.type)})).reduce(((e,r)=>e+r))));return Math.max(...n)+1}return void 0===r.type.fields?0:r.type.fields.map((r=>Ot(e,r.type))).reduce(((e,r)=>e+r),0)}function Ot(e,r){var n,i;switch(r){case"bool":case"u8":case"i8":case"bytes":case"string":return 1;case"i16":case"u16":return 2;case"u32":case"i32":case"f32":return 4;case"u64":case"i64":case"f64":return 8;case"u128":case"i128":return 16;case"publicKey":return 32;default:if("vec"in r)return 1;if("option"in r)return 1+Ot(e,r.option);if("coption"in r)return 4+Ot(e,r.coption);if("defined"in r){const s=null!==(i=null===(n=e.types)||void 0===n?void 0:n.filter((e=>e.name===r.defined)))&&void 0!==i?i:[];if(1!==s.length)throw new gt(`Type not found: ${JSON.stringify(r)}`);return Bt(e,s[0])}if("array"in r){let n=r.array[0],i=r.array[1];return Ot(e,n)*i}throw new Error(`Invalid type ${JSON.stringify(r)}`)}}const Hi=8;class Nt{constructor(e){if(void 0===e.accounts)return void(this.accountLayouts=new Map);const r=e.accounts.map((r=>[r.name,Lt.typeDefLayout(r,e.types)]));this.accountLayouts=new Map(r),this.idl=e}async encode(e,r){const n=i.Buffer.alloc(1e3),s=this.accountLayouts.get(e);if(!s)throw new Error(`Unknown account: ${e}`);const a=s.encode(r,n);let w=n.slice(0,a),k=Nt.accountDiscriminator(e);return i.Buffer.concat([k,w])}decode(e,r){if(Nt.accountDiscriminator(e).compare(r.slice(0,8)))throw new Error("Invalid account discriminator");return this.decodeUnchecked(e,r)}decodeUnchecked(e,r){const n=r.slice(8),i=this.accountLayouts.get(e);if(!i)throw new Error(`Unknown account: ${e}`);return i.decode(n)}memcmp(e,r){const n=Nt.accountDiscriminator(e);return{offset:0,bytes:I().encode(r?i.Buffer.concat([n,r]):n)}}size(e){var r;return 8+(null!==(r=Bt(this.idl,e))&&void 0!==r?r:0)}static accountDiscriminator(e){return i.Buffer.from(Be.sha256.digest(`account:${Ce()(e,{pascalCase:!0})}`)).slice(0,8)}}class Rt{constructor(e){if(void 0===e.events)return void(this.layouts=new Map);const r=e.events.map((r=>{let n={name:r.name,type:{kind:"struct",fields:r.fields.map((e=>({name:e.name,type:e.type})))}};return[r.name,Lt.typeDefLayout(n,e.types)]}));this.layouts=new Map(r),this.discriminators=new Map(void 0===e.events?[]:e.events.map((e=>[we.fromByteArray(Vt(e.name)),e.name])))}decode(e){let r;try{r=i.Buffer.from(we.toByteArray(e))}catch(e){return null}const n=we.fromByteArray(r.slice(0,8)),s=this.discriminators.get(n);if(void 0===s)return null;const a=this.layouts.get(s);if(!a)throw new Error(`Unknown event: ${s}`);return{data:a.decode(r.slice(8)),name:s}}}function Vt(e){return i.Buffer.from(Be.sha256.digest(`event:${e}`)).slice(0,8)}class Ut{constructor(e){if(void 0===e.state)throw new Error("Idl state not defined.");this.layout=Lt.typeDefLayout(e.state.struct,e.types)}async encode(e,r){const n=i.Buffer.alloc(1e3),s=this.layout.encode(r,n),a=await jt(e),w=n.slice(0,s);return i.Buffer.concat([a,w])}decode(e){const r=e.slice(8);return this.layout.decode(r)}}async function jt(e){let r=mt("anchor-deprecated-state")?"account":"state";return i.Buffer.from(Be.sha256.digest(`${r}:${e}`)).slice(0,8)}class $t{constructor(e){if(void 0===e.types)return void(this.typeLayouts=new Map);const r=e.types.map((r=>[r.name,Lt.typeDefLayout(r,e.types)]));this.typeLayouts=new Map(r),this.idl=e}encode(e,r){const n=i.Buffer.alloc(1e3),s=this.typeLayouts.get(e);if(!s)throw new Error(`Unknown type: ${e}`);const a=s.encode(r,n);return n.slice(0,a)}decode(e,r){const n=this.typeLayouts.get(e);if(!n)throw new Error(`Unknown type: ${e}`);return n.decode(r)}}class Kt{constructor(e){this.instruction=new Tt(e),this.accounts=new Nt(e),this.events=new Rt(e),e.state&&(this.state=new Ut(e)),this.types=new $t(e)}}var $i="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:void 0!==n.g?n.g:"undefined"!=typeof self?self:{};class Wt{constructor(e,r){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=r}makeDestinationObject(){return{}}decode(e,r){throw new Error("Layout is abstract")}encode(e,r,n){throw new Error("Layout is abstract")}getSpan(e,r){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const r=Object.create(this.constructor.prototype);return Object.assign(r,this),r.property=e,r}fromArray(e){}}var Yi=Wt;class Ht extends Wt{isCount(){throw new Error("ExternalLayout is abstract")}}class Jt extends Ht{constructor(e,r,n){if(!(e instanceof Wt))throw new TypeError("layout must be a Layout");if(void 0===r)r=0;else if(!Number.isInteger(r))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=r}isCount(){return this.layout instanceof Zt||this.layout instanceof Xt}decode(e,r){return void 0===r&&(r=0),this.layout.decode(e,r+this.offset)}encode(e,r,n){return void 0===n&&(n=0),this.layout.encode(e,r,n+this.offset)}}class Zt extends Wt{constructor(e,r){if(super(e,r),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,r){return void 0===r&&(r=0),e.readUIntLE(r,this.span)}encode(e,r,n){return void 0===n&&(n=0),r.writeUIntLE(e,n,this.span),this.span}}class Xt extends Wt{constructor(e,r){if(super(e,r),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,r){return void 0===r&&(r=0),e.readUIntBE(r,this.span)}encode(e,r,n){return void 0===n&&(n=0),r.writeUIntBE(e,n,this.span),this.span}}const Gi=Math.pow(2,32);function Yt(e){const r=Math.floor(e/Gi);return{hi32:r,lo32:e-r*Gi}}function te(e,r){return e*Gi+r}class ee extends Wt{constructor(e){super(8,e)}decode(e,r){void 0===r&&(r=0);const n=e.readUInt32LE(r);return te(e.readUInt32LE(r+4),n)}encode(e,r,n){void 0===n&&(n=0);const i=Yt(e);return r.writeUInt32LE(i.lo32,n),r.writeUInt32LE(i.hi32,n+4),8}}class ne extends Wt{constructor(e){super(8,e)}decode(e,r){void 0===r&&(r=0);const n=e.readUInt32LE(r);return te(e.readInt32LE(r+4),n)}encode(e,r,n){void 0===n&&(n=0);const i=Yt(e);return r.writeUInt32LE(i.lo32,n),r.writeInt32LE(i.hi32,n+4),8}}class re extends Wt{constructor(e,r,n){if(!Array.isArray(e)||!e.reduce(((e,r)=>e&&r instanceof Wt),!0))throw new TypeError("fields must be array of Layout instances");"boolean"==typeof r&&void 0===n&&(n=r,r=void 0);for(const r of e)if(0>r.span&&void 0===r.property)throw new Error("fields cannot contain unnamed variable-length layout");let i=-1;try{i=e.reduce(((e,r)=>e+r.getSpan()),0)}catch(e){}super(i,r),this.fields=e,this.decodePrefixes=!!n}getSpan(e,r){if(0<=this.span)return this.span;void 0===r&&(r=0);let n=0;try{n=this.fields.reduce(((n,i)=>{const s=i.getSpan(e,r);return r+=s,n+s}),0)}catch(e){throw new RangeError("indeterminate span")}return n}decode(e,r){void 0===r&&(r=0);const n=this.makeDestinationObject();for(const i of this.fields)if(void 0!==i.property&&(n[i.property]=i.decode(e,r)),r+=i.getSpan(e,r),this.decodePrefixes&&e.length===r)break;return n}encode(e,r,n){void 0===n&&(n=0);const i=n;let s=0,a=0;for(const i of this.fields){let w=i.span;if(a=0<w?w:0,void 0!==i.property){const s=e[i.property];void 0!==s&&(a=i.encode(s,r,n),0>w&&(w=i.getSpan(r,n)))}s=n,n+=w}return s+a-i}fromArray(e){const r=this.makeDestinationObject();for(const n of this.fields)void 0!==n.property&&0<e.length&&(r[n.property]=e.shift());return r}layoutFor(e){if("string"!=typeof e)throw new TypeError("property must be string");for(const r of this.fields)if(r.property===e)return r}offsetOf(e){if("string"!=typeof e)throw new TypeError("property must be string");let r=0;for(const n of this.fields){if(n.property===e)return r;0>n.span?r=-1:0<=r&&(r+=n.span)}}}class oe{constructor(e){this.property=e}decode(){throw new Error("UnionDiscriminator is abstract")}encode(){throw new Error("UnionDiscriminator is abstract")}}class ie extends oe{constructor(e,r){if(!(e instanceof Ht&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(r||e.property||"variant"),this.layout=e}decode(e,r){return this.layout.decode(e,r)}encode(e,r,n){return this.layout.encode(e,r,n)}}class se extends Wt{constructor(e,r,n){const i=e instanceof Zt||e instanceof Xt;if(i)e=new ie(new Jt(e));else if(e instanceof Ht&&e.isCount())e=new ie(e);else if(!(e instanceof oe))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(void 0===r&&(r=null),!(null===r||r instanceof Wt))throw new TypeError("defaultLayout must be null or a Layout");if(null!==r){if(0>r.span)throw new Error("defaultLayout must have constant span");void 0===r.property&&(r=r.replicate("content"))}let s=-1;r&&(s=r.span,0<=s&&i&&(s+=e.layout.span)),super(s,n),this.discriminator=e,this.usesPrefixDiscriminator=i,this.defaultLayout=r,this.registry={};let a=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(e){return a(e)},this.configGetSourceVariant=function(e){a=e.bind(this)}}getSpan(e,r){if(0<=this.span)return this.span;void 0===r&&(r=0);const n=this.getVariant(e,r);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,r)}defaultGetSourceVariant(e){if(e.hasOwnProperty(this.discriminator.property)){if(this.defaultLayout&&e.hasOwnProperty(this.defaultLayout.property))return;const r=this.registry[e[this.discriminator.property]];if(r&&(!r.layout||e.hasOwnProperty(r.property)))return r}else for(const r in this.registry){const n=this.registry[r];if(e.hasOwnProperty(n.property))return n}throw new Error("unable to infer src variant")}decode(e,r){let n;void 0===r&&(r=0);const i=this.discriminator,s=i.decode(e,r);let a=this.registry[s];if(void 0===a){let w=0;a=this.defaultLayout,this.usesPrefixDiscriminator&&(w=i.layout.span),n=this.makeDestinationObject(),n[i.property]=s,n[a.property]=this.defaultLayout.decode(e,r+w)}else n=a.decode(e,r);return n}encode(e,r,n){void 0===n&&(n=0);const i=this.getSourceVariant(e);if(void 0===i){const i=this.discriminator,s=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=i.layout.span),i.encode(e[i.property],r,n),a+s.encode(e[s.property],r,n+a)}return i.encode(e,r,n)}addVariant(e,r,n){const i=new ae(this,e,r,n);return this.registry[e]=i,i}getVariant(e,r){let n=e;return Oi.isBuffer(e)&&(void 0===r&&(r=0),n=this.discriminator.decode(e,r)),this.registry[n]}}class ae extends Wt{constructor(e,r,n,i){if(!(e instanceof se))throw new TypeError("union must be a Union");if(!Number.isInteger(r)||0>r)throw new TypeError("variant must be a (non-negative) integer");if("string"==typeof n&&void 0===i&&(i=n,n=null),n){if(!(n instanceof Wt))throw new TypeError("layout must be a Layout");if(null!==e.defaultLayout&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if("string"!=typeof i)throw new TypeError("variant must have a String property")}let s=e.span;0>e.span&&(s=n?n.span:0,0<=s&&e.usesPrefixDiscriminator&&(s+=e.discriminator.layout.span)),super(s,i),this.union=e,this.variant=r,this.layout=n||null}getSpan(e,r){if(0<=this.span)return this.span;void 0===r&&(r=0);let n=0;return this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),n+this.layout.getSpan(e,r+n)}decode(e,r){const n=this.makeDestinationObject();if(void 0===r&&(r=0),this!==this.union.getVariant(e,r))throw new Error("variant mismatch");let i=0;return this.union.usesPrefixDiscriminator&&(i=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,r+i):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,r,n){void 0===n&&(n=0);let i=0;if(this.union.usesPrefixDiscriminator&&(i=this.union.discriminator.layout.span),this.layout&&!e.hasOwnProperty(this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,r,n);let s=i;if(this.layout&&(this.layout.encode(e[this.property],r,n+i),s+=this.layout.getSpan(r,n+i),0<=this.union.span&&s>this.union.span))throw new Error("encoded variant overruns containing union");return s}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}class ce extends Wt{constructor(e,r){if(!(e instanceof Ht&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof Ht||(n=e),super(n,r),this.length=e}getSpan(e,r){let n=this.span;return 0>n&&(n=this.length.decode(e,r)),n}decode(e,r){void 0===r&&(r=0);let n=this.span;return 0>n&&(n=this.length.decode(e,r)),e.slice(r,r+n)}encode(e,r,n){let i=this.length;if(this.length instanceof Ht&&(i=e.length),!Oi.isBuffer(e)||i!==e.length)throw new TypeError((s="Blob.encode",(this.property?s+"["+this.property+"]":s)+" requires (length "+i+") Buffer as src"));var s;if(n+i>r.length)throw new RangeError("encoding overruns Buffer");return r.write(e.toString("hex"),n,i,"hex"),this.length instanceof Ht&&this.length.encode(i,r,n),i}}var ue=(e,r,n)=>new Jt(e,r,n),de=e=>new Zt(1,e),le=e=>new Zt(4,e),he=e=>new ee(e),pe=e=>new ne(e),fe=(e,r,n)=>new re(e,r,n),me=(e,r,n)=>new se(e,r,n),ye=(e,r)=>new ce(e,r);class ge{constructor(e){}encode(e,r){switch(Ce()(e)){case"initializeMint":return function({decimals:e,mintAuthority:r,freezeAuthority:n}){return be({initializeMint:{decimals:e,mintAuthority:r.toBuffer(),freezeAuthorityOption:!!n,freezeAuthority:(n||s.PublicKey.default).toBuffer()}})}(r);case"initializeAccount":return be({initializeAccount:{}});case"initializeMultisig":return function({m:e}){return be({initializeMultisig:{m:e}})}(r);case"transfer":return function({amount:e}){return be({transfer:{amount:e}})}(r);case"approve":return function({amount:e}){return be({approve:{amount:e}})}(r);case"revoke":return be({revoke:{}});case"setAuthority":return function({authorityType:e,newAuthority:r}){return be({setAuthority:{authorityType:e,newAuthority:r}})}(r);case"mintTo":return function({amount:e}){return be({mintTo:{amount:e}})}(r);case"burn":return function({amount:e}){return be({burn:{amount:e}})}(r);case"closeAccount":return be({closeAccount:{}});case"freezeAccount":return be({freezeAccount:{}});case"thawAccount":return be({thawAccount:{}});case"transferChecked":return function({amount:e,decimals:r}){return be({transferChecked:{amount:e,decimals:r}})}(r);case"approvedChecked":return function({amount:e,decimals:r}){return be({approveChecked:{amount:e,decimals:r}})}(r);case"mintToChecked":return function({amount:e,decimals:r}){return be({mintToChecked:{amount:e,decimals:r}})}(r);case"burnChecked":return function({amount:e,decimals:r}){return be({burnChecked:{amount:e,decimals:r}})}(r);case"intializeAccount2":return function({authority:e}){return be({initilaizeAccount2:{authority:e}})}(r);case"syncNative":return be({syncNative:{}});case"initializeAccount3":return function({authority:e}){return be({initializeAccount3:{authority:e}})}(r);case"initializeMultisig2":return function({m:e}){return be({initializeMultisig2:{m:e}})}(r);case"initializeMint2":return function({decimals:e,mintAuthority:r,freezeAuthority:n}){return be({encodeInitializeMint2:{decimals:e,mintAuthority:r,freezeAuthority:n}})}(r);default:throw new Error(`Invalid instruction: ${e}`)}}encodeState(e,r){throw new Error("SPL token does not have state")}}const Ji=me(de("instruction"));function ve(e){return ye(32,e)}function be(e){let r=Oi.alloc(Zi),n=Ji.encode(e,r);return r.slice(0,n)}Ji.addVariant(0,fe([de("decimals"),ye(32,"mintAuthority"),de("freezeAuthorityOption"),ve("freezeAuthority")]),"initializeMint"),Ji.addVariant(1,fe([]),"initializeAccount"),Ji.addVariant(2,fe([de("m")]),"initializeMultisig"),Ji.addVariant(3,fe([he("amount")]),"transfer"),Ji.addVariant(4,fe([he("amount")]),"approve"),Ji.addVariant(5,fe([]),"revoke"),Ji.addVariant(6,fe([de("authorityType"),de("newAuthorityOption"),ve("newAuthority")]),"setAuthority"),Ji.addVariant(7,fe([he("amount")]),"mintTo"),Ji.addVariant(8,fe([he("amount")]),"burn"),Ji.addVariant(9,fe([]),"closeAccount"),Ji.addVariant(10,fe([]),"freezeAccount"),Ji.addVariant(11,fe([]),"thawAccount"),Ji.addVariant(12,fe([he("amount"),de("decimals")]),"transferChecked"),Ji.addVariant(13,fe([he("amount"),de("decimals")]),"approvedChecked"),Ji.addVariant(14,fe([he("amount"),de("decimals")]),"mintToChecked"),Ji.addVariant(15,fe([he("amount"),de("decimals")]),"burnedChecked"),Ji.addVariant(16,fe([ve("authority")]),"InitializeAccount2"),Ji.addVariant(17,fe([]),"syncNative"),Ji.addVariant(18,fe([ve("authority")]),"initializeAccount3"),Ji.addVariant(19,fe([de("m")]),"initializeMultisig2"),Ji.addVariant(20,fe([de("decimals"),ve("mintAuthority"),de("freezeAuthorityOption"),ve("freezeAuthority")]),"initializeMint2");const Zi=Math.max(...Object.values(Ji.registry).map((e=>e.span)));class _e{constructor(e){}encode(e,r){throw new Error("SPL token does not have state")}decode(e){throw new Error("SPL token does not have state")}}function Se(e){return new ke(ye(8),(e=>Le.fromBuffer(e)),(e=>e.toBuffer()),e)}function Ee(e){return new ke(ye(32),(e=>new s.PublicKey(e)),(e=>e.toBuffer()),e)}function Ie(e,r){return new Me(e,r)}class ke extends Yi{constructor(e,r,n,i){super(e.span,i),this.layout=e,this.decoder=r,this.encoder=n}decode(e,r){return this.decoder(this.layout.decode(e,r))}encode(e,r,n){return this.layout.encode(this.encoder(e),r,n)}getSpan(e,r){return this.layout.getSpan(e,r)}}class Me extends Yi{constructor(e,r){super(-1,r),this.layout=e,this.discriminator=le()}encode(e,r,n=0){return null==e?this.layout.span+this.discriminator.encode(0,r,n):(this.discriminator.encode(1,r,n),this.layout.encode(e,r,n+4)+4)}decode(e,r=0){const n=this.discriminator.decode(e,r);if(0===n)return null;if(1===n)return this.layout.decode(e,r+4);throw new Error("Invalid coption "+this.layout.property)}getSpan(e,r=0){return this.layout.getSpan(e,r+4)+4}}class Le extends(w()){toBuffer(){const e=super.toArray().reverse(),r=Oi.from(e);if(8===r.length)return r;if(r.length>=8)throw new Error("u64 too large");const n=Oi.alloc(8);return r.copy(n),n}static fromBuffer(e){if(8!==e.length)throw new Error(`Invalid buffer length: ${e.length}`);return new Le([...e].reverse().map((e=>`00${e.toString(16)}`.slice(-2))).join(""),16)}}class Te{constructor(e){this.idl=e}async encode(e,r){switch(e){case"token":{const e=Oi.alloc(165),n=Qi.encode(r,e);return e.slice(0,n)}case"mint":{const e=Oi.alloc(82),n=Xi.encode(r,e);return e.slice(0,n)}default:throw new Error(`Invalid account name: ${e}`)}}decode(e,r){return this.decodeUnchecked(e,r)}decodeUnchecked(e,r){switch(e){case"token":return function(e){return Qi.decode(e)}(r);case"mint":return function(e){return Xi.decode(e)}(r);default:throw new Error(`Invalid account name: ${e}`)}}memcmp(e,r){switch(e){case"token":return{dataSize:165};case"mint":return{dataSize:82};default:throw new Error(`Invalid account name: ${e}`)}}size(e){var r;return null!==(r=Bt(this.idl,e))&&void 0!==r?r:0}}const Xi=fe([Ie(Ee(),"mintAuthority"),Se("supply"),de("decimals"),("isInitialized",new ke(de(),(function xe(e){if(0===e)return!1;if(1===e)return!0;throw new Error("Invalid bool: "+e)}),(function Pe(e){return e?1:0}),"isInitialized")),Ie(Ee(),"freezeAuthority")]);const Qi=fe([Ee("mint"),Ee("authority"),Se("amount"),Ie(Ee(),"delegate"),de("state"),Ie(Se(),"isNative"),Se("delegatedAmount"),Ie(Ee(),"closeAuthority")]);class Oe{constructor(e){}decode(e){throw new Error("SPL token program does not have events")}}class De{constructor(e){}encode(e,r){throw new Error("SPL token does not have user-defined types")}decode(e,r){throw new Error("SPL token does not have user-defined types")}}class Ne{constructor(e){this.instruction=new ge(e),this.accounts=new Te(e),this.events=new Oe(e),this.state=new _e(e),this.types=new De(e)}}class Re{constructor(e){}encode(e,r){switch(Ce()(e)){case"createAccount":return function({lamports:e,space:r,owner:n}){return Ke({createAccount:{lamports:e,space:r,owner:n.toBuffer()}})}(r);case"assign":return function({owner:e}){return Ke({assign:{owner:e.toBuffer()}})}(r);case"transfer":return function({lamports:e}){return Ke({transfer:{lamports:e}})}(r);case"createAccountWithSeed":return function({base:e,seed:r,lamports:n,space:i,owner:s}){return Ke({createAccountWithSeed:{base:e.toBuffer(),seed:r,lamports:n,space:i,owner:s.toBuffer()}},eo.getVariant(3).span+r.length)}(r);case"advanceNonceAccount":return function({authorized:e}){return Ke({advanceNonceAccount:{authorized:e.toBuffer()}})}(r);case"withdrawNonceAccount":return function({lamports:e}){return Ke({withdrawNonceAccount:{lamports:e}})}(r);case"initializeNonceAccount":return function({authorized:e}){return Ke({initializeNonceAccount:{authorized:e.toBuffer()}})}(r);case"authorizeNonceAccount":return function({authorized:e}){return Ke({authorizeNonceAccount:{authorized:e.toBuffer()}})}(r);case"allocate":return function({space:e}){return Ke({allocate:{space:e}})}(r);case"allocateWithSeed":return function({base:e,seed:r,space:n,owner:i}){return Ke({allocateWithSeed:{base:e.toBuffer(),seed:r,space:n,owner:i.toBuffer()}},eo.getVariant(9).span+r.length)}(r);case"assignWithSeed":return function({base:e,seed:r,owner:n}){return Ke({assignWithSeed:{base:e.toBuffer(),seed:r,owner:n.toBuffer()}},eo.getVariant(10).span+r.length)}(r);case"transferWithSeed":return function({lamports:e,seed:r,owner:n}){return Ke({transferWithSeed:{lamports:e,seed:r,owner:n.toBuffer()}},eo.getVariant(11).span+r.length)}(r);default:throw new Error(`Invalid instruction: ${e}`)}}encodeState(e,r){throw new Error("System does not have state")}}class Ve extends Yi{constructor(e){super(-1,e),this.property=e,this.layout=fe([le("length"),le("lengthPadding"),ye(ue(le(),-8),"chars")],this.property)}encode(e,r,n=0){if(null==e)return this.layout.span;const i={chars:Oi.from(e,"utf8")};return this.layout.encode(i,r,n)}decode(e,r=0){return this.layout.decode(e,r).chars.toString()}getSpan(e,r=0){return le().span+le().span+new(w())(new Uint8Array(e).slice(r,r+4),10,"le").toNumber()}}function Ue(e){return new Ve(e)}function je(e){return ye(32,e)}const eo=me(le("instruction"));function Ke(e,r){const n=Oi.alloc(null!=r?r:to),i=eo.encode(e,n);return void 0===r?n.slice(0,i):n}eo.addVariant(0,fe([pe("lamports"),pe("space"),je("owner")]),"createAccount"),eo.addVariant(1,fe([je("owner")]),"assign"),eo.addVariant(2,fe([pe("lamports")]),"transfer"),eo.addVariant(3,fe([je("base"),Ue("seed"),pe("lamports"),pe("space"),je("owner")]),"createAccountWithSeed"),eo.addVariant(4,fe([je("authorized")]),"advanceNonceAccount"),eo.addVariant(5,fe([pe("lamports")]),"withdrawNonceAccount"),eo.addVariant(6,fe([je("authorized")]),"initializeNonceAccount"),eo.addVariant(7,fe([je("authorized")]),"authorizeNonceAccount"),eo.addVariant(8,fe([pe("space")]),"allocate"),eo.addVariant(9,fe([je("base"),Ue("seed"),pe("space"),je("owner")]),"allocateWithSeed"),eo.addVariant(10,fe([je("base"),Ue("seed"),je("owner")]),"assignWithSeed"),eo.addVariant(11,fe([pe("lamports"),Ue("seed"),je("owner")]),"transferWithSeed");const to=Math.max(...Object.values(eo.registry).map((e=>e.span)));class Fe{constructor(e){}encode(e,r){throw new Error("System does not have state")}decode(e){throw new Error("System does not have state")}}class We{constructor(e){this.idl=e}async encode(e,r){if("nonce"===e){const e=Oi.alloc(s.NONCE_ACCOUNT_LENGTH),n=ro.encode(r,e);return e.slice(0,n)}throw new Error(`Invalid account name: ${e}`)}decode(e,r){return this.decodeUnchecked(e,r)}decodeUnchecked(e,r){if("nonce"===e)return function(e){return ro.decode(e)}(r);throw new Error(`Invalid account name: ${e}`)}memcmp(e,r){if("nonce"===e)return{dataSize:s.NONCE_ACCOUNT_LENGTH};throw new Error(`Invalid account name: ${e}`)}size(e){var r;return null!==(r=Bt(this.idl,e))&&void 0!==r?r:0}}class Ge extends Yi{constructor(e,r,n,i){super(e.span,i),this.layout=e,this.decoder=r,this.encoder=n}decode(e,r){return this.decoder(this.layout.decode(e,r))}encode(e,r,n){return this.layout.encode(this.encoder(e),r,n)}getSpan(e,r){return this.layout.getSpan(e,r)}}function He(e){return new Ge(ye(32),(e=>new s.PublicKey(e)),(e=>e.toBuffer()),e)}const ro=fe([le("version"),le("state"),He("authorizedPubkey"),He("nonce"),fe([he("lamportsPerSignature")],"feeCalculator")]);class Ze{constructor(e){}decode(e){throw new Error("System program does not have events")}}class Xe{constructor(e){}encode(e,r){throw new Error("System does not have user-defined types")}decode(e,r){throw new Error("System does not have user-defined types")}}class Qe{constructor(e){this.instruction=new Re(e),this.accounts=new We(e),this.events=new Ze(e),this.state=new Fe(e),this.types=new Xe(e)}}var no=Object.freeze({__proto__:null,hash:function(e){return(0,Be.sha256)(e)}});function tn(e,r,n){const a=i.Buffer.concat([e.toBuffer(),i.Buffer.from(r),n.toBuffer()]),w=Be.sha256.digest(a);return new s.PublicKey(i.Buffer.from(w))}function en(e,r){let n=i.Buffer.alloc(0);e.forEach((function(e){if(e.length>32)throw new TypeError("Max seed length exceeded");n=i.Buffer.concat([n,rn(e)])})),n=i.Buffer.concat([n,r.toBuffer(),i.Buffer.from("ProgramDerivedAddress")]);let a=(0,Be.sha256)(new Uint8Array(n)),k=new(w())(a,16).toArray(void 0,32);if(s.PublicKey.isOnCurve(new Uint8Array(k)))throw new Error("Invalid seeds, address must fall off the curve");return new s.PublicKey(k)}function nn(e,r){let n,s=255;for(;0!=s;){try{n=en(e.concat(i.Buffer.from([s])),r)}catch(e){if(e instanceof TypeError)throw e;s--;continue}return[n,s]}throw new Error("Unable to find a viable program address nonce")}const rn=e=>e instanceof i.Buffer?e:e instanceof Uint8Array?i.Buffer.from(e.buffer,e.byteOffset,e.byteLength):i.Buffer.from(e);async function on(e,...r){let n=[i.Buffer.from([97,110,99,104,111,114])];r.forEach((e=>{n.push(e instanceof i.Buffer?e:L(e).toBuffer())}));const[a]=await s.PublicKey.findProgramAddress(n,L(e));return a}var io=Object.freeze({__proto__:null,createWithSeedSync:tn,createProgramAddressSync:en,findProgramAddressSync:nn,associated:on});const oo=new s.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),so=new s.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");var ao=Object.freeze({__proto__:null,TOKEN_PROGRAM_ID:oo,ASSOCIATED_PROGRAM_ID:so,associatedAddress:async function({mint:e,owner:r}){return(await s.PublicKey.findProgramAddress([r.toBuffer(),oo.toBuffer(),e.toBuffer()],so))[0]}}),co={exports:{}};!function(e,r){var n="undefined"!=typeof self?self:$i,i=function(){function t(){this.fetch=!1,this.DOMException=n.DOMException}return t.prototype=n,new t}();!function(e){!function(r){var n="URLSearchParams"in e,i="Symbol"in e&&"iterator"in Symbol,s="FileReader"in e&&"Blob"in e&&function(){try{return new Blob,!0}catch(e){return!1}}(),a="FormData"in e,w="ArrayBuffer"in e;if(w)var k=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],I=ArrayBuffer.isView||function(e){return e&&k.indexOf(Object.prototype.toString.call(e))>-1};function u(e){if("string"!=typeof e&&(e=String(e)),/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(e))throw new TypeError("Invalid character in header field name");return e.toLowerCase()}function d(e){return"string"!=typeof e&&(e=String(e)),e}function l(e){var r={next:function(){var r=e.shift();return{done:void 0===r,value:r}}};return i&&(r[Symbol.iterator]=function(){return r}),r}function h(e){this.map={},e instanceof h?e.forEach((function(e,r){this.append(r,e)}),this):Array.isArray(e)?e.forEach((function(e){this.append(e[0],e[1])}),this):e&&Object.getOwnPropertyNames(e).forEach((function(r){this.append(r,e[r])}),this)}function p(e){if(e.bodyUsed)return Promise.reject(new TypeError("Already read"));e.bodyUsed=!0}function f(e){return new Promise((function(r,n){e.onload=function(){r(e.result)},e.onerror=function(){n(e.error)}}))}function m(e){var r=new FileReader,n=f(r);return r.readAsArrayBuffer(e),n}function y(e){if(e.slice)return e.slice(0);var r=new Uint8Array(e.byteLength);return r.set(new Uint8Array(e)),r.buffer}function g(){return this.bodyUsed=!1,this._initBody=function(e){var r;this._bodyInit=e,e?"string"==typeof e?this._bodyText=e:s&&Blob.prototype.isPrototypeOf(e)?this._bodyBlob=e:a&&FormData.prototype.isPrototypeOf(e)?this._bodyFormData=e:n&&URLSearchParams.prototype.isPrototypeOf(e)?this._bodyText=e.toString():w&&s&&(r=e)&&DataView.prototype.isPrototypeOf(r)?(this._bodyArrayBuffer=y(e.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):w&&(ArrayBuffer.prototype.isPrototypeOf(e)||I(e))?this._bodyArrayBuffer=y(e):this._bodyText=e=Object.prototype.toString.call(e):this._bodyText="",this.headers.get("content-type")||("string"==typeof e?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):n&&URLSearchParams.prototype.isPrototypeOf(e)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"))},s&&(this.blob=function(){var e=p(this);if(e)return e;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?p(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(m)}),this.text=function(){var e=p(this);if(e)return e;if(this._bodyBlob)return function(e){var r=new FileReader,n=f(r);return r.readAsText(e),n}(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(function(e){for(var r=new Uint8Array(e),n=new Array(r.length),i=0;i<r.length;i++)n[i]=String.fromCharCode(r[i]);return n.join("")}(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},a&&(this.formData=function(){return this.text().then(b)}),this.json=function(){return this.text().then(JSON.parse)},this}h.prototype.append=function(e,r){e=u(e),r=d(r);var n=this.map[e];this.map[e]=n?n+", "+r:r},h.prototype.delete=function(e){delete this.map[u(e)]},h.prototype.get=function(e){return e=u(e),this.has(e)?this.map[e]:null},h.prototype.has=function(e){return this.map.hasOwnProperty(u(e))},h.prototype.set=function(e,r){this.map[u(e)]=d(r)},h.prototype.forEach=function(e,r){for(var n in this.map)this.map.hasOwnProperty(n)&&e.call(r,this.map[n],n,this)},h.prototype.keys=function(){var e=[];return this.forEach((function(r,n){e.push(n)})),l(e)},h.prototype.values=function(){var e=[];return this.forEach((function(r){e.push(r)})),l(e)},h.prototype.entries=function(){var e=[];return this.forEach((function(r,n){e.push([n,r])})),l(e)},i&&(h.prototype[Symbol.iterator]=h.prototype.entries);var we=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];function v(e,r){var n,i,s=(r=r||{}).body;if(e instanceof v){if(e.bodyUsed)throw new TypeError("Already read");this.url=e.url,this.credentials=e.credentials,r.headers||(this.headers=new h(e.headers)),this.method=e.method,this.mode=e.mode,this.signal=e.signal,s||null==e._bodyInit||(s=e._bodyInit,e.bodyUsed=!0)}else this.url=String(e);if(this.credentials=r.credentials||this.credentials||"same-origin",!r.headers&&this.headers||(this.headers=new h(r.headers)),this.method=(i=(n=r.method||this.method||"GET").toUpperCase(),we.indexOf(i)>-1?i:n),this.mode=r.mode||this.mode||null,this.signal=r.signal||this.signal,this.referrer=null,("GET"===this.method||"HEAD"===this.method)&&s)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(s)}function b(e){var r=new FormData;return e.trim().split("&").forEach((function(e){if(e){var n=e.split("="),i=n.shift().replace(/\+/g," "),s=n.join("=").replace(/\+/g," ");r.append(decodeURIComponent(i),decodeURIComponent(s))}})),r}function A(e,r){r||(r={}),this.type="default",this.status=void 0===r.status?200:r.status,this.ok=this.status>=200&&this.status<300,this.statusText="statusText"in r?r.statusText:"OK",this.headers=new h(r.headers),this.url=r.url||"",this._initBody(e)}v.prototype.clone=function(){return new v(this,{body:this._bodyInit})},g.call(v.prototype),g.call(A.prototype),A.prototype.clone=function(){return new A(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new h(this.headers),url:this.url})},A.error=function(){var e=new A(null,{status:0,statusText:""});return e.type="error",e};var Ae=[301,302,303,307,308];A.redirect=function(e,r){if(-1===Ae.indexOf(r))throw new RangeError("Invalid status code");return new A(null,{status:r,headers:{location:e}})},r.DOMException=e.DOMException;try{new r.DOMException}catch(e){r.DOMException=function(e,r){this.message=e,this.name=r;var n=Error(e);this.stack=n.stack},r.DOMException.prototype=Object.create(Error.prototype),r.DOMException.prototype.constructor=r.DOMException}function S(e,n){return new Promise((function(i,a){var w=new v(e,n);if(w.signal&&w.signal.aborted)return a(new r.DOMException("Aborted","AbortError"));var k=new XMLHttpRequest;function c(){k.abort()}k.onload=function(){var e,r,n={status:k.status,statusText:k.statusText,headers:(e=k.getAllResponseHeaders()||"",r=new h,e.replace(/\r?\n[\t ]+/g," ").split(/\r?\n/).forEach((function(e){var n=e.split(":"),i=n.shift().trim();if(i){var s=n.join(":").trim();r.append(i,s)}})),r)};n.url="responseURL"in k?k.responseURL:n.headers.get("X-Request-URL");var s="response"in k?k.response:k.responseText;i(new A(s,n))},k.onerror=function(){a(new TypeError("Network request failed"))},k.ontimeout=function(){a(new TypeError("Network request failed"))},k.onabort=function(){a(new r.DOMException("Aborted","AbortError"))},k.open(w.method,w.url,!0),"include"===w.credentials?k.withCredentials=!0:"omit"===w.credentials&&(k.withCredentials=!1),"responseType"in k&&s&&(k.responseType="blob"),w.headers.forEach((function(e,r){k.setRequestHeader(r,e)})),w.signal&&(w.signal.addEventListener("abort",c),k.onreadystatechange=function(){4===k.readyState&&w.signal.removeEventListener("abort",c)}),k.send(void 0===w._bodyInit?null:w._bodyInit)}))}S.polyfill=!0,e.fetch||(e.fetch=S,e.Headers=h,e.Request=v,e.Response=A),r.Headers=h,r.Request=v,r.Response=A,r.fetch=S,Object.defineProperty(r,"__esModule",{value:!0})}({})}(i),i.fetch.ponyfill=!0,delete i.fetch.polyfill;var s=i;(r=s.fetch).default=s.fetch,r.fetch=s.fetch,r.Headers=s.Headers,r.Request=s.Request,r.Response=s.Response,e.exports=r}(co,co.exports);var uo=function Ft(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}(co.exports);async function hn(e,r){const n=await e.getAccountInfo(r);if(null===n)throw new Error("program account not found");const{program:i}=fn(n.data),s=await e.getAccountInfo(i.programdataAddress);if(null===s)throw new Error("program data account not found");const{programData:a}=fn(s.data);return a}const lo=ze.rustEnum([ze.struct([],"uninitialized"),ze.struct([ze.option(ze.publicKey(),"authorityAddress")],"buffer"),ze.struct([ze.publicKey("programdataAddress")],"program"),ze.struct([ze.u64("slot"),ze.option(ze.publicKey(),"upgradeAuthorityAddress")],"programData")],void 0,ze.u32());function fn(e){return lo.decode(e)}var ho=Object.freeze({__proto__:null,verifiedBuild:async function(e,r,n=5){const i=`https://api.apr.dev/api/v0/program/${r.toString()}/latest?limit=${n}`,[s,a]=await Promise.all([hn(e,r),uo(i)]),w=(await a.json()).filter((e=>!e.aborted&&"Built"===e.state&&"Verified"===e.verified));if(0===w.length)return null;const k=w[0];return s.slot.toNumber()!==k.verified_slot?null:k},fetchData:hn,decodeUpgradeableLoaderState:fn}),fo=Object.freeze({__proto__:null,sha256:no,rpc:Di,publicKey:io,bytes:Ci,token:ao,features:Fi,registry:ho});const go=ze.struct([ze.publicKey("authority"),ze.vecU8("data")]);function wn(e,r){var n,i;let s={};const a=e.args?e.args.length:0;if(r.length>a){if(r.length!==a+1)throw new Error(`provided too many arguments ${r} to instruction ${null==e?void 0:e.name} expecting: ${null!==(i=null===(n=e.args)||void 0===n?void 0:n.map((e=>e.name)))&&void 0!==i?i:[]}`);s=r.pop()}return[r,s]}class vn{static build(e,r,n){if("_inner"===e.name)throw new gt("the _inner name is reserved");const o=(...i)=>{const[a,w]=wn(e,[...i]);P(e.accounts,w.accounts);const k=o.accounts(w.accounts);return void 0!==w.remainingAccounts&&k.push(...w.remainingAccounts),mt("debug-logs")&&console.log("Outgoing account metas:",k),new s.TransactionInstruction({keys:k,programId:n,data:r(e.name,x(e,...a))})};return o.accounts=r=>vn.accountsArray(r,e.accounts,e.name),o}static accountsArray(e,r,n){return e?r.map((r=>{if(void 0!==("accounts"in r?r.accounts:void 0)){const i=e[r.name];return vn.accountsArray(i,r.accounts,n).flat()}{const i=r;let s;try{s=L(e[r.name])}catch(e){throw new Error(`Wrong input type for account "${r.name}" in the instruction accounts object${void 0!==n?' for instruction "'+n+'"':""}. Expected PublicKey or string.`)}return{pubkey:s,isWritable:i.isMut,isSigner:i.isSigner}}})).flat():[]}}class browser_bn{static build(e,r,n,i){return async(...s)=>{var a;const w=r(...s),[,k]=wn(e,[...s]);if(void 0===i.sendAndConfirm)throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");try{return await i.sendAndConfirm(w,null!==(a=k.signers)&&void 0!==a?a:[],k.options)}catch(e){throw At(e,n)}}}}class An{static build(e,r){return(...n)=>{var i,a,w;const[,k]=wn(e,[...n]),I=new s.Transaction;if(k.preInstructions&&k.instructions)throw new Error("instructions is deprecated, use preInstructions");return null===(i=k.preInstructions)||void 0===i||i.forEach((e=>I.add(e))),null===(a=k.instructions)||void 0===a||a.forEach((e=>I.add(e))),I.add(r(...n)),null===(w=k.postInstructions)||void 0===w||w.forEach((e=>I.add(e))),I}}}class _n{constructor(e,r,n=lt(),i=new Kt(e)){this.provider=n,this.coder=i,this._idl=e,this._programId=r,this._address=Sn(r),this._sub=null;const[a,w,k]=(()=>{var a;let w={},k={},I={};return null===(a=e.state)||void 0===a||a.methods.forEach((a=>{const we=vn.build(a,((e,r)=>i.instruction.encodeState(e,r)),r);we.accounts=e=>{const i=function(e,r,n,i){if("new"===n.name){const[n]=nn([],e);if(void 0===r.wallet)throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");return[{pubkey:r.wallet.publicKey,isWritable:!1,isSigner:!0},{pubkey:Sn(e),isWritable:!0,isSigner:!1},{pubkey:n,isWritable:!1,isSigner:!1},{pubkey:s.SystemProgram.programId,isWritable:!1,isSigner:!1},{pubkey:e,isWritable:!1,isSigner:!1}]}return P(n.accounts,i),[{pubkey:Sn(e),isWritable:!0,isSigner:!1}]}(r,n,a,e);return i.concat(vn.accountsArray(e,a.accounts,a.name))};const Ae=An.build(a,we),Be=browser_bn.build(a,Ae,M(e),n),ze=Ce()(a.name);w[ze]=we,k[ze]=Ae,I[ze]=Be})),[w,k,I]})();this.instruction=a,this.transaction=w,this.rpc=k}get programId(){return this._programId}async fetch(){const e=this.address(),r=await this.provider.connection.getAccountInfo(e);if(null===r)throw new Error(`Account does not exist ${e.toString()}`);const n=this._idl.state;if(!n)throw new Error("State is not specified in IDL.");if((await jt(n.struct.name)).compare(r.data.slice(0,8)))throw new Error("Invalid account discriminator");return this.coder.state.decode(r.data)}address(){return this._address}subscribe(e){if(null!==this._sub)return this._sub.ee;const r=new(Ri()),n=this.provider.connection.onAccountChange(this.address(),(e=>{const n=this.coder.state.decode(e.data);r.emit("change",n)}),e);return this._sub={ee:r,listener:n},r}unsubscribe(){null!==this._sub&&this.provider.connection.removeAccountChangeListener(this._sub.listener).then((async()=>{this._sub=null})).catch(console.error)}}function Sn(e){let[r]=nn([],e);return tn(r,"unversioned",e)}class En{constructor(e,r,n,i,s){this._idlAccount=r,this._programId=n,this._provider=null!=i?i:lt(),this._coder=null!=s?s:new Kt(e),this._size=this._coder.accounts.size(r)}get size(){return this._size}get programId(){return this._programId}get provider(){return this._provider}get coder(){return this._coder}async fetchNullable(e,r){const n=await this.getAccountInfo(e,r);return null===n?null:this._coder.accounts.decode(this._idlAccount.name,n.data)}async fetch(e,r){const n=await this.fetchNullable(e,r);if(null===n)throw new Error(`Account does not exist ${e.toString()}`);return n}async fetchMultiple(e,r){return(await X(this._provider.connection,e.map((e=>L(e))),r)).map((e=>null==e?null:this._coder.accounts.decode(this._idlAccount.name,null==e?void 0:e.account.data)))}async all(e){return(await this._provider.connection.getProgramAccounts(this._programId,{commitment:this._provider.connection.commitment,filters:[{memcmp:this.coder.accounts.memcmp(this._idlAccount.name,e instanceof Oi?e:void 0)},...Array.isArray(e)?e:[]]})).map((({pubkey:e,account:r})=>({publicKey:e,account:this._coder.accounts.decode(this._idlAccount.name,r.data)})))}subscribe(e,r){const n=po.get(e.toString());if(n)return n.ee;const i=new(Ri());e=L(e);const s=this._provider.connection.onAccountChange(e,(e=>{const r=this._coder.accounts.decode(this._idlAccount.name,e.data);i.emit("change",r)}),r);return po.set(e.toString(),{ee:i,listener:s}),i}async unsubscribe(e){let r=po.get(e.toString());r?po&&await this._provider.connection.removeAccountChangeListener(r.listener).then((()=>{po.delete(e.toString())})).catch(console.error):console.warn("Address is not subscribed")}async createInstruction(e,r){const n=this.size;if(void 0===this._provider.wallet)throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");return s.SystemProgram.createAccount({fromPubkey:this._provider.wallet.publicKey,newAccountPubkey:e.publicKey,space:null!=r?r:n,lamports:await this._provider.connection.getMinimumBalanceForRentExemption(null!=r?r:n),programId:this._programId})}async associated(...e){const r=await this.associatedAddress(...e);return await this.fetch(r)}async associatedAddress(...e){return await on(this._programId,...e)}async getAccountInfo(e,r){return await this._provider.connection.getAccountInfo(L(e),r)}}const po=new Map;class xn{constructor(e,r,n){this._programId=e,this._provider=r,this._eventParser=new Pn(e,n),this._eventCallbacks=new Map,this._eventListeners=new Map,this._listenerIdCount=0}addEventListener(e,r){var n;let i=this._listenerIdCount;return this._listenerIdCount+=1,e in this._eventCallbacks||this._eventListeners.set(e,[]),this._eventListeners.set(e,(null!==(n=this._eventListeners.get(e))&&void 0!==n?n:[]).concat(i)),this._eventCallbacks.set(i,[e,r]),void 0!==this._onLogsSubscriptionId||(this._onLogsSubscriptionId=this._provider.connection.onLogs(this._programId,((e,r)=>{if(!e.err)for(const n of this._eventParser.parseLogs(e.logs)){const i=this._eventListeners.get(n.name);i&&i.forEach((i=>{const s=this._eventCallbacks.get(i);if(s){const[,i]=s;i(n.data,r.slot,e.signature)}}))}}))),i}async removeEventListener(e){const r=this._eventCallbacks.get(e);if(!r)throw new Error(`Event listener ${e} doesn't exist!`);const[n]=r;let i=this._eventListeners.get(n);if(!i)throw new Error(`Event listeners don't exist for ${n}!`);this._eventCallbacks.delete(e),i=i.filter((r=>r!==e)),0===i.length&&this._eventListeners.delete(n),0==this._eventCallbacks.size&&(vi.ok(0===this._eventListeners.size),void 0!==this._onLogsSubscriptionId&&(await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId),this._onLogsSubscriptionId=void 0))}}class Pn{constructor(e,r){this.coder=r,this.programId=e}*parseLogs(e){const r=new Tn(e),n=new Ln;let i=r.next();for(;null!==i;){let[e,s,a]=this.handleLog(n,i);e&&(yield e),s&&n.push(s),a&&n.pop(),i=r.next()}}handleLog(e,r){return e.stack.length>0&&e.program()===this.programId.toString()?this.handleProgramLog(r):[null,...this.handleSystemLog(r)]}handleProgramLog(e){if(e.startsWith("Program log: ")||e.startsWith("Program data: ")){const r=e.startsWith("Program log: ")?e.slice(13):e.slice(14);return[this.coder.events.decode(r),null,!1]}return[null,...this.handleSystemLog(e)]}handleSystemLog(e){const r=e.split(":")[0];return null!==r.match(/^Program (.*) success/g)?[null,!0]:r.startsWith(`Program ${this.programId.toString()} invoke`)?[this.programId.toString(),!1]:r.includes("invoke")?["cpi",!1]:[null,!1]}}class Ln{constructor(){this.stack=[]}program(){return vi.ok(this.stack.length>0),this.stack[this.stack.length-1]}push(e){this.stack.push(e)}pop(){vi.ok(this.stack.length>0),this.stack.pop()}}class Tn{constructor(e){this.logs=e}next(){if(0===this.logs.length)return null;let e=this.logs[0];return this.logs=this.logs.slice(1),e}}const mo=new s.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");function zn(){return new Ne(yo)}const yo={version:"0.1.0",name:"spl_token",instructions:[{name:"initializeMint",accounts:[{name:"mint",isMut:!0,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"decimals",type:"u8"},{name:"mintAuthority",type:"publicKey"},{name:"freezeAuthority",type:{coption:"publicKey"}}]},{name:"initializeAccount",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"initializeMultisig",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"m",type:"u8"}]},{name:"transfer",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"}]},{name:"approve",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"delegate",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"}]},{name:"revoke",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[]},{name:"setAuthority",accounts:[{name:"mint",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"authorityType",type:"u8"},{name:"newAuthority",type:{coption:"publicKey"}}]},{name:"mintTo",accounts:[{name:"mint",isMut:!0,isSigner:!1},{name:"to",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"}]},{name:"burn",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"mint",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"}]},{name:"closeAccount",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1}],args:[]},{name:"freezeAccount",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[]},{name:"thawAccount",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[]},{name:"transferChecked",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"},{name:"decimals",type:"u8"}]},{name:"approveChecked",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"delegate",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"},{name:"decimals",type:"u8"}]},{name:"mintToChecked",accounts:[{name:"mint",isMut:!0,isSigner:!1},{name:"to",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"},{name:"decimals",type:"u8"}]},{name:"burnChecked",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"mint",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"},{name:"decimals",type:"u8"}]},{name:"initializeAccount2",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"authority",type:"publicKey"}]},{name:"syncNative",accounts:[{name:"account",isMut:!0,isSigner:!1}],args:[]},{name:"initializeAccount3",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1}],args:[{name:"authority",type:"publicKey"}]},{name:"initializeMultisig2",accounts:[{name:"account",isMut:!0,isSigner:!1}],args:[{name:"m",type:"u8"}]},{name:"initializeMint2",accounts:[{name:"mint",isMut:!0,isSigner:!1}],args:[{name:"decimals",type:"u8"},{name:"mintAuthority",type:"publicKey"},{name:"freezeAuthority",type:{coption:"publicKey"}}]}],accounts:[{name:"mint",type:{kind:"struct",fields:[{name:"mintAuthority",type:{coption:"publicKey"}},{name:"supply",type:"u64"},{name:"decimals",type:"u8"},{name:"isInitialized",type:"bool"},{name:"freezeAuthority",type:{coption:"publicKey"}}]}},{name:"token",type:{kind:"struct",fields:[{name:"mint",type:"publicKey"},{name:"authority",type:"publicKey"},{name:"amount",type:"u64"},{name:"delegate",type:{coption:"publicKey"}},{name:"state",type:"u8"},{name:"isNative",type:{coption:"u64"}},{name:"delegatedAmount",type:"u64"},{name:"closeAuthority",type:{coption:"publicKey"}}]}}]};class On{constructor(e,r,n,i,s,a){this._args=e,this._accounts=r,this._provider=n,this._programId=i,this._idlIx=s,this._accountStore=new Dn(n,a)}async resolve(){for(let e=0;e<this._idlIx.accounts.length;e+=1){const r=this._idlIx.accounts[e],n=Ce()(r.name);if(!r.isSigner||this._accounts[n])Reflect.has(On.CONST_ACCOUNTS,n)&&!this._accounts[n]&&(this._accounts[n]=On.CONST_ACCOUNTS[n]);else{if(void 0===this._provider.wallet)throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");this._accounts[n]=this._provider.wallet.publicKey}}for(let e=0;e<this._idlIx.accounts.length;e+=1){const r=this._idlIx.accounts[e],n=Ce()(r.name);r.pda&&r.pda.seeds.length>0&&!this._accounts[n]&&await this.autoPopulatePda(r)}}async autoPopulatePda(e){if(!e.pda||!e.pda.seeds)throw new Error("Must have seeds");const r=await Promise.all(e.pda.seeds.map((e=>this.toBuffer(e)))),n=await this.parseProgramId(e),[i]=await s.PublicKey.findProgramAddress(r,n);this._accounts[Ce()(e.name)]=i}async parseProgramId(e){var r;if(!(null===(r=e.pda)||void 0===r?void 0:r.programId))return this._programId;switch(e.pda.programId.kind){case"const":return new s.PublicKey(this.toBufferConst(e.pda.programId.value));case"arg":return this.argValue(e.pda.programId);case"account":return await this.accountValue(e.pda.programId);default:throw new Error(`Unexpected program seed kind: ${e.pda.programId.kind}`)}}async toBuffer(e){switch(e.kind){case"const":return this.toBufferConst(e);case"arg":return await this.toBufferArg(e);case"account":return await this.toBufferAccount(e);default:throw new Error(`Unexpected seed kind: ${e.kind}`)}}toBufferConst(e){return this.toBufferValue(e.type,e.value)}async toBufferArg(e){const r=this.argValue(e);return this.toBufferValue(e.type,r)}argValue(e){const r=Ce()(e.path.split(".")[0]),n=this._idlIx.args.findIndex((e=>e.name===r));if(-1===n)throw new Error(`Unable to find argument for seed: ${r}`);return this._args[n]}async toBufferAccount(e){const r=await this.accountValue(e);return this.toBufferValue(e.type,r)}async accountValue(e){const r=e.path.split("."),n=r[0],i=this._accounts[Ce()(n)];if(1===r.length)return i;const s=await this._accountStore.fetchAccount(e.account,i);return this.parseAccountValue(s,r.slice(1))}parseAccountValue(e,r){let n;for(;r.length>0;)n=e[Ce()(r[0])],r=r.slice(1);return n}toBufferValue(e,r){switch(e){case"u8":return Oi.from([r]);case"u16":let n=Oi.alloc(2);return n.writeUInt16LE(r),n;case"u32":let i=Oi.alloc(4);return i.writeUInt32LE(r),i;case"u64":let s=Oi.alloc(8);return s.writeBigUInt64LE(BigInt(r)),s;case"string":return Oi.from(b(r));case"publicKey":return r.toBuffer();default:if(e.array)return Oi.from(r);throw new Error(`Unexpected seed type: ${e}`)}}}On.CONST_ACCOUNTS={associatedTokenProgram:so,rent:s.SYSVAR_RENT_PUBKEY,systemProgram:s.SystemProgram.programId,tokenProgram:oo};class Dn{constructor(e,r){this._provider=e,this._accounts=r,this._cache=new Map}async fetchAccount(e,r){const n=r.toString();if(!this._cache.has(n))if("TokenAccount"===e){const e=await this._provider.connection.getAccountInfo(r);if(null===e)throw new Error(`invalid account info for ${n}`);const i=zn().accounts.decode("token",e.data);this._cache.set(n,i)}else{const i=this._accounts[Ce()(e)].fetch(r);this._cache.set(n,i)}return this._cache.get(n)}}class Nn{static build(e,r,n,i,s,a,w,k,I){return(...we)=>new Rn(we,i,s,a,w,k,e,r,n,I)}}class Rn{constructor(e,r,n,i,s,a,w,k,I,we){this._args=e,this._ixFn=r,this._txFn=n,this._rpcFn=i,this._simulateFn=s,this._viewFn=a,this._accounts={},this._remainingAccounts=[],this._signers=[],this._preInstructions=[],this._postInstructions=[],this._autoResolveAccounts=!0,this._accountsResolver=new On(e,this._accounts,w,k,I,we)}async pubkeys(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._accounts}accounts(e){return this._autoResolveAccounts=!0,Object.assign(this._accounts,e),this}accountsStrict(e){return this._autoResolveAccounts=!1,Object.assign(this._accounts,e),this}signers(e){return this._signers=this._signers.concat(e),this}remainingAccounts(e){return this._remainingAccounts=this._remainingAccounts.concat(e),this}preInstructions(e){return this._preInstructions=this._preInstructions.concat(e),this}postInstructions(e){return this._postInstructions=this._postInstructions.concat(e),this}async rpc(e){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._rpcFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:e})}async view(e){if(this._autoResolveAccounts&&await this._accountsResolver.resolve(),!this._viewFn)throw new Error("Method does not support views");return this._viewFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:e})}async simulate(e){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._simulateFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:e})}async instruction(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._ixFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}async transaction(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._txFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}}class Vn{constructor(e,r,n,i){r=L(r),n||(n=lt()),this._idl=e,this._provider=n,this._programId=r,this._coder=null!=i?i:new Kt(e),this._events=new xn(this._programId,n,this._coder);const[s,a,w,k,I,we,Ae,Be]=class{static build(e,r,n,i){const s={},a={},w={},k={},I={},we={},Ae=M(e),Be=e.accounts?class{static build(e,r,n,i){var s;const a={};return null===(s=e.accounts)||void 0===s||s.forEach((s=>{const w=Ce()(s.name);a[w]=new En(e,s,n,i,r)})),a}}.build(e,r,n,i):{},ze=class{static build(e,r,n,i){if(void 0!==e.state)return new _n(e,n,i,r)}}.build(e,r,n,i);return e.instructions.forEach((ze=>{const qe=vn.build(ze,((e,n)=>r.instruction.encode(e,n)),n),$e=An.build(ze,qe),Ye=browser_bn.build(ze,$e,Ae,i),Je=class{static build(e,r,n,i,s,a,w){return async(...k)=>{var I;const we=r(...k),[,Ae]=wn(e,[...k]);let Ce;if(void 0===i.simulate)throw new Error("This function requires 'Provider.simulate' to be implemented.");try{Ce=await i.simulate(we,Ae.signers,null===(I=Ae.options)||void 0===I?void 0:I.commitment)}catch(e){throw At(e,n)}if(void 0===Ce)throw new Error("Unable to simulate transaction");const Be=Ce.logs;if(!Be)throw new Error("Simulated logs not found");const ze=[];if(w.events){let e=new Pn(a,s);for(const r of e.parseLogs(Be))ze.push(r)}return{events:ze,raw:Be}}}}.build(ze,$e,Ae,i,r,n,e),et=class{static build(e,r,n,i){const s=r.accounts.find((e=>e.isMut)),a=!!r.returns;if(!s&&a)return async(...s)=>{var a,w;let k=await n(...s);const I=`Program return: ${e} `;let we=k.raw.find((e=>e.startsWith(I)));if(!we)throw new Error("View expected return log");let Ae=E(we.slice(I.length)),Ce=r.returns;if(!Ce)throw new Error("View expected return type");return Lt.fieldLayout({type:Ce},Array.from([...null!==(a=i.accounts)&&void 0!==a?a:[],...null!==(w=i.types)&&void 0!==w?w:[]])).decode(Ae)}}}.build(n,ze,Je,e),rt=Nn.build(i,n,ze,qe,$e,Ye,Je,et,Be),it=Ce()(ze.name);a[it]=qe,w[it]=$e,s[it]=Ye,k[it]=Je,I[it]=rt,et&&(we[it]=et)})),[s,a,w,Be,k,I,ze,we]}}.build(e,this._coder,r,n);this.rpc=s,this.instruction=a,this.transaction=w,this.account=k,this.simulate=I,this.methods=we,this.state=Ae,this.views=Be}get programId(){return this._programId}get idl(){return this._idl}get coder(){return this._coder}get provider(){return this._provider}static async at(e,r){const n=L(e),i=await Vn.fetchIdl(n,r);if(!i)throw new Error(`IDL not found for program: ${e.toString()}`);return new Vn(i,n,r)}static async fetchIdl(e,r){r=null!=r?r:lt();const n=L(e),i=await async function(e){const r=(await s.PublicKey.findProgramAddress([],e))[0];return await s.PublicKey.createWithSeed(r,"anchor:idl",e)}(n),a=await r.connection.getAccountInfo(i);if(!a)return null;let w=(k=a.data.slice(8),go.decode(k));var k;const I=Ai(w.data);return JSON.parse(v(I))}addEventListener(e,r){return this._events.addEventListener(e,r)}async removeEventListener(e){return await this._events.removeEventListener(e)}}class Un{constructor(e){}encode(e,r){if("create"===Ce()(e))return Oi.alloc(0);throw new Error(`Invalid instruction: ${e}`)}encodeState(e,r){throw new Error("SPL associated token does not have state")}}class jn{constructor(e){}encode(e,r){throw new Error("SPL associated token does not have state")}decode(e){throw new Error("SPL associated token does not have state")}}class $n{constructor(e){this.idl=e}async encode(e,r){throw new Error(`Invalid account name: ${e}`)}decode(e,r){return this.decodeUnchecked(e,r)}decodeUnchecked(e,r){throw new Error(`Invalid account name: ${e}`)}memcmp(e,r){throw new Error(`Invalid account name: ${e}`)}size(e){var r;return null!==(r=Bt(this.idl,e))&&void 0!==r?r:0}}class Kn{constructor(e){}decode(e){throw new Error("SPL associated token program does not have events")}}class qn{constructor(e){}encode(e,r){throw new Error("SPL associated token does not have user-defined types")}decode(e,r){throw new Error("SPL associated token does not have user-defined types")}}class Fn{constructor(e){this.instruction=new Un(e),this.accounts=new $n(e),this.events=new Kn(e),this.state=new jn(e),this.types=new qn(e)}}const bo=new s.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");const _o={version:"0.1.0",name:"spl_associated_token",instructions:[{name:"create",accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"associatedAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]}]};class Jn{static token(e){return function(e){return new Vn(yo,mo,e,zn())}(e)}static associatedToken(e){return function Gn(e){return new Vn(_o,bo,e,new Fn(_o))}(e)}}const wo=new s.PublicKey("11111111111111111111111111111111");const So={version:"0.1.0",name:"system_program",instructions:[{name:"createAccount",accounts:[{name:"from",isMut:!0,isSigner:!0},{name:"to",isMut:!0,isSigner:!0}],args:[{name:"lamports",type:"u64"},{name:"space",type:"u64"},{name:"owner",type:"publicKey"}]},{name:"assign",accounts:[{name:"pubkey",isMut:!0,isSigner:!0}],args:[{name:"owner",type:"publicKey"}]},{name:"transfer",accounts:[{name:"from",isMut:!0,isSigner:!0},{name:"to",isMut:!0,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"createAccountWithSeed",accounts:[{name:"from",isMut:!0,isSigner:!0},{name:"to",isMut:!0,isSigner:!1},{name:"base",isMut:!1,isSigner:!0}],args:[{name:"base",type:"publicKey"},{name:"seed",type:"string"},{name:"lamports",type:"u64"},{name:"space",type:"u64"},{name:"owner",type:"publicKey"}]},{name:"advanceNonceAccount",accounts:[{name:"nonce",isMut:!0,isSigner:!1},{name:"recentBlockhashes",isMut:!1,isSigner:!1},{name:"authorized",isMut:!1,isSigner:!0}],args:[{name:"authorized",type:"publicKey"}]},{name:"withdrawNonceAccount",accounts:[{name:"nonce",isMut:!0,isSigner:!1},{name:"to",isMut:!0,isSigner:!1},{name:"recentBlockhashes",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"authorized",isMut:!1,isSigner:!0}],args:[{name:"lamports",type:"u64"}]},{name:"initializeNonceAccount",accounts:[{name:"nonce",isMut:!0,isSigner:!0},{name:"recentBlockhashes",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"authorized",type:"publicKey"}]},{name:"authorizeNonceAccount",accounts:[{name:"nonce",isMut:!0,isSigner:!1},{name:"authorized",isMut:!1,isSigner:!0}],args:[{name:"authorized",type:"publicKey"}]},{name:"allocate",accounts:[{name:"pubkey",isMut:!0,isSigner:!0}],args:[{name:"space",type:"u64"}]},{name:"allocateWithSeed",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"base",isMut:!1,isSigner:!0}],args:[{name:"base",type:"publicKey"},{name:"seed",type:"string"},{name:"space",type:"u64"},{name:"owner",type:"publicKey"}]},{name:"assignWithSeed",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"base",isMut:!1,isSigner:!0}],args:[{name:"base",type:"publicKey"},{name:"seed",type:"string"},{name:"owner",type:"publicKey"}]},{name:"transferWithSeed",accounts:[{name:"from",isMut:!0,isSigner:!1},{name:"base",isMut:!1,isSigner:!0},{name:"to",isMut:!0,isSigner:!1}],args:[{name:"lamports",type:"u64"},{name:"seed",type:"string"},{name:"owner",type:"publicKey"}]}],accounts:[{name:"nonce",type:{kind:"struct",fields:[{name:"version",type:"u32"},{name:"state",type:"u32"},{name:"authorizedPubkey",type:"publicKey"},{name:"nonce",type:"publicKey"},{name:"feeCalculator",type:{defined:"FeeCalculator"}}]}}],types:[{name:"FeeCalculator",type:{kind:"struct",fields:[{name:"lamportsPerSignature",type:"u64"}]}}]};class Yn{static system(e){return function Xn(e){return new Vn(So,wo,e,new Qe(So))}(e)}}},208674:function(e,r,n){var i=n(901048).Buffer,s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0}),r.map=r.array=r.rustEnum=r.str=r.vecU8=r.tagged=r.vec=r.bool=r.option=r.publicKey=r.i128=r.u128=r.i64=r.u64=r.struct=r.f64=r.f32=r.i32=r.u32=r.i16=r.u16=r.i8=r.u8=void 0;const a=n(553511),w=n(384431),k=s(n(682823));var I=n(553511);Object.defineProperty(r,"u8",{enumerable:!0,get:function(){return I.u8}}),Object.defineProperty(r,"i8",{enumerable:!0,get:function(){return I.s8}}),Object.defineProperty(r,"u16",{enumerable:!0,get:function(){return I.u16}}),Object.defineProperty(r,"i16",{enumerable:!0,get:function(){return I.s16}}),Object.defineProperty(r,"u32",{enumerable:!0,get:function(){return I.u32}}),Object.defineProperty(r,"i32",{enumerable:!0,get:function(){return I.s32}}),Object.defineProperty(r,"f32",{enumerable:!0,get:function(){return I.f32}}),Object.defineProperty(r,"f64",{enumerable:!0,get:function(){return I.f64}}),Object.defineProperty(r,"struct",{enumerable:!0,get:function(){return I.struct}});class BNLayout extends a.Layout{constructor(e,r,n){super(e,n),this.blob=a.blob(e),this.signed=r}decode(e,r=0){const n=new k.default(this.blob.decode(e,r),10,"le");return this.signed?n.fromTwos(8*this.span).clone():n}encode(e,r,n=0){return this.signed&&(e=e.toTwos(8*this.span)),this.blob.encode(e.toArrayLike(i,"le",this.span),r,n)}}function u64(e){return new BNLayout(8,!1,e)}r.u64=u64,r.i64=function i64(e){return new BNLayout(8,!0,e)},r.u128=function u128(e){return new BNLayout(16,!1,e)},r.i128=function i128(e){return new BNLayout(16,!0,e)};class WrappedLayout extends a.Layout{constructor(e,r,n,i){super(e.span,i),this.layout=e,this.decoder=r,this.encoder=n}decode(e,r){return this.decoder(this.layout.decode(e,r))}encode(e,r,n){return this.layout.encode(this.encoder(e),r,n)}getSpan(e,r){return this.layout.getSpan(e,r)}}r.publicKey=function publicKey(e){return new WrappedLayout(a.blob(32),(e=>new w.PublicKey(e)),(e=>e.toBuffer()),e)};class OptionLayout extends a.Layout{constructor(e,r){super(-1,r),this.layout=e,this.discriminator=a.u8()}encode(e,r,n=0){return null==e?this.discriminator.encode(0,r,n):(this.discriminator.encode(1,r,n),this.layout.encode(e,r,n+1)+1)}decode(e,r=0){const n=this.discriminator.decode(e,r);if(0===n)return null;if(1===n)return this.layout.decode(e,r+1);throw new Error("Invalid option "+this.property)}getSpan(e,r=0){const n=this.discriminator.decode(e,r);if(0===n)return 1;if(1===n)return this.layout.getSpan(e,r+1)+1;throw new Error("Invalid option "+this.property)}}function decodeBool(e){if(0===e)return!1;if(1===e)return!0;throw new Error("Invalid bool: "+e)}function encodeBool(e){return e?1:0}function vecU8(e){const r=a.u32("length"),n=a.struct([r,a.blob(a.offset(r,-r.span),"data")]);return new WrappedLayout(n,(({data:e})=>e),(e=>({data:e})),e)}r.option=function option(e,r){return new OptionLayout(e,r)},r.bool=function bool(e){return new WrappedLayout(a.u8(),decodeBool,encodeBool,e)},r.vec=function vec(e,r){const n=a.u32("length"),i=a.struct([n,a.seq(e,a.offset(n,-n.span),"values")]);return new WrappedLayout(i,(({values:e})=>e),(e=>({values:e})),r)},r.tagged=function tagged(e,r,n){const i=a.struct([u64("tag"),r.replicate("data")]);return new WrappedLayout(i,(function decodeTag({tag:r,data:n}){if(!r.eq(e))throw new Error("Invalid tag, expected: "+e.toString("hex")+", got: "+r.toString("hex"));return n}),(r=>({tag:e,data:r})),n)},r.vecU8=vecU8,r.str=function str(e){return new WrappedLayout(vecU8(),(e=>e.toString("utf-8")),(e=>i.from(e,"utf-8")),e)},r.rustEnum=function rustEnum(e,r,n){const i=a.union(null!=n?n:a.u8(),r);return e.forEach(((e,r)=>i.addVariant(r,e,e.property))),i},r.array=function array(e,r,n){const i=a.struct([a.seq(e,r,"values")]);return new WrappedLayout(i,(({values:e})=>e),(e=>({values:e})),n)};class MapEntryLayout extends a.Layout{constructor(e,r,n){super(e.span+r.span,n),this.keyLayout=e,this.valueLayout=r}decode(e,r){r=r||0;return[this.keyLayout.decode(e,r),this.valueLayout.decode(e,r+this.keyLayout.getSpan(e,r))]}encode(e,r,n){n=n||0;const i=this.keyLayout.encode(e[0],r,n);return i+this.valueLayout.encode(e[1],r,n+i)}getSpan(e,r){return this.keyLayout.getSpan(e,r)+this.valueLayout.getSpan(e,r)}}r.map=function map(e,r,n){const i=a.u32("length"),s=a.struct([i,a.seq(new MapEntryLayout(e,r),a.offset(i,-i.span),"values")]);return new WrappedLayout(s,(({values:e})=>new Map(e)),(e=>({values:Array.from(e.entries())})),n)}},384431:(e,r,n)=>{n.r(r),n.d(r,{Account:()=>Account,AddressLookupTableAccount:()=>AddressLookupTableAccount,AddressLookupTableInstruction:()=>AddressLookupTableInstruction,AddressLookupTableProgram:()=>AddressLookupTableProgram,Authorized:()=>Authorized,BLOCKHASH_CACHE_TIMEOUT_MS:()=>Ei,BPF_LOADER_DEPRECATED_PROGRAM_ID:()=>pn,BPF_LOADER_PROGRAM_ID:()=>li,BpfLoader:()=>BpfLoader,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS:()=>ns,ComputeBudgetInstruction:()=>ComputeBudgetInstruction,ComputeBudgetProgram:()=>ComputeBudgetProgram,Connection:()=>Connection,Ed25519Program:()=>Ed25519Program,Enum:()=>Enum,EpochSchedule:()=>EpochSchedule,FeeCalculatorLayout:()=>ii,Keypair:()=>Keypair,LAMPORTS_PER_SOL:()=>_s,LOOKUP_TABLE_INSTRUCTION_LAYOUTS:()=>rs,Loader:()=>Loader,Lockup:()=>Lockup,MAX_SEED_LENGTH:()=>dn,Message:()=>Message,MessageAccountKeys:()=>MessageAccountKeys,MessageV0:()=>MessageV0,NONCE_ACCOUNT_LENGTH:()=>si,NonceAccount:()=>NonceAccount,PACKET_DATA_SIZE:()=>mn,PUBLIC_KEY_LENGTH:()=>ln,PublicKey:()=>PublicKey,SIGNATURE_LENGTH_IN_BYTES:()=>bn,SOLANA_SCHEMA:()=>cn,STAKE_CONFIG_ID:()=>us,STAKE_INSTRUCTION_LAYOUTS:()=>ds,SYSTEM_INSTRUCTION_LAYOUTS:()=>ui,SYSVAR_CLOCK_PUBKEY:()=>Mn,SYSVAR_EPOCH_SCHEDULE_PUBKEY:()=>Wn,SYSVAR_INSTRUCTIONS_PUBKEY:()=>Hn,SYSVAR_RECENT_BLOCKHASHES_PUBKEY:()=>Zn,SYSVAR_RENT_PUBKEY:()=>Qn,SYSVAR_REWARDS_PUBKEY:()=>ei,SYSVAR_SLOT_HASHES_PUBKEY:()=>ti,SYSVAR_SLOT_HISTORY_PUBKEY:()=>ri,SYSVAR_STAKE_HISTORY_PUBKEY:()=>ni,Secp256k1Program:()=>Secp256k1Program,SendTransactionError:()=>SendTransactionError,SolanaJSONRPCError:()=>SolanaJSONRPCError,SolanaJSONRPCErrorCode:()=>pi,StakeAuthorizationLayout:()=>ls,StakeInstruction:()=>StakeInstruction,StakeProgram:()=>StakeProgram,Struct:()=>index_browser_esm_Struct,SystemInstruction:()=>SystemInstruction,SystemProgram:()=>SystemProgram,Transaction:()=>Transaction,TransactionExpiredBlockheightExceededError:()=>TransactionExpiredBlockheightExceededError,TransactionExpiredNonceInvalidError:()=>TransactionExpiredNonceInvalidError,TransactionExpiredTimeoutError:()=>TransactionExpiredTimeoutError,TransactionInstruction:()=>TransactionInstruction,TransactionMessage:()=>TransactionMessage,TransactionStatus:()=>Cn,VALIDATOR_INFO_KEY:()=>gs,VERSION_PREFIX_MASK:()=>yn,VOTE_PROGRAM_ID:()=>ms,ValidatorInfo:()=>ValidatorInfo,VersionedMessage:()=>In,VersionedTransaction:()=>VersionedTransaction,VoteAccount:()=>VoteAccount,VoteAuthorizationLayout:()=>fs,VoteInit:()=>VoteInit,VoteInstruction:()=>VoteInstruction,VoteProgram:()=>VoteProgram,clusterApiUrl:()=>clusterApiUrl,sendAndConfirmRawTransaction:()=>sendAndConfirmRawTransaction,sendAndConfirmTransaction:()=>sendAndConfirmTransaction});var i={};n.r(i),n.d(i,{DO:()=>utils_abytes,OG:()=>bitMask,My:()=>abstract_utils_bytesToHex,bytesToNumberBE:()=>utils_bytesToNumberBE,lX:()=>utils_bytesToNumberLE,Id:()=>abstract_utils_concatBytes,fg:()=>createHmacDrbg,qj:()=>utils_ensureBytes,hexToBytes:()=>utils_hexToBytes,aY:()=>abstract_utils_isBytes,lq:()=>utils_numberToBytesBE,z:()=>utils_numberToBytesLE,Q5:()=>validateObject});var s=n(901048);function number(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function bytes(e,...r){if(!function isBytes(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}(e))throw new Error("Uint8Array expected");if(r.length>0&&!r.includes(e.length))throw new Error(`Uint8Array expected of length ${r}, not of length=${e.length}`)}function _assert_hash(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");number(e.outputLen),number(e.blockLen)}function exists(e,r=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(r&&e.finished)throw new Error("Hash#digest() has already been called")}function output(e,r){bytes(e);const n=r.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const a="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;const createView=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),rotr=(e,r)=>e<<32-r|e>>>r,w=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],byteSwap=e=>e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255;function byteSwap32(e){for(let r=0;r<e.length;r++)e[r]=byteSwap(e[r])}function utils_utf8ToBytes(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}function toBytes(e){return"string"==typeof e&&(e=utils_utf8ToBytes(e)),bytes(e),e}function utils_concatBytes(...e){let r=0;for(let n=0;n<e.length;n++){const i=e[n];bytes(i),r+=i.length}const n=new Uint8Array(r);for(let r=0,i=0;r<e.length;r++){const s=e[r];n.set(s,i),i+=s.length}return n}class Hash{clone(){return this._cloneInto()}}function utils_wrapConstructor(e){const hashC=r=>e().update(toBytes(r)).digest(),r=e();return hashC.outputLen=r.outputLen,hashC.blockLen=r.blockLen,hashC.create=()=>e(),hashC}function utils_randomBytes(e=32){if(a&&"function"==typeof a.getRandomValues)return a.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}const Maj=(e,r,n)=>e&r^e&n^r&n;class HashMD extends Hash{constructor(e,r,n,i){super(),this.blockLen=e,this.outputLen=r,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView(this.buffer)}update(e){exists(this);const{view:r,buffer:n,blockLen:i}=this,s=(e=toBytes(e)).length;for(let a=0;a<s;){const w=Math.min(i-this.pos,s-a);if(w!==i)n.set(e.subarray(a,a+w),this.pos),this.pos+=w,a+=w,this.pos===i&&(this.process(r,0),this.pos=0);else{const r=createView(e);for(;i<=s-a;a+=i)this.process(r,a)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){exists(this),output(e,this),this.finished=!0;const{buffer:r,view:n,blockLen:i,isLE:s}=this;let{pos:a}=this;r[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>i-a&&(this.process(n,0),a=0);for(let e=a;e<i;e++)r[e]=0;!function setBigUint64(e,r,n,i){if("function"==typeof e.setBigUint64)return e.setBigUint64(r,n,i);const s=BigInt(32),a=BigInt(4294967295),w=Number(n>>s&a),k=Number(n&a),I=i?4:0,we=i?0:4;e.setUint32(r+I,w,i),e.setUint32(r+we,k,i)}(n,i-8,BigInt(8*this.length),s),this.process(n,0);const w=createView(e),k=this.outputLen;if(k%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const I=k/4,we=this.get();if(I>we.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<I;e++)w.setUint32(4*e,we[e],s)}digest(){const{buffer:e,outputLen:r}=this;this.digestInto(e);const n=e.slice(0,r);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:r,buffer:n,length:i,finished:s,destroyed:a,pos:w}=this;return e.length=i,e.pos=w,e.finished=s,e.destroyed=a,i%r&&e.buffer.set(n),e}}const k=BigInt(2**32-1),I=BigInt(32);function fromBig(e,r=!1){return r?{h:Number(e&k),l:Number(e>>I&k)}:{h:0|Number(e>>I&k),l:0|Number(e&k)}}function split(e,r=!1){let n=new Uint32Array(e.length),i=new Uint32Array(e.length);for(let s=0;s<e.length;s++){const{h:a,l:w}=fromBig(e[s],r);[n[s],i[s]]=[a,w]}return[n,i]}const rotlSH=(e,r,n)=>e<<n|r>>>32-n,rotlSL=(e,r,n)=>r<<n|e>>>32-n,rotlBH=(e,r,n)=>r<<n-32|e>>>64-n,rotlBL=(e,r,n)=>e<<n-32|r>>>64-n;const we={fromBig,split,toBig:(e,r)=>BigInt(e>>>0)<<I|BigInt(r>>>0),shrSH:(e,r,n)=>e>>>n,shrSL:(e,r,n)=>e<<32-n|r>>>n,rotrSH:(e,r,n)=>e>>>n|r<<32-n,rotrSL:(e,r,n)=>e<<32-n|r>>>n,rotrBH:(e,r,n)=>e<<64-n|r>>>n-32,rotrBL:(e,r,n)=>e>>>n-32|r<<64-n,rotr32H:(e,r)=>r,rotr32L:(e,r)=>e,rotlSH,rotlSL,rotlBH,rotlBL,add:function add(e,r,n,i){const s=(r>>>0)+(i>>>0);return{h:e+n+(s/2**32|0)|0,l:0|s}},add3L:(e,r,n)=>(e>>>0)+(r>>>0)+(n>>>0),add3H:(e,r,n,i)=>r+n+i+(e/2**32|0)|0,add4L:(e,r,n,i)=>(e>>>0)+(r>>>0)+(n>>>0)+(i>>>0),add4H:(e,r,n,i,s)=>r+n+i+s+(e/2**32|0)|0,add5H:(e,r,n,i,s,a)=>r+n+i+s+a+(e/2**32|0)|0,add5L:(e,r,n,i,s)=>(e>>>0)+(r>>>0)+(n>>>0)+(i>>>0)+(s>>>0)},[Ae,Ce]=(()=>we.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((e=>BigInt(e)))))(),Be=new Uint32Array(80),ze=new Uint32Array(80);class SHA512 extends HashMD{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:r,Bh:n,Bl:i,Ch:s,Cl:a,Dh:w,Dl:k,Eh:I,El:we,Fh:Ae,Fl:Ce,Gh:Be,Gl:ze,Hh:qe,Hl:$e}=this;return[e,r,n,i,s,a,w,k,I,we,Ae,Ce,Be,ze,qe,$e]}set(e,r,n,i,s,a,w,k,I,we,Ae,Ce,Be,ze,qe,$e){this.Ah=0|e,this.Al=0|r,this.Bh=0|n,this.Bl=0|i,this.Ch=0|s,this.Cl=0|a,this.Dh=0|w,this.Dl=0|k,this.Eh=0|I,this.El=0|we,this.Fh=0|Ae,this.Fl=0|Ce,this.Gh=0|Be,this.Gl=0|ze,this.Hh=0|qe,this.Hl=0|$e}process(e,r){for(let n=0;n<16;n++,r+=4)Be[n]=e.getUint32(r),ze[n]=e.getUint32(r+=4);for(let e=16;e<80;e++){const r=0|Be[e-15],n=0|ze[e-15],i=we.rotrSH(r,n,1)^we.rotrSH(r,n,8)^we.shrSH(r,n,7),s=we.rotrSL(r,n,1)^we.rotrSL(r,n,8)^we.shrSL(r,n,7),a=0|Be[e-2],w=0|ze[e-2],k=we.rotrSH(a,w,19)^we.rotrBH(a,w,61)^we.shrSH(a,w,6),I=we.rotrSL(a,w,19)^we.rotrBL(a,w,61)^we.shrSL(a,w,6),Ae=we.add4L(s,I,ze[e-7],ze[e-16]),Ce=we.add4H(Ae,i,k,Be[e-7],Be[e-16]);Be[e]=0|Ce,ze[e]=0|Ae}let{Ah:n,Al:i,Bh:s,Bl:a,Ch:w,Cl:k,Dh:I,Dl:qe,Eh:$e,El:Ye,Fh:Je,Fl:et,Gh:rt,Gl:it,Hh:ot,Hl:ht}=this;for(let e=0;e<80;e++){const r=we.rotrSH($e,Ye,14)^we.rotrSH($e,Ye,18)^we.rotrBH($e,Ye,41),ft=we.rotrSL($e,Ye,14)^we.rotrSL($e,Ye,18)^we.rotrBL($e,Ye,41),pt=$e&Je^~$e&rt,yt=Ye&et^~Ye&it,_t=we.add5L(ht,ft,yt,Ce[e],ze[e]),St=we.add5H(_t,ot,r,pt,Ae[e],Be[e]),kt=0|_t,Dt=we.rotrSH(n,i,28)^we.rotrBH(n,i,34)^we.rotrBH(n,i,39),Mt=we.rotrSL(n,i,28)^we.rotrBL(n,i,34)^we.rotrBL(n,i,39),qt=n&s^n&w^s&w,Gt=i&a^i&k^a&k;ot=0|rt,ht=0|it,rt=0|Je,it=0|et,Je=0|$e,et=0|Ye,({h:$e,l:Ye}=we.add(0|I,0|qe,0|St,0|kt)),I=0|w,qe=0|k,w=0|s,k=0|a,s=0|n,a=0|i;const Qt=we.add3L(kt,Mt,Gt);n=we.add3H(Qt,St,Dt,qt),i=0|Qt}({h:n,l:i}=we.add(0|this.Ah,0|this.Al,0|n,0|i)),({h:s,l:a}=we.add(0|this.Bh,0|this.Bl,0|s,0|a)),({h:w,l:k}=we.add(0|this.Ch,0|this.Cl,0|w,0|k)),({h:I,l:qe}=we.add(0|this.Dh,0|this.Dl,0|I,0|qe)),({h:$e,l:Ye}=we.add(0|this.Eh,0|this.El,0|$e,0|Ye)),({h:Je,l:et}=we.add(0|this.Fh,0|this.Fl,0|Je,0|et)),({h:rt,l:it}=we.add(0|this.Gh,0|this.Gl,0|rt,0|it)),({h:ot,l:ht}=we.add(0|this.Hh,0|this.Hl,0|ot,0|ht)),this.set(n,i,s,a,w,k,I,qe,$e,Ye,Je,et,rt,it,ot,ht)}roundClean(){Be.fill(0),ze.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const qe=utils_wrapConstructor((()=>new SHA512)),$e=(BigInt(0),BigInt(1)),Ye=BigInt(2);function abstract_utils_isBytes(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}function utils_abytes(e){if(!abstract_utils_isBytes(e))throw new Error("Uint8Array expected")}const Je=Array.from({length:256},((e,r)=>r.toString(16).padStart(2,"0")));function abstract_utils_bytesToHex(e){utils_abytes(e);let r="";for(let n=0;n<e.length;n++)r+=Je[e[n]];return r}function hexToNumber(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}const et={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function utils_asciiToBase16(e){return e>=et._0&&e<=et._9?e-et._0:e>=et._A&&e<=et._F?e-(et._A-10):e>=et._a&&e<=et._f?e-(et._a-10):void 0}function utils_hexToBytes(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const r=e.length,n=r/2;if(r%2)throw new Error("padded hex string expected, got unpadded hex of length "+r);const i=new Uint8Array(n);for(let r=0,s=0;r<n;r++,s+=2){const n=utils_asciiToBase16(e.charCodeAt(s)),a=utils_asciiToBase16(e.charCodeAt(s+1));if(void 0===n||void 0===a){const r=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+r+'" at index '+s)}i[r]=16*n+a}return i}function utils_bytesToNumberBE(e){return hexToNumber(abstract_utils_bytesToHex(e))}function utils_bytesToNumberLE(e){return utils_abytes(e),hexToNumber(abstract_utils_bytesToHex(Uint8Array.from(e).reverse()))}function utils_numberToBytesBE(e,r){return utils_hexToBytes(e.toString(16).padStart(2*r,"0"))}function utils_numberToBytesLE(e,r){return utils_numberToBytesBE(e,r).reverse()}function utils_ensureBytes(e,r,n){let i;if("string"==typeof r)try{i=utils_hexToBytes(r)}catch(n){throw new Error(`${e} must be valid hex string, got "${r}". Cause: ${n}`)}else{if(!abstract_utils_isBytes(r))throw new Error(`${e} must be hex string or Uint8Array`);i=Uint8Array.from(r)}const s=i.length;if("number"==typeof n&&s!==n)throw new Error(`${e} expected ${n} bytes, got ${s}`);return i}function abstract_utils_concatBytes(...e){let r=0;for(let n=0;n<e.length;n++){const i=e[n];utils_abytes(i),r+=i.length}const n=new Uint8Array(r);for(let r=0,i=0;r<e.length;r++){const s=e[r];n.set(s,i),i+=s.length}return n}const bitMask=e=>(Ye<<BigInt(e-1))-$e,u8n=e=>new Uint8Array(e),u8fr=e=>Uint8Array.from(e);function createHmacDrbg(e,r,n){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof r||r<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let i=u8n(e),s=u8n(e),a=0;const reset=()=>{i.fill(1),s.fill(0),a=0},h=(...e)=>n(s,i,...e),reseed=(e=u8n())=>{s=h(u8fr([0]),e),i=h(),0!==e.length&&(s=h(u8fr([1]),e),i=h())},gen=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const n=[];for(;e<r;){i=h();const r=i.slice();n.push(r),e+=i.length}return abstract_utils_concatBytes(...n)};return(e,r)=>{let n;for(reset(),reseed(e);!(n=r(gen()));)reseed();return reset(),n}}const rt={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||abstract_utils_isBytes(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,r)=>r.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function validateObject(e,r,n={}){const checkField=(r,n,i)=>{const s=rt[n];if("function"!=typeof s)throw new Error(`Invalid validator "${n}", expected function`);const a=e[r];if(!(i&&void 0===a||s(a,e)))throw new Error(`Invalid param ${String(r)}=${a} (${typeof a}), expected ${n}`)};for(const[e,n]of Object.entries(r))checkField(e,n,!1);for(const[e,r]of Object.entries(n))checkField(e,r,!0);return e}const it=BigInt(0),ot=BigInt(1),ht=BigInt(2),ft=BigInt(3),pt=BigInt(4),yt=BigInt(5),_t=BigInt(8);BigInt(9),BigInt(16);function modular_mod(e,r){const n=e%r;return n>=it?n:r+n}function pow(e,r,n){if(n<=it||r<it)throw new Error("Expected power/modulo > 0");if(n===ot)return it;let i=ot;for(;r>it;)r&ot&&(i=i*e%n),e=e*e%n,r>>=ot;return i}function modular_pow2(e,r,n){let i=e;for(;r-- >it;)i*=i,i%=n;return i}function invert(e,r){if(e===it||r<=it)throw new Error(`invert: expected positive integers, got n=${e} mod=${r}`);let n=modular_mod(e,r),i=r,s=it,a=ot,w=ot,k=it;for(;n!==it;){const e=i/n,r=i%n,I=s-w*e,we=a-k*e;i=n,n=r,s=w,a=k,w=I,k=we}if(i!==ot)throw new Error("invert: does not exist");return modular_mod(s,r)}function FpSqrt(e){if(e%pt===ft){const r=(e+ot)/pt;return function sqrt3mod4(e,n){const i=e.pow(n,r);if(!e.eql(e.sqr(i),n))throw new Error("Cannot find square root");return i}}if(e%_t===yt){const r=(e-yt)/_t;return function sqrt5mod8(e,n){const i=e.mul(n,ht),s=e.pow(i,r),a=e.mul(n,s),w=e.mul(e.mul(a,ht),s),k=e.mul(a,e.sub(w,e.ONE));if(!e.eql(e.sqr(k),n))throw new Error("Cannot find square root");return k}}return function tonelliShanks(e){const r=(e-ot)/ht;let n,i,s;for(n=e-ot,i=0;n%ht===it;n/=ht,i++);for(s=ht;s<e&&pow(s,r,e)!==e-ot;s++);if(1===i){const r=(e+ot)/pt;return function tonelliFast(e,n){const i=e.pow(n,r);if(!e.eql(e.sqr(i),n))throw new Error("Cannot find square root");return i}}const a=(n+ot)/ht;return function tonelliSlow(e,w){if(e.pow(w,r)===e.neg(e.ONE))throw new Error("Cannot find square root");let k=i,I=e.pow(e.mul(e.ONE,s),n),we=e.pow(w,a),Ae=e.pow(w,n);for(;!e.eql(Ae,e.ONE);){if(e.eql(Ae,e.ZERO))return e.ZERO;let r=1;for(let n=e.sqr(Ae);r<k&&!e.eql(n,e.ONE);r++)n=e.sqr(n);const n=e.pow(I,ot<<BigInt(k-r-1));I=e.sqr(n),we=e.mul(we,n),Ae=e.mul(Ae,I),k=r}return we}}(e)}const modular_isNegativeLE=(e,r)=>(modular_mod(e,r)&ot)===ot,St=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function nLength(e,r){const n=void 0!==r?r:e.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function Field(e,r,n=!1,i={}){if(e<=it)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:s,nByteLength:a}=nLength(e,r);if(a>2048)throw new Error("Field lengths over 2048 bytes are not supported");const w=FpSqrt(e),k=Object.freeze({ORDER:e,BITS:s,BYTES:a,MASK:bitMask(s),ZERO:it,ONE:ot,create:r=>modular_mod(r,e),isValid:r=>{if("bigint"!=typeof r)throw new Error("Invalid field element: expected bigint, got "+typeof r);return it<=r&&r<e},is0:e=>e===it,isOdd:e=>(e&ot)===ot,neg:r=>modular_mod(-r,e),eql:(e,r)=>e===r,sqr:r=>modular_mod(r*r,e),add:(r,n)=>modular_mod(r+n,e),sub:(r,n)=>modular_mod(r-n,e),mul:(r,n)=>modular_mod(r*n,e),pow:(e,r)=>function FpPow(e,r,n){if(n<it)throw new Error("Expected power > 0");if(n===it)return e.ONE;if(n===ot)return r;let i=e.ONE,s=r;for(;n>it;)n&ot&&(i=e.mul(i,s)),s=e.sqr(s),n>>=ot;return i}(k,e,r),div:(r,n)=>modular_mod(r*invert(n,e),e),sqrN:e=>e*e,addN:(e,r)=>e+r,subN:(e,r)=>e-r,mulN:(e,r)=>e*r,inv:r=>invert(r,e),sqrt:i.sqrt||(e=>w(k,e)),invertBatch:e=>function FpInvertBatch(e,r){const n=new Array(r.length),i=r.reduce(((r,i,s)=>e.is0(i)?r:(n[s]=r,e.mul(r,i))),e.ONE),s=e.inv(i);return r.reduceRight(((r,i,s)=>e.is0(i)?r:(n[s]=e.mul(r,n[s]),e.mul(r,i))),s),n}(k,e),cmov:(e,r,n)=>n?r:e,toBytes:e=>n?utils_numberToBytesLE(e,a):utils_numberToBytesBE(e,a),fromBytes:e=>{if(e.length!==a)throw new Error(`Fp.fromBytes: expected ${a}, got ${e.length}`);return n?utils_bytesToNumberLE(e):utils_bytesToNumberBE(e)}});return Object.freeze(k)}function getFieldBytesLength(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const r=e.toString(2).length;return Math.ceil(r/8)}function getMinHashLength(e){const r=getFieldBytesLength(e);return r+Math.ceil(r/2)}const kt=BigInt(0),Dt=BigInt(1);function wNAF(e,r){const constTimeNegate=(e,r)=>{const n=r.negate();return e?n:r},opts=e=>({windows:Math.ceil(r/e)+1,windowSize:2**(e-1)});return{constTimeNegate,unsafeLadder(r,n){let i=e.ZERO,s=r;for(;n>kt;)n&Dt&&(i=i.add(s)),s=s.double(),n>>=Dt;return i},precomputeWindow(e,r){const{windows:n,windowSize:i}=opts(r),s=[];let a=e,w=a;for(let e=0;e<n;e++){w=a,s.push(w);for(let e=1;e<i;e++)w=w.add(a),s.push(w);a=w.double()}return s},wNAF(r,n,i){const{windows:s,windowSize:a}=opts(r);let w=e.ZERO,k=e.BASE;const I=BigInt(2**r-1),we=2**r,Ae=BigInt(r);for(let e=0;e<s;e++){const r=e*a;let s=Number(i&I);i>>=Ae,s>a&&(s-=we,i+=Dt);const Ce=r,Be=r+Math.abs(s)-1,ze=e%2!=0,qe=s<0;0===s?k=k.add(constTimeNegate(ze,n[Ce])):w=w.add(constTimeNegate(qe,n[Be]))}return{p:w,f:k}},wNAFCached(e,r,n,i){const s=e._WINDOW_SIZE||1;let a=r.get(e);return a||(a=this.precomputeWindow(e,s),1!==s&&r.set(e,i(a))),this.wNAF(s,a,n)}}}function validateBasic(e){return function validateField(e){const r=St.reduce(((e,r)=>(e[r]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return validateObject(e,r)}(e.Fp),validateObject(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}const Mt=BigInt(0),qt=BigInt(1),Gt=BigInt(2),Qt=BigInt(8),er={zip215:!0};function twistedEdwards(e){const r=function validateOpts(e){const r=validateBasic(e);return validateObject(e,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...r})}(e),{Fp:n,n:i,prehash:s,hash:a,randomBytes:w,nByteLength:k,h:I}=r,we=Gt<<BigInt(8*k)-qt,Ae=n.create,Ce=r.uvRatio||((e,r)=>{try{return{isValid:!0,value:n.sqrt(e*n.inv(r))}}catch(e){return{isValid:!1,value:Mt}}}),Be=r.adjustScalarBytes||(e=>e),ze=r.domain||((e,r,n)=>{if(r.length||n)throw new Error("Contexts/pre-hash are not supported");return e}),inBig=e=>"bigint"==typeof e&&Mt<e,inRange=(e,r)=>inBig(e)&&inBig(r)&&e<r,in0MaskRange=e=>e===Mt||inRange(e,we);function assertInRange(e,r){if(inRange(e,r))return e;throw new Error(`Expected valid scalar < ${r}, got ${typeof e} ${e}`)}function assertGE0(e){return e===Mt?e:assertInRange(e,i)}const qe=new Map;function isPoint(e){if(!(e instanceof Point))throw new Error("ExtendedPoint expected")}class Point{constructor(e,r,n,i){if(this.ex=e,this.ey=r,this.ez=n,this.et=i,!in0MaskRange(e))throw new Error("x required");if(!in0MaskRange(r))throw new Error("y required");if(!in0MaskRange(n))throw new Error("z required");if(!in0MaskRange(i))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(e){if(e instanceof Point)throw new Error("extended point not allowed");const{x:r,y:n}=e||{};if(!in0MaskRange(r)||!in0MaskRange(n))throw new Error("invalid affine point");return new Point(r,n,qt,Ae(r*n))}static normalizeZ(e){const r=n.invertBatch(e.map((e=>e.ez)));return e.map(((e,n)=>e.toAffine(r[n]))).map(Point.fromAffine)}_setWindowSize(e){this._WINDOW_SIZE=e,qe.delete(this)}assertValidity(){const{a:e,d:n}=r;if(this.is0())throw new Error("bad point: ZERO");const{ex:i,ey:s,ez:a,et:w}=this,k=Ae(i*i),I=Ae(s*s),we=Ae(a*a),Ce=Ae(we*we),Be=Ae(k*e);if(Ae(we*Ae(Be+I))!==Ae(Ce+Ae(n*Ae(k*I))))throw new Error("bad point: equation left != right (1)");if(Ae(i*s)!==Ae(a*w))throw new Error("bad point: equation left != right (2)")}equals(e){isPoint(e);const{ex:r,ey:n,ez:i}=this,{ex:s,ey:a,ez:w}=e,k=Ae(r*w),I=Ae(s*i),we=Ae(n*w),Ce=Ae(a*i);return k===I&&we===Ce}is0(){return this.equals(Point.ZERO)}negate(){return new Point(Ae(-this.ex),this.ey,this.ez,Ae(-this.et))}double(){const{a:e}=r,{ex:n,ey:i,ez:s}=this,a=Ae(n*n),w=Ae(i*i),k=Ae(Gt*Ae(s*s)),I=Ae(e*a),we=n+i,Ce=Ae(Ae(we*we)-a-w),Be=I+w,ze=Be-k,qe=I-w,$e=Ae(Ce*ze),Ye=Ae(Be*qe),Je=Ae(Ce*qe),et=Ae(ze*Be);return new Point($e,Ye,et,Je)}add(e){isPoint(e);const{a:n,d:i}=r,{ex:s,ey:a,ez:w,et:k}=this,{ex:I,ey:we,ez:Ce,et:Be}=e;if(n===BigInt(-1)){const e=Ae((a-s)*(we+I)),r=Ae((a+s)*(we-I)),n=Ae(r-e);if(n===Mt)return this.double();const i=Ae(w*Gt*Be),ze=Ae(k*Gt*Ce),qe=ze+i,$e=r+e,Ye=ze-i,Je=Ae(qe*n),et=Ae($e*Ye),rt=Ae(qe*Ye),it=Ae(n*$e);return new Point(Je,et,it,rt)}const ze=Ae(s*I),qe=Ae(a*we),$e=Ae(k*i*Be),Ye=Ae(w*Ce),Je=Ae((s+a)*(I+we)-ze-qe),et=Ye-$e,rt=Ye+$e,it=Ae(qe-n*ze),ot=Ae(Je*et),ht=Ae(rt*it),ft=Ae(Je*it),pt=Ae(et*rt);return new Point(ot,ht,pt,ft)}subtract(e){return this.add(e.negate())}wNAF(e){return Je.wNAFCached(this,qe,e,Point.normalizeZ)}multiply(e){const{p:r,f:n}=this.wNAF(assertInRange(e,i));return Point.normalizeZ([r,n])[0]}multiplyUnsafe(e){let r=assertGE0(e);return r===Mt?Ye:this.equals(Ye)||r===qt?this:this.equals($e)?this.wNAF(r).p:Je.unsafeLadder(this,r)}isSmallOrder(){return this.multiplyUnsafe(I).is0()}isTorsionFree(){return Je.unsafeLadder(this,i).is0()}toAffine(e){const{ex:r,ey:i,ez:s}=this,a=this.is0();null==e&&(e=a?Qt:n.inv(s));const w=Ae(r*e),k=Ae(i*e),I=Ae(s*e);if(a)return{x:Mt,y:qt};if(I!==qt)throw new Error("invZ was invalid");return{x:w,y:k}}clearCofactor(){const{h:e}=r;return e===qt?this:this.multiplyUnsafe(e)}static fromHex(e,i=!1){const{d:s,a}=r,w=n.BYTES,k=(e=utils_ensureBytes("pointHex",e,w)).slice(),I=e[w-1];k[w-1]=-129&I;const Be=utils_bytesToNumberLE(k);Be===Mt||assertInRange(Be,i?we:n.ORDER);const ze=Ae(Be*Be),qe=Ae(ze-qt),$e=Ae(s*ze-a);let{isValid:Ye,value:Je}=Ce(qe,$e);if(!Ye)throw new Error("Point.fromHex: invalid y coordinate");const et=(Je&qt)===qt,rt=!!(128&I);if(!i&&Je===Mt&&rt)throw new Error("Point.fromHex: x=0 and x_0=1");return rt!==et&&(Je=Ae(-Je)),Point.fromAffine({x:Je,y:Be})}static fromPrivateKey(e){return getExtendedPublicKey(e).point}toRawBytes(){const{x:e,y:r}=this.toAffine(),i=utils_numberToBytesLE(r,n.BYTES);return i[i.length-1]|=e&qt?128:0,i}toHex(){return abstract_utils_bytesToHex(this.toRawBytes())}}Point.BASE=new Point(r.Gx,r.Gy,qt,Ae(r.Gx*r.Gy)),Point.ZERO=new Point(Mt,qt,qt,Mt);const{BASE:$e,ZERO:Ye}=Point,Je=wNAF(Point,8*k);function modN(e){return modular_mod(e,i)}function modN_LE(e){return modN(utils_bytesToNumberLE(e))}function getExtendedPublicKey(e){const r=k;e=utils_ensureBytes("private key",e,r);const n=utils_ensureBytes("hashed private key",a(e),2*r),i=Be(n.slice(0,r)),s=n.slice(r,2*r),w=modN_LE(i),I=$e.multiply(w),we=I.toRawBytes();return{head:i,prefix:s,scalar:w,point:I,pointBytes:we}}function hashDomainToScalar(e=new Uint8Array,...r){const n=abstract_utils_concatBytes(...r);return modN_LE(a(ze(n,utils_ensureBytes("context",e),!!s)))}const et=er;$e._setWindowSize(8);return{CURVE:r,getPublicKey:function getPublicKey(e){return getExtendedPublicKey(e).pointBytes},sign:function sign(e,r,i={}){e=utils_ensureBytes("message",e),s&&(e=s(e));const{prefix:a,scalar:w,pointBytes:I}=getExtendedPublicKey(r),we=hashDomainToScalar(i.context,a,e),Ae=$e.multiply(we).toRawBytes(),Ce=modN(we+hashDomainToScalar(i.context,Ae,I,e)*w);return assertGE0(Ce),utils_ensureBytes("result",abstract_utils_concatBytes(Ae,utils_numberToBytesLE(Ce,n.BYTES)),2*k)},verify:function verify(e,r,i,a=et){const{context:w,zip215:k}=a,I=n.BYTES;e=utils_ensureBytes("signature",e,2*I),r=utils_ensureBytes("message",r),s&&(r=s(r));const we=utils_bytesToNumberLE(e.slice(I,2*I));let Ae,Ce,Be;try{Ae=Point.fromHex(i,k),Ce=Point.fromHex(e.slice(0,I),k),Be=$e.multiplyUnsafe(we)}catch(e){return!1}if(!k&&Ae.isSmallOrder())return!1;const ze=hashDomainToScalar(w,Ce.toRawBytes(),Ae.toRawBytes(),r);return Ce.add(Ae.multiplyUnsafe(ze)).subtract(Be).clearCofactor().equals(Point.ZERO)},ExtendedPoint:Point,utils:{getExtendedPublicKey,randomPrivateKey:()=>w(n.BYTES),precompute:(e=8,r=Point.BASE)=>(r._setWindowSize(e),r.multiply(BigInt(3)),r)}}}const tr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),rr=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),nr=(BigInt(0),BigInt(1)),ir=BigInt(2),or=BigInt(5),sr=BigInt(10),ar=BigInt(20),cr=BigInt(40),ur=BigInt(80);function ed25519_pow_2_252_3(e){const r=tr,n=e*e%r*e%r,i=modular_pow2(n,ir,r)*n%r,s=modular_pow2(i,nr,r)*e%r,a=modular_pow2(s,or,r)*s%r,w=modular_pow2(a,sr,r)*a%r,k=modular_pow2(w,ar,r)*w%r,I=modular_pow2(k,cr,r)*k%r,we=modular_pow2(I,ur,r)*I%r,Ae=modular_pow2(we,ur,r)*I%r,Ce=modular_pow2(Ae,sr,r)*a%r;return{pow_p_5_8:modular_pow2(Ce,ir,r)*e%r,b2:n}}function adjustScalarBytes(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}function uvRatio(e,r){const n=tr,i=modular_mod(r*r*r,n),s=modular_mod(i*i*r,n);let a=modular_mod(e*i*ed25519_pow_2_252_3(e*s).pow_p_5_8,n);const w=modular_mod(r*a*a,n),k=a,I=modular_mod(a*rr,n),we=w===e,Ae=w===modular_mod(-e,n),Ce=w===modular_mod(-e*rr,n);return we&&(a=k),(Ae||Ce)&&(a=I),modular_isNegativeLE(a,n)&&(a=modular_mod(-a,n)),{isValid:we||Ae,value:a}}const dr=Field(tr,void 0,!0),lr={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:dr,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:qe,randomBytes:utils_randomBytes,adjustScalarBytes,uvRatio},hr=twistedEdwards(lr);function ed25519_domain(e,r,n){if(r.length>255)throw new Error("Context is too big");return utils_concatBytes(utils_utf8ToBytes("SigEd25519 no Ed25519 collisions"),new Uint8Array([n?1:0,r.length]),r,e)}const fr=(dr.ORDER+BigInt(3))/BigInt(8);dr.pow(ir,fr),dr.sqrt(dr.neg(dr.ONE)),dr.ORDER,BigInt(5),BigInt(8),BigInt(486662);(function FpSqrtEven(e,r){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const n=e.sqrt(r);return e.isOdd(n)?e.neg(n):n})(dr,dr.neg(BigInt(486664)));BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");var gr=n(682823),pr=n.n(gr),mr=n(939216),yr=n.n(mr);const br=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),_r=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),wr=new Uint32Array(64);class SHA256 extends HashMD{constructor(){super(64,32,8,!1),this.A=0|_r[0],this.B=0|_r[1],this.C=0|_r[2],this.D=0|_r[3],this.E=0|_r[4],this.F=0|_r[5],this.G=0|_r[6],this.H=0|_r[7]}get(){const{A:e,B:r,C:n,D:i,E:s,F:a,G:w,H:k}=this;return[e,r,n,i,s,a,w,k]}set(e,r,n,i,s,a,w,k){this.A=0|e,this.B=0|r,this.C=0|n,this.D=0|i,this.E=0|s,this.F=0|a,this.G=0|w,this.H=0|k}process(e,r){for(let n=0;n<16;n++,r+=4)wr[n]=e.getUint32(r,!1);for(let e=16;e<64;e++){const r=wr[e-15],n=wr[e-2],i=rotr(r,7)^rotr(r,18)^r>>>3,s=rotr(n,17)^rotr(n,19)^n>>>10;wr[e]=s+wr[e-7]+i+wr[e-16]|0}let{A:n,B:i,C:s,D:a,E:w,F:k,G:I,H:we}=this;for(let e=0;e<64;e++){const r=we+(rotr(w,6)^rotr(w,11)^rotr(w,25))+((Ae=w)&k^~Ae&I)+br[e]+wr[e]|0,Ce=(rotr(n,2)^rotr(n,13)^rotr(n,22))+Maj(n,i,s)|0;we=I,I=k,k=w,w=a+r|0,a=s,s=i,i=n,n=r+Ce|0}var Ae;n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,a=a+this.D|0,w=w+this.E|0,k=k+this.F|0,I=I+this.G|0,we=we+this.H|0,this.set(n,i,s,a,w,k,I,we)}roundClean(){wr.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Sr=utils_wrapConstructor((()=>new SHA256));var Er=n(881818),kr=n(878918),Ar=n(856115);class StructError extends TypeError{constructor(e,r){let n;const{message:i,...s}=e,{path:a}=e;super(0===a.length?i:"At path: "+a.join(".")+" -- "+i),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>{var i;return null!=(i=n)?i:n=[e,...r()]}}}function isObject(e){return"object"==typeof e&&null!=e}function print(e){return"string"==typeof e?JSON.stringify(e):""+e}function toFailure(e,r,n,i){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:s,branch:a}=r,{type:w}=n,{refinement:k,message:I="Expected a value of type `"+w+"`"+(k?" with refinement `"+k+"`":"")+", but received: `"+print(i)+"`"}=e;return{value:i,type:w,refinement:k,key:s[s.length-1],path:s,branch:a,...e,message:I}}function*toFailures(e,r,n,i){(function isIterable(e){return isObject(e)&&"function"==typeof e[Symbol.iterator]})(e)||(e=[e]);for(const s of e){const e=toFailure(s,r,n,i);e&&(yield e)}}function*run(e,r,n={}){const{path:i=[],branch:s=[e],coerce:a=!1,mask:w=!1}=n,k={path:i,branch:s};if(a&&(e=r.coercer(e,k),w&&"type"!==r.type&&isObject(r.schema)&&isObject(e)&&!Array.isArray(e)))for(const n in e)void 0===r.schema[n]&&delete e[n];let I=!0;for(const n of r.validator(e,k))I=!1,yield[n,void 0];for(let[n,we,Ae]of r.entries(e,k)){const r=run(we,Ae,{path:void 0===n?i:[...i,n],branch:void 0===n?s:[...s,we],coerce:a,mask:w});for(const i of r)i[0]?(I=!1,yield[i[0],void 0]):a&&(we=i[1],void 0===n?e=we:e instanceof Map?e.set(n,we):e instanceof Set?e.add(we):isObject(e)&&(e[n]=we))}if(I)for(const n of r.refiner(e,k))I=!1,yield[n,void 0];I&&(yield[void 0,e])}class Struct{constructor(e){const{type:r,schema:n,validator:i,refiner:s,coercer:a=(e=>e),entries:w=function*(){}}=e;this.type=r,this.schema=n,this.entries=w,this.coercer=a,this.validator=i?(e,r)=>toFailures(i(e,r),r,this,e):()=>[],this.refiner=s?(e,r)=>toFailures(s(e,r),r,this,e):()=>[]}assert(e){return index_es_assert(e,this)}create(e){return create(e,this)}is(e){return is(e,this)}mask(e){return function mask(e,r){const n=validate(e,r,{coerce:!0,mask:!0});if(n[0])throw n[0];return n[1]}(e,this)}validate(e,r={}){return validate(e,this,r)}}function index_es_assert(e,r){const n=validate(e,r);if(n[0])throw n[0]}function create(e,r){const n=validate(e,r,{coerce:!0});if(n[0])throw n[0];return n[1]}function is(e,r){return!validate(e,r)[0]}function validate(e,r,n={}){const i=run(e,r,n),s=function shiftIterator(e){const{done:r,value:n}=e.next();return r?void 0:n}(i);if(s[0]){return[new StructError(s[0],(function*(){for(const e of i)e[0]&&(yield e[0])})),void 0]}return[void 0,s[1]]}function index_es_define(e,r){return new Struct({type:e,schema:null,validator:r})}function array(e){return new Struct({type:"array",schema:e,*entries(r){if(e&&Array.isArray(r))for(const[n,i]of r.entries())yield[n,i,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||"Expected an array value, but received: "+print(e)})}function index_es_boolean(){return index_es_define("boolean",(e=>"boolean"==typeof e))}function instance(e){return index_es_define("instance",(r=>r instanceof e||"Expected a `"+e.name+"` instance, but received: "+print(r)))}function literal(e){const r=print(e),n=typeof e;return new Struct({type:"literal",schema:"string"===n||"number"===n||"boolean"===n?e:null,validator:n=>n===e||"Expected the literal `"+r+"`, but received: "+print(n)})}function never(){return index_es_define("never",(()=>!1))}function nullable(e){return new Struct({...e,validator:(r,n)=>null===r||e.validator(r,n),refiner:(r,n)=>null===r||e.refiner(r,n)})}function index_es_number(){return index_es_define("number",(e=>"number"==typeof e&&!isNaN(e)||"Expected a number, but received: "+print(e)))}function optional(e){return new Struct({...e,validator:(r,n)=>void 0===r||e.validator(r,n),refiner:(r,n)=>void 0===r||e.refiner(r,n)})}function record(e,r){return new Struct({type:"record",schema:null,*entries(n){if(isObject(n))for(const i in n){const s=n[i];yield[i,i,e],yield[i,s,r]}},validator:e=>isObject(e)||"Expected an object, but received: "+print(e)})}function string(){return index_es_define("string",(e=>"string"==typeof e||"Expected a string, but received: "+print(e)))}function tuple(e){const r=never();return new Struct({type:"tuple",schema:null,*entries(n){if(Array.isArray(n)){const i=Math.max(e.length,n.length);for(let s=0;s<i;s++)yield[s,n[s],e[s]||r]}},validator:e=>Array.isArray(e)||"Expected an array, but received: "+print(e)})}function type(e){const r=Object.keys(e);return new Struct({type:"type",schema:e,*entries(n){if(isObject(n))for(const i of r)yield[i,n[i],e[i]]},validator:e=>isObject(e)||"Expected an object, but received: "+print(e)})}function union(e){const r=e.map((e=>e.type)).join(" | ");return new Struct({type:"union",schema:null,validator(n,i){const s=[];for(const r of e){const[...e]=run(n,r,i),[a]=e;if(!a[0])return[];for(const[r]of e)r&&s.push(r)}return["Expected the value to satisfy a union of `"+r+"`, but received: "+print(n),...s]}})}function unknown(){return index_es_define("unknown",(()=>!0))}function coerce(e,r,n){return new Struct({...e,coercer:(i,s)=>is(i,r)?e.coercer(n(i,s),s):e.coercer(i,s)})}var Ir=n(759499),Rr=n.n(Ir),vr=n(50162),Or=n(172208);const xr=[],Tr=[],Nr=[],Pr=BigInt(0),Cr=BigInt(1),Br=BigInt(2),Lr=BigInt(7),zr=BigInt(256),Dr=BigInt(113);for(let e=0,r=Cr,n=1,i=0;e<24;e++){[n,i]=[i,(2*n+3*i)%5],xr.push(2*(5*i+n)),Tr.push((e+1)*(e+2)/2%64);let s=Pr;for(let e=0;e<7;e++)r=(r<<Cr^(r>>Lr)*Dr)%zr,r&Br&&(s^=Cr<<(Cr<<BigInt(e))-Cr);Nr.push(s)}const[Kr,Ur]=split(Nr,!0),rotlH=(e,r,n)=>n>32?rotlBH(e,r,n):rotlSH(e,r,n),rotlL=(e,r,n)=>n>32?rotlBL(e,r,n):rotlSL(e,r,n);class Keccak extends Hash{constructor(e,r,n,i=!1,s=24){if(super(),this.blockLen=e,this.suffix=r,this.outputLen=n,this.enableXOF=i,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,number(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var a;this.state=new Uint8Array(200),this.state32=(a=this.state,new Uint32Array(a.buffer,a.byteOffset,Math.floor(a.byteLength/4)))}keccak(){w||byteSwap32(this.state32),function keccakP(e,r=24){const n=new Uint32Array(10);for(let i=24-r;i<24;i++){for(let r=0;r<10;r++)n[r]=e[r]^e[r+10]^e[r+20]^e[r+30]^e[r+40];for(let r=0;r<10;r+=2){const i=(r+8)%10,s=(r+2)%10,a=n[s],w=n[s+1],k=rotlH(a,w,1)^n[i],I=rotlL(a,w,1)^n[i+1];for(let n=0;n<50;n+=10)e[r+n]^=k,e[r+n+1]^=I}let r=e[2],s=e[3];for(let n=0;n<24;n++){const i=Tr[n],a=rotlH(r,s,i),w=rotlL(r,s,i),k=xr[n];r=e[k],s=e[k+1],e[k]=a,e[k+1]=w}for(let r=0;r<50;r+=10){for(let i=0;i<10;i++)n[i]=e[r+i];for(let i=0;i<10;i++)e[r+i]^=~n[(i+2)%10]&n[(i+4)%10]}e[0]^=Kr[i],e[1]^=Ur[i]}n.fill(0)}(this.state32,this.rounds),w||byteSwap32(this.state32),this.posOut=0,this.pos=0}update(e){exists(this);const{blockLen:r,state:n}=this,i=(e=toBytes(e)).length;for(let s=0;s<i;){const a=Math.min(r-this.pos,i-s);for(let r=0;r<a;r++)n[this.pos++]^=e[s++];this.pos===r&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:r,pos:n,blockLen:i}=this;e[n]^=r,128&r&&n===i-1&&this.keccak(),e[i-1]^=128,this.keccak()}writeInto(e){exists(this,!1),bytes(e),this.finish();const r=this.state,{blockLen:n}=this;for(let i=0,s=e.length;i<s;){this.posOut>=n&&this.keccak();const a=Math.min(n-this.posOut,s-i);e.set(r.subarray(this.posOut,this.posOut+a),i),this.posOut+=a,i+=a}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return number(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(output(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:r,suffix:n,outputLen:i,rounds:s,enableXOF:a}=this;return e||(e=new Keccak(r,n,i,a,s)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=s,e.suffix=n,e.outputLen=i,e.enableXOF=a,e.destroyed=this.destroyed,e}}const gen=(e,r,n)=>utils_wrapConstructor((()=>new Keccak(r,e,n))),Mr=gen(1,136,32);class HMAC extends Hash{constructor(e,r){super(),this.finished=!1,this.destroyed=!1,_assert_hash(e);const n=toBytes(r);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(n.length>i?e.create().update(n).digest():n);for(let e=0;e<s.length;e++)s[e]^=54;this.iHash.update(s),this.oHash=e.create();for(let e=0;e<s.length;e++)s[e]^=106;this.oHash.update(s),s.fill(0)}update(e){return exists(this),this.iHash.update(e),this}digestInto(e){exists(this),bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:n,finished:i,destroyed:s,blockLen:a,outputLen:w}=this;return e.finished=i,e.destroyed=s,e.blockLen=a,e.outputLen=w,e.oHash=r._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(e,r,n)=>new HMAC(e,r).update(n).digest();hmac.create=(e,r)=>new HMAC(e,r);const{bytesToNumberBE:Fr,hexToBytes:Wr}=i,qr={Err:class DERErr extends Error{constructor(e=""){super(e)}},_parseInt(e){const{Err:r}=qr;if(e.length<2||2!==e[0])throw new r("Invalid signature integer tag");const n=e[1],i=e.subarray(2,n+2);if(!n||i.length!==n)throw new r("Invalid signature integer: wrong length");if(128&i[0])throw new r("Invalid signature integer: negative");if(0===i[0]&&!(128&i[1]))throw new r("Invalid signature integer: unnecessary leading zero");return{d:Fr(i),l:e.subarray(n+2)}},toSig(e){const{Err:r}=qr,n="string"==typeof e?Wr(e):e;utils_abytes(n);let i=n.length;if(i<2||48!=n[0])throw new r("Invalid signature tag");if(n[1]!==i-2)throw new r("Invalid signature: incorrect length");const{d:s,l:a}=qr._parseInt(n.subarray(2)),{d:w,l:k}=qr._parseInt(a);if(k.length)throw new r("Invalid signature: left bytes after parsing");return{r:s,s:w}},hexFromSig(e){const slice=e=>8&Number.parseInt(e[0],16)?"00"+e:e,h=e=>{const r=e.toString(16);return 1&r.length?`0${r}`:r},r=slice(h(e.s)),n=slice(h(e.r)),i=r.length/2,s=n.length/2,a=h(i),w=h(s);return`30${h(s+i+4)}02${w}${n}02${a}${r}`}},Vr=BigInt(0),jr=BigInt(1),Hr=(BigInt(2),BigInt(3));BigInt(4);function weierstrassPoints(e){const r=function validatePointOpts(e){const r=validateBasic(e);validateObject(r,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:i,a:s}=r;if(n){if(!i.eql(s,i.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...r})}(e),{Fp:n}=r,i=r.toBytes||((e,r,i)=>{const s=r.toAffine();return abstract_utils_concatBytes(Uint8Array.from([4]),n.toBytes(s.x),n.toBytes(s.y))}),s=r.fromBytes||(e=>{const r=e.subarray(1);return{x:n.fromBytes(r.subarray(0,n.BYTES)),y:n.fromBytes(r.subarray(n.BYTES,2*n.BYTES))}});function weierstrassEquation(e){const{a:i,b:s}=r,a=n.sqr(e),w=n.mul(a,e);return n.add(n.add(w,n.mul(e,i)),s)}if(!n.eql(n.sqr(r.Gy),weierstrassEquation(r.Gx)))throw new Error("bad generator point: equation left != right");function isWithinCurveOrder(e){return"bigint"==typeof e&&Vr<e&&e<r.n}function assertGE(e){if(!isWithinCurveOrder(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function normPrivateKeyToScalar(e){const{allowedPrivateKeyLengths:n,nByteLength:i,wrapPrivateKey:s,n:a}=r;if(n&&"bigint"!=typeof e){if(abstract_utils_isBytes(e)&&(e=abstract_utils_bytesToHex(e)),"string"!=typeof e||!n.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*i,"0")}let w;try{w="bigint"==typeof e?e:utils_bytesToNumberBE(utils_ensureBytes("private key",e,i))}catch(r){throw new Error(`private key must be ${i} bytes, hex or bigint, not ${typeof e}`)}return s&&(w=modular_mod(w,a)),assertGE(w),w}const a=new Map;function assertPrjPoint(e){if(!(e instanceof Point))throw new Error("ProjectivePoint expected")}class Point{constructor(e,r,i){if(this.px=e,this.py=r,this.pz=i,null==e||!n.isValid(e))throw new Error("x required");if(null==r||!n.isValid(r))throw new Error("y required");if(null==i||!n.isValid(i))throw new Error("z required")}static fromAffine(e){const{x:r,y:i}=e||{};if(!e||!n.isValid(r)||!n.isValid(i))throw new Error("invalid affine point");if(e instanceof Point)throw new Error("projective point not allowed");const is0=e=>n.eql(e,n.ZERO);return is0(r)&&is0(i)?Point.ZERO:new Point(r,i,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const r=n.invertBatch(e.map((e=>e.pz)));return e.map(((e,n)=>e.toAffine(r[n]))).map(Point.fromAffine)}static fromHex(e){const r=Point.fromAffine(s(utils_ensureBytes("pointHex",e)));return r.assertValidity(),r}static fromPrivateKey(e){return Point.BASE.multiply(normPrivateKeyToScalar(e))}_setWindowSize(e){this._WINDOW_SIZE=e,a.delete(this)}assertValidity(){if(this.is0()){if(r.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:e,y:i}=this.toAffine();if(!n.isValid(e)||!n.isValid(i))throw new Error("bad point: x or y not FE");const s=n.sqr(i),a=weierstrassEquation(e);if(!n.eql(s,a))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(n.isOdd)return!n.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){assertPrjPoint(e);const{px:r,py:i,pz:s}=this,{px:a,py:w,pz:k}=e,I=n.eql(n.mul(r,k),n.mul(a,s)),we=n.eql(n.mul(i,k),n.mul(w,s));return I&&we}negate(){return new Point(this.px,n.neg(this.py),this.pz)}double(){const{a:e,b:i}=r,s=n.mul(i,Hr),{px:a,py:w,pz:k}=this;let I=n.ZERO,we=n.ZERO,Ae=n.ZERO,Ce=n.mul(a,a),Be=n.mul(w,w),ze=n.mul(k,k),qe=n.mul(a,w);return qe=n.add(qe,qe),Ae=n.mul(a,k),Ae=n.add(Ae,Ae),I=n.mul(e,Ae),we=n.mul(s,ze),we=n.add(I,we),I=n.sub(Be,we),we=n.add(Be,we),we=n.mul(I,we),I=n.mul(qe,I),Ae=n.mul(s,Ae),ze=n.mul(e,ze),qe=n.sub(Ce,ze),qe=n.mul(e,qe),qe=n.add(qe,Ae),Ae=n.add(Ce,Ce),Ce=n.add(Ae,Ce),Ce=n.add(Ce,ze),Ce=n.mul(Ce,qe),we=n.add(we,Ce),ze=n.mul(w,k),ze=n.add(ze,ze),Ce=n.mul(ze,qe),I=n.sub(I,Ce),Ae=n.mul(ze,Be),Ae=n.add(Ae,Ae),Ae=n.add(Ae,Ae),new Point(I,we,Ae)}add(e){assertPrjPoint(e);const{px:i,py:s,pz:a}=this,{px:w,py:k,pz:I}=e;let we=n.ZERO,Ae=n.ZERO,Ce=n.ZERO;const Be=r.a,ze=n.mul(r.b,Hr);let qe=n.mul(i,w),$e=n.mul(s,k),Ye=n.mul(a,I),Je=n.add(i,s),et=n.add(w,k);Je=n.mul(Je,et),et=n.add(qe,$e),Je=n.sub(Je,et),et=n.add(i,a);let rt=n.add(w,I);return et=n.mul(et,rt),rt=n.add(qe,Ye),et=n.sub(et,rt),rt=n.add(s,a),we=n.add(k,I),rt=n.mul(rt,we),we=n.add($e,Ye),rt=n.sub(rt,we),Ce=n.mul(Be,et),we=n.mul(ze,Ye),Ce=n.add(we,Ce),we=n.sub($e,Ce),Ce=n.add($e,Ce),Ae=n.mul(we,Ce),$e=n.add(qe,qe),$e=n.add($e,qe),Ye=n.mul(Be,Ye),et=n.mul(ze,et),$e=n.add($e,Ye),Ye=n.sub(qe,Ye),Ye=n.mul(Be,Ye),et=n.add(et,Ye),qe=n.mul($e,et),Ae=n.add(Ae,qe),qe=n.mul(rt,et),we=n.mul(Je,we),we=n.sub(we,qe),qe=n.mul(Je,$e),Ce=n.mul(rt,Ce),Ce=n.add(Ce,qe),new Point(we,Ae,Ce)}subtract(e){return this.add(e.negate())}is0(){return this.equals(Point.ZERO)}wNAF(e){return k.wNAFCached(this,a,e,(e=>{const r=n.invertBatch(e.map((e=>e.pz)));return e.map(((e,n)=>e.toAffine(r[n]))).map(Point.fromAffine)}))}multiplyUnsafe(e){const i=Point.ZERO;if(e===Vr)return i;if(assertGE(e),e===jr)return this;const{endo:s}=r;if(!s)return k.unsafeLadder(this,e);let{k1neg:a,k1:w,k2neg:I,k2:we}=s.splitScalar(e),Ae=i,Ce=i,Be=this;for(;w>Vr||we>Vr;)w&jr&&(Ae=Ae.add(Be)),we&jr&&(Ce=Ce.add(Be)),Be=Be.double(),w>>=jr,we>>=jr;return a&&(Ae=Ae.negate()),I&&(Ce=Ce.negate()),Ce=new Point(n.mul(Ce.px,s.beta),Ce.py,Ce.pz),Ae.add(Ce)}multiply(e){assertGE(e);let i,s,a=e;const{endo:w}=r;if(w){const{k1neg:e,k1:r,k2neg:I,k2:we}=w.splitScalar(a);let{p:Ae,f:Ce}=this.wNAF(r),{p:Be,f:ze}=this.wNAF(we);Ae=k.constTimeNegate(e,Ae),Be=k.constTimeNegate(I,Be),Be=new Point(n.mul(Be.px,w.beta),Be.py,Be.pz),i=Ae.add(Be),s=Ce.add(ze)}else{const{p:e,f:r}=this.wNAF(a);i=e,s=r}return Point.normalizeZ([i,s])[0]}multiplyAndAddUnsafe(e,r,n){const i=Point.BASE,mul=(e,r)=>r!==Vr&&r!==jr&&e.equals(i)?e.multiply(r):e.multiplyUnsafe(r),s=mul(this,r).add(mul(e,n));return s.is0()?void 0:s}toAffine(e){const{px:r,py:i,pz:s}=this,a=this.is0();null==e&&(e=a?n.ONE:n.inv(s));const w=n.mul(r,e),k=n.mul(i,e),I=n.mul(s,e);if(a)return{x:n.ZERO,y:n.ZERO};if(!n.eql(I,n.ONE))throw new Error("invZ was invalid");return{x:w,y:k}}isTorsionFree(){const{h:e,isTorsionFree:n}=r;if(e===jr)return!0;if(n)return n(Point,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:n}=r;return e===jr?this:n?n(Point,this):this.multiplyUnsafe(r.h)}toRawBytes(e=!0){return this.assertValidity(),i(Point,this,e)}toHex(e=!0){return abstract_utils_bytesToHex(this.toRawBytes(e))}}Point.BASE=new Point(r.Gx,r.Gy,n.ONE),Point.ZERO=new Point(n.ZERO,n.ONE,n.ZERO);const w=r.nBitLength,k=wNAF(Point,r.endo?Math.ceil(w/2):w);return{CURVE:r,ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}}function weierstrass(e){const r=function weierstrass_validateOpts(e){const r=validateBasic(e);return validateObject(r,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...r})}(e),{Fp:n,n:i}=r,s=n.BYTES+1,a=2*n.BYTES+1;function modN(e){return modular_mod(e,i)}function invN(e){return invert(e,i)}const{ProjectivePoint:w,normPrivateKeyToScalar:k,weierstrassEquation:I,isWithinCurveOrder:we}=weierstrassPoints({...r,toBytes(e,r,i){const s=r.toAffine(),a=n.toBytes(s.x),w=abstract_utils_concatBytes;return i?w(Uint8Array.from([r.hasEvenY()?2:3]),a):w(Uint8Array.from([4]),a,n.toBytes(s.y))},fromBytes(e){const r=e.length,i=e[0],w=e.subarray(1);if(r!==s||2!==i&&3!==i){if(r===a&&4===i){return{x:n.fromBytes(w.subarray(0,n.BYTES)),y:n.fromBytes(w.subarray(n.BYTES,2*n.BYTES))}}throw new Error(`Point of length ${r} was invalid. Expected ${s} compressed bytes or ${a} uncompressed bytes`)}{const e=utils_bytesToNumberBE(w);if(!function isValidFieldElement(e){return Vr<e&&e<n.ORDER}(e))throw new Error("Point is not on curve");const r=I(e);let s;try{s=n.sqrt(r)}catch(e){const r=e instanceof Error?": "+e.message:"";throw new Error("Point is not on curve"+r)}return!(1&~i)!==((s&jr)===jr)&&(s=n.neg(s)),{x:e,y:s}}}}),numToNByteStr=e=>abstract_utils_bytesToHex(utils_numberToBytesBE(e,r.nByteLength));function isBiggerThanHalfOrder(e){return e>i>>jr}const slcNum=(e,r,n)=>utils_bytesToNumberBE(e.slice(r,n));class Signature{constructor(e,r,n){this.r=e,this.s=r,this.recovery=n,this.assertValidity()}static fromCompact(e){const n=r.nByteLength;return e=utils_ensureBytes("compactSignature",e,2*n),new Signature(slcNum(e,0,n),slcNum(e,n,2*n))}static fromDER(e){const{r,s:n}=qr.toSig(utils_ensureBytes("DER",e));return new Signature(r,n)}assertValidity(){if(!we(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!we(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new Signature(this.r,this.s,e)}recoverPublicKey(e){const{r:i,s,recovery:a}=this,k=Be(utils_ensureBytes("msgHash",e));if(null==a||![0,1,2,3].includes(a))throw new Error("recovery id invalid");const I=2===a||3===a?i+r.n:i;if(I>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const we=1&a?"03":"02",Ae=w.fromHex(we+numToNByteStr(I)),Ce=invN(I),ze=modN(-k*Ce),qe=modN(s*Ce),$e=w.BASE.multiplyAndAddUnsafe(Ae,ze,qe);if(!$e)throw new Error("point at infinify");return $e.assertValidity(),$e}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return utils_hexToBytes(this.toDERHex())}toDERHex(){return qr.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return utils_hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}}const Ae={isValidPrivateKey(e){try{return k(e),!0}catch(e){return!1}},normPrivateKeyToScalar:k,randomPrivateKey:()=>{const e=getMinHashLength(r.n);return function mapHashToField(e,r,n=!1){const i=e.length,s=getFieldBytesLength(r),a=getMinHashLength(r);if(i<16||i<a||i>1024)throw new Error(`expected ${a}-1024 bytes of input, got ${i}`);const w=modular_mod(n?utils_bytesToNumberBE(e):utils_bytesToNumberLE(e),r-ot)+ot;return n?utils_numberToBytesLE(w,s):utils_numberToBytesBE(w,s)}(r.randomBytes(e),r.n)},precompute:(e=8,r=w.BASE)=>(r._setWindowSize(e),r.multiply(BigInt(3)),r)};function isProbPub(e){const r=abstract_utils_isBytes(e),n="string"==typeof e,i=(r||n)&&e.length;return r?i===s||i===a:n?i===2*s||i===2*a:e instanceof w}const Ce=r.bits2int||function(e){const n=utils_bytesToNumberBE(e),i=8*e.length-r.nBitLength;return i>0?n>>BigInt(i):n},Be=r.bits2int_modN||function(e){return modN(Ce(e))},ze=bitMask(r.nBitLength);function int2octets(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(Vr<=e&&e<ze))throw new Error(`bigint expected < 2^${r.nBitLength}`);return utils_numberToBytesBE(e,r.nByteLength)}function prepSig(e,i,s=qe){if(["recovered","canonical"].some((e=>e in s)))throw new Error("sign() legacy options not supported");const{hash:a,randomBytes:I}=r;let{lowS:Ae,prehash:ze,extraEntropy:$e}=s;null==Ae&&(Ae=!0),e=utils_ensureBytes("msgHash",e),ze&&(e=utils_ensureBytes("prehashed msgHash",a(e)));const Ye=Be(e),Je=k(i),et=[int2octets(Je),int2octets(Ye)];if(null!=$e&&!1!==$e){const e=!0===$e?I(n.BYTES):$e;et.push(utils_ensureBytes("extraEntropy",e))}const rt=abstract_utils_concatBytes(...et),it=Ye;return{seed:rt,k2sig:function k2sig(e){const r=Ce(e);if(!we(r))return;const n=invN(r),i=w.BASE.multiply(r).toAffine(),s=modN(i.x);if(s===Vr)return;const a=modN(n*modN(it+s*Je));if(a===Vr)return;let k=(i.x===s?0:2)|Number(i.y&jr),I=a;return Ae&&isBiggerThanHalfOrder(a)&&(I=function normalizeS(e){return isBiggerThanHalfOrder(e)?modN(-e):e}(a),k^=1),new Signature(s,I,k)}}}const qe={lowS:r.lowS,prehash:!1},$e={lowS:r.lowS,prehash:!1};return w.BASE._setWindowSize(8),{CURVE:r,getPublicKey:function getPublicKey(e,r=!0){return w.fromPrivateKey(e).toRawBytes(r)},getSharedSecret:function getSharedSecret(e,r,n=!0){if(isProbPub(e))throw new Error("first arg must be private key");if(!isProbPub(r))throw new Error("second arg must be public key");return w.fromHex(r).multiply(k(e)).toRawBytes(n)},sign:function sign(e,n,i=qe){const{seed:s,k2sig:a}=prepSig(e,n,i),w=r;return createHmacDrbg(w.hash.outputLen,w.nByteLength,w.hmac)(s,a)},verify:function verify(e,n,i,s=$e){const a=e;if(n=utils_ensureBytes("msgHash",n),i=utils_ensureBytes("publicKey",i),"strict"in s)throw new Error("options.strict was renamed to lowS");const{lowS:k,prehash:I}=s;let we,Ae;try{if("string"==typeof a||abstract_utils_isBytes(a))try{we=Signature.fromDER(a)}catch(e){if(!(e instanceof qr.Err))throw e;we=Signature.fromCompact(a)}else{if("object"!=typeof a||"bigint"!=typeof a.r||"bigint"!=typeof a.s)throw new Error("PARSE");{const{r:e,s:r}=a;we=new Signature(e,r)}}Ae=w.fromHex(i)}catch(e){if("PARSE"===e.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(k&&we.hasHighS())return!1;I&&(n=r.hash(n));const{r:Ce,s:ze}=we,qe=Be(n),Ye=invN(ze),Je=modN(qe*Ye),et=modN(Ce*Ye),rt=w.BASE.multiplyAndAddUnsafe(Ae,Je,et)?.toAffine();return!!rt&&modN(rt.x)===Ce},ProjectivePoint:w,Signature,utils:Ae}}function getHash(e){return{hash:e,hmac:(r,...n)=>hmac(e,r,utils_concatBytes(...n)),randomBytes:utils_randomBytes}}const $r=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Yr=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Gr=BigInt(1),Jr=BigInt(2),divNearest=(e,r)=>(e+r/Jr)/r;function sqrtMod(e){const r=$r,n=BigInt(3),i=BigInt(6),s=BigInt(11),a=BigInt(22),w=BigInt(23),k=BigInt(44),I=BigInt(88),we=e*e*e%r,Ae=we*we*e%r,Ce=modular_pow2(Ae,n,r)*Ae%r,Be=modular_pow2(Ce,n,r)*Ae%r,ze=modular_pow2(Be,Jr,r)*we%r,qe=modular_pow2(ze,s,r)*ze%r,$e=modular_pow2(qe,a,r)*qe%r,Ye=modular_pow2($e,k,r)*$e%r,Je=modular_pow2(Ye,I,r)*Ye%r,et=modular_pow2(Je,k,r)*$e%r,rt=modular_pow2(et,n,r)*Ae%r,it=modular_pow2(rt,w,r)*qe%r,ot=modular_pow2(it,i,r)*we%r,ht=modular_pow2(ot,Jr,r);if(!Zr.eql(Zr.sqr(ht),e))throw new Error("Cannot find square root");return ht}const Zr=Field($r,void 0,void 0,{sqrt:sqrtMod}),Xr=function createCurve(e,r){const create=r=>weierstrass({...e,...getHash(r)});return Object.freeze({...create(r),create})}({a:BigInt(0),b:BigInt(7),Fp:Zr,n:Yr,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const r=Yr,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),i=-Gr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),a=n,w=BigInt("0x100000000000000000000000000000000"),k=divNearest(a*e,r),I=divNearest(-i*e,r);let we=modular_mod(e-k*n-I*s,r),Ae=modular_mod(-k*i-I*a,r);const Ce=we>w,Be=Ae>w;if(Ce&&(we=r-we),Be&&(Ae=r-Ae),we>w||Ae>w)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:Ce,k1:we,k2neg:Be,k2:Ae}}}},Sr);BigInt(0);Xr.ProjectivePoint;const Qr=hr.utils.randomPrivateKey,generateKeypair=()=>{const e=hr.utils.randomPrivateKey(),r=sn(e),n=new Uint8Array(64);return n.set(e),n.set(r,32),{publicKey:r,secretKey:n}},sn=hr.getPublicKey;function isOnCurve(e){try{return hr.ExtendedPoint.fromHex(e),!0}catch{return!1}}const sign=(e,r)=>hr.sign(e,r.slice(0,32)),an=hr.verify,toBuffer=e=>s.Buffer.isBuffer(e)?e:e instanceof Uint8Array?s.Buffer.from(e.buffer,e.byteOffset,e.byteLength):s.Buffer.from(e);class index_browser_esm_Struct{constructor(e){Object.assign(this,e)}encode(){return s.Buffer.from((0,Er.serialize)(cn,this))}static decode(e){return(0,Er.deserialize)(cn,this,e)}static decodeUnchecked(e){return(0,Er.deserializeUnchecked)(cn,this,e)}}class Enum extends index_browser_esm_Struct{constructor(e){if(super(e),this.enum="",1!==Object.keys(e).length)throw new Error("Enum can only take single value");Object.keys(e).map((e=>{this.enum=e}))}}const cn=new Map;var un;const dn=32,ln=32;let gn=1;class PublicKey extends index_browser_esm_Struct{constructor(e){if(super({}),this._bn=void 0,function isPublicKeyData(e){return void 0!==e._bn}(e))this._bn=e._bn;else{if("string"==typeof e){const r=yr().decode(e);if(r.length!=ln)throw new Error("Invalid public key input");this._bn=new(pr())(r)}else this._bn=new(pr())(e);if(this._bn.byteLength()>ln)throw new Error("Invalid public key input")}}static unique(){const e=new PublicKey(gn);return gn+=1,new PublicKey(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return yr().encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(s.Buffer);if(e.length===ln)return e;const r=s.Buffer.alloc(32);return e.copy(r,32-e.length),r}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,r,n){const i=s.Buffer.concat([e.toBuffer(),s.Buffer.from(r),n.toBuffer()]),a=Sr(i);return new PublicKey(a)}static createProgramAddressSync(e,r){let n=s.Buffer.alloc(0);e.forEach((function(e){if(e.length>dn)throw new TypeError("Max seed length exceeded");n=s.Buffer.concat([n,toBuffer(e)])})),n=s.Buffer.concat([n,r.toBuffer(),s.Buffer.from("ProgramDerivedAddress")]);const i=Sr(n);if(isOnCurve(i))throw new Error("Invalid seeds, address must fall off the curve");return new PublicKey(i)}static async createProgramAddress(e,r){return this.createProgramAddressSync(e,r)}static findProgramAddressSync(e,r){let n,i=255;for(;0!=i;){try{const a=e.concat(s.Buffer.from([i]));n=this.createProgramAddressSync(a,r)}catch(e){if(e instanceof TypeError)throw e;i--;continue}return[n,i]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,r){return this.findProgramAddressSync(e,r)}static isOnCurve(e){return isOnCurve(new PublicKey(e).toBytes())}}un=PublicKey,PublicKey.default=new un("11111111111111111111111111111111"),cn.set(PublicKey,{kind:"struct",fields:[["_bn","u256"]]});class Account{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const r=toBuffer(e);if(64!==e.length)throw new Error("bad secret key size");this._publicKey=r.slice(32,64),this._secretKey=r.slice(0,32)}else this._secretKey=toBuffer(Qr()),this._publicKey=toBuffer(sn(this._secretKey))}get publicKey(){return new PublicKey(this._publicKey)}get secretKey(){return s.Buffer.concat([this._secretKey,this._publicKey],64)}}const pn=new PublicKey("BPFLoader1111111111111111111111111111111111"),mn=1232,yn=127,bn=64;class TransactionExpiredBlockheightExceededError extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class TransactionExpiredTimeoutError extends Error{constructor(e,r){super(`Transaction was not confirmed in ${r.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredTimeoutError.prototype,"name",{value:"TransactionExpiredTimeoutError"});class TransactionExpiredNonceInvalidError extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredNonceInvalidError.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class MessageAccountKeys{constructor(e,r){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=r}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const r of this.keySegments()){if(e<r.length)return r[e];e-=r.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach(((e,n)=>{r.set(e.toBase58(),n)}));const findKeyIndex=e=>{const n=r.get(e.toBase58());if(void 0===n)throw new Error("Encountered an unknown instruction account key during compilation");return n};return e.map((e=>({programIdIndex:findKeyIndex(e.programId),accountKeyIndexes:e.keys.map((e=>findKeyIndex(e.pubkey))),data:e.data})))}}const publicKey=(e="publicKey")=>kr.blob(32,e),signature=(e="signature")=>kr.blob(64,e),rustString=(e="string")=>{const r=kr.struct([kr.u32("length"),kr.u32("lengthPadding"),kr.blob(kr.offset(kr.u32(),-8),"chars")],e),n=r.decode.bind(r),i=r.encode.bind(r),a=r;return a.decode=(e,r)=>n(e,r).chars.toString(),a.encode=(e,r,n)=>{const a={chars:s.Buffer.from(e,"utf8")};return i(a,r,n)},a.alloc=e=>kr.u32().span+kr.u32().span+s.Buffer.from(e,"utf8").length,a};function getAlloc(e,r){const getItemAlloc=e=>{if(e.span>=0)return e.span;if("function"==typeof e.alloc)return e.alloc(r[e.property]);if("count"in e&&"elementLayout"in e){const n=r[e.property];if(Array.isArray(n))return n.length*getItemAlloc(e.elementLayout)}else if("fields"in e)return getAlloc({layout:e},r[e.property]);return 0};let n=0;return e.layout.fields.forEach((e=>{n+=getItemAlloc(e)})),n}function decodeLength(e){let r=0,n=0;for(;;){let i=e.shift();if(r|=(127&i)<<7*n,n+=1,!(128&i))break}return r}function encodeLength(e,r){let n=r;for(;;){let r=127&n;if(n>>=7,0==n){e.push(r);break}r|=128,e.push(r)}}function index_browser_esm_assert(e,r){if(!e)throw new Error(r||"Assertion failed")}class CompiledKeys{constructor(e,r){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=r}static compile(e,r){const n=new Map,getOrInsertDefault=e=>{const r=e.toBase58();let i=n.get(r);return void 0===i&&(i={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(r,i)),i},i=getOrInsertDefault(r);i.isSigner=!0,i.isWritable=!0;for(const r of e){getOrInsertDefault(r.programId).isInvoked=!0;for(const e of r.keys){const r=getOrInsertDefault(e.pubkey);r.isSigner||=e.isSigner,r.isWritable||=e.isWritable}}return new CompiledKeys(r,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];index_browser_esm_assert(e.length<=256,"Max static account keys length exceeded");const r=e.filter((([,e])=>e.isSigner&&e.isWritable)),n=e.filter((([,e])=>e.isSigner&&!e.isWritable)),i=e.filter((([,e])=>!e.isSigner&&e.isWritable)),s=e.filter((([,e])=>!e.isSigner&&!e.isWritable)),a={numRequiredSignatures:r.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:s.length};{index_browser_esm_assert(r.length>0,"Expected at least one writable signer key");const[e]=r[0];index_browser_esm_assert(e===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}return[a,[...r.map((([e])=>new PublicKey(e))),...n.map((([e])=>new PublicKey(e))),...i.map((([e])=>new PublicKey(e))),...s.map((([e])=>new PublicKey(e)))]]}extractTableLookup(e){const[r,n]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&e.isWritable)),[i,s]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&!e.isWritable));if(0!==r.length||0!==i.length)return[{accountKey:e.key,writableIndexes:r,readonlyIndexes:i},{writable:n,readonly:s}]}drainKeysFoundInLookupTable(e,r){const n=new Array,i=new Array;for(const[s,a]of this.keyMetaMap.entries())if(r(a)){const r=new PublicKey(s),a=e.findIndex((e=>e.equals(r)));a>=0&&(index_browser_esm_assert(a<256,"Max lookup table index exceeded"),n.push(a),i.push(r),this.keyMetaMap.delete(s))}return[n,i]}}const kn="Reached end of buffer unexpectedly";function guardedShift(e){if(0===e.length)throw new Error(kn);return e.shift()}function guardedSplice(e,...r){const[n]=r;if(2===r.length?n+(r[1]??0)>e.length:n>=e.length)throw new Error(kn);return e.splice(...r)}class Message{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map((e=>new PublicKey(e))),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach((e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex])))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map((e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:yr().decode(e.data)})))}get addressTableLookups(){return[]}getAccountKeys(){return new MessageAccountKeys(this.staticAccountKeys)}static compile(e){const r=CompiledKeys.compile(e.instructions,e.payerKey),[n,i]=r.getMessageComponents(),s=new MessageAccountKeys(i).compileInstructions(e.instructions).map((e=>({programIdIndex:e.programIdIndex,accounts:e.accountKeyIndexes,data:yr().encode(e.data)})));return new Message({header:n,accountKeys:i,recentBlockhash:e.recentBlockhash,instructions:s})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const r=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){return e-r<this.accountKeys.length-r-this.header.numReadonlyUnsignedAccounts}return e<r-this.header.numReadonlySignedAccounts}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter(((e,r)=>!this.isProgramId(r)))}serialize(){const e=this.accountKeys.length;let r=[];encodeLength(r,e);const n=this.instructions.map((e=>{const{accounts:r,programIdIndex:n}=e,i=Array.from(yr().decode(e.data));let a=[];encodeLength(a,r.length);let w=[];return encodeLength(w,i.length),{programIdIndex:n,keyIndicesCount:s.Buffer.from(a),keyIndices:r,dataLength:s.Buffer.from(w),data:i}}));let i=[];encodeLength(i,n.length);let a=s.Buffer.alloc(mn);s.Buffer.from(i).copy(a);let w=i.length;n.forEach((e=>{const r=kr.struct([kr.u8("programIdIndex"),kr.blob(e.keyIndicesCount.length,"keyIndicesCount"),kr.seq(kr.u8("keyIndex"),e.keyIndices.length,"keyIndices"),kr.blob(e.dataLength.length,"dataLength"),kr.seq(kr.u8("userdatum"),e.data.length,"data")]).encode(e,a,w);w+=r})),a=a.slice(0,w);const k=kr.struct([kr.blob(1,"numRequiredSignatures"),kr.blob(1,"numReadonlySignedAccounts"),kr.blob(1,"numReadonlyUnsignedAccounts"),kr.blob(r.length,"keyCount"),kr.seq(publicKey("key"),e,"keys"),publicKey("recentBlockhash")]),I={numRequiredSignatures:s.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:s.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:s.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:s.Buffer.from(r),keys:this.accountKeys.map((e=>toBuffer(e.toBytes()))),recentBlockhash:yr().decode(this.recentBlockhash)};let we=s.Buffer.alloc(2048);const Ae=k.encode(I,we);return a.copy(we,Ae),we.slice(0,Ae+a.length)}static from(e){let r=[...e];const n=guardedShift(r);if(n!==(n&yn))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const i=guardedShift(r),a=guardedShift(r),w=decodeLength(r);let k=[];for(let e=0;e<w;e++){const e=guardedSplice(r,0,ln);k.push(new PublicKey(s.Buffer.from(e)))}const I=guardedSplice(r,0,ln),we=decodeLength(r);let Ae=[];for(let e=0;e<we;e++){const e=guardedShift(r),n=guardedSplice(r,0,decodeLength(r)),i=guardedSplice(r,0,decodeLength(r)),a=yr().encode(s.Buffer.from(i));Ae.push({programIdIndex:e,accounts:n,data:a})}const Ce={header:{numRequiredSignatures:n,numReadonlySignedAccounts:i,numReadonlyUnsignedAccounts:a},recentBlockhash:yr().encode(s.Buffer.from(I)),accountKeys:k,instructions:Ae};return new Message(Ce)}}class MessageV0{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const r of this.addressTableLookups)e+=r.readonlyIndexes.length+r.writableIndexes.length;return e}getAccountKeys(e){let r;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");r=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)r=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new MessageAccountKeys(this.staticAccountKeys,r)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const r=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){return e-n<this.addressTableLookups.reduce(((e,r)=>e+r.writableIndexes.length),0)}if(e>=this.header.numRequiredSignatures){return e-r<n-r-this.header.numReadonlyUnsignedAccounts}return e<r-this.header.numReadonlySignedAccounts}resolveAddressTableLookups(e){const r={writable:[],readonly:[]};for(const n of this.addressTableLookups){const i=e.find((e=>e.key.equals(n.accountKey)));if(!i)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const e of n.writableIndexes){if(!(e<i.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${n.accountKey.toBase58()}`);r.writable.push(i.state.addresses[e])}for(const e of n.readonlyIndexes){if(!(e<i.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${n.accountKey.toBase58()}`);r.readonly.push(i.state.addresses[e])}}return r}static compile(e){const r=CompiledKeys.compile(e.instructions,e.payerKey),n=new Array,i={writable:new Array,readonly:new Array},s=e.addressLookupTableAccounts||[];for(const e of s){const s=r.extractTableLookup(e);if(void 0!==s){const[e,{writable:r,readonly:a}]=s;n.push(e),i.writable.push(...r),i.readonly.push(...a)}}const[a,w]=r.getMessageComponents(),k=new MessageAccountKeys(w,i).compileInstructions(e.instructions);return new MessageV0({header:a,staticAccountKeys:w,recentBlockhash:e.recentBlockhash,compiledInstructions:k,addressTableLookups:n})}serialize(){const e=Array();encodeLength(e,this.staticAccountKeys.length);const r=this.serializeInstructions(),n=Array();encodeLength(n,this.compiledInstructions.length);const i=this.serializeAddressTableLookups(),s=Array();encodeLength(s,this.addressTableLookups.length);const a=kr.struct([kr.u8("prefix"),kr.struct([kr.u8("numRequiredSignatures"),kr.u8("numReadonlySignedAccounts"),kr.u8("numReadonlyUnsignedAccounts")],"header"),kr.blob(e.length,"staticAccountKeysLength"),kr.seq(publicKey(),this.staticAccountKeys.length,"staticAccountKeys"),publicKey("recentBlockhash"),kr.blob(n.length,"instructionsLength"),kr.blob(r.length,"serializedInstructions"),kr.blob(s.length,"addressTableLookupsLength"),kr.blob(i.length,"serializedAddressTableLookups")]),w=new Uint8Array(mn),k=a.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map((e=>e.toBytes())),recentBlockhash:yr().decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:r,addressTableLookupsLength:new Uint8Array(s),serializedAddressTableLookups:i},w);return w.slice(0,k)}serializeInstructions(){let e=0;const r=new Uint8Array(mn);for(const n of this.compiledInstructions){const i=Array();encodeLength(i,n.accountKeyIndexes.length);const s=Array();encodeLength(s,n.data.length);e+=kr.struct([kr.u8("programIdIndex"),kr.blob(i.length,"encodedAccountKeyIndexesLength"),kr.seq(kr.u8(),n.accountKeyIndexes.length,"accountKeyIndexes"),kr.blob(s.length,"encodedDataLength"),kr.blob(n.data.length,"data")]).encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(i),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(s),data:n.data},r,e)}return r.slice(0,e)}serializeAddressTableLookups(){let e=0;const r=new Uint8Array(mn);for(const n of this.addressTableLookups){const i=Array();encodeLength(i,n.writableIndexes.length);const s=Array();encodeLength(s,n.readonlyIndexes.length);e+=kr.struct([publicKey("accountKey"),kr.blob(i.length,"encodedWritableIndexesLength"),kr.seq(kr.u8(),n.writableIndexes.length,"writableIndexes"),kr.blob(s.length,"encodedReadonlyIndexesLength"),kr.seq(kr.u8(),n.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(i),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(s),readonlyIndexes:n.readonlyIndexes},r,e)}return r.slice(0,e)}static deserialize(e){let r=[...e];const n=guardedShift(r),i=n&yn;index_browser_esm_assert(n!==i,"Expected versioned message but received legacy message");index_browser_esm_assert(0===i,`Expected versioned message with version 0 but found version ${i}`);const s={numRequiredSignatures:guardedShift(r),numReadonlySignedAccounts:guardedShift(r),numReadonlyUnsignedAccounts:guardedShift(r)},a=[],w=decodeLength(r);for(let e=0;e<w;e++)a.push(new PublicKey(guardedSplice(r,0,ln)));const k=yr().encode(guardedSplice(r,0,ln)),I=decodeLength(r),we=[];for(let e=0;e<I;e++){const e=guardedShift(r),n=guardedSplice(r,0,decodeLength(r)),i=decodeLength(r),s=new Uint8Array(guardedSplice(r,0,i));we.push({programIdIndex:e,accountKeyIndexes:n,data:s})}const Ae=decodeLength(r),Ce=[];for(let e=0;e<Ae;e++){const e=new PublicKey(guardedSplice(r,0,ln)),n=guardedSplice(r,0,decodeLength(r)),i=guardedSplice(r,0,decodeLength(r));Ce.push({accountKey:e,writableIndexes:n,readonlyIndexes:i})}return new MessageV0({header:s,staticAccountKeys:a,recentBlockhash:k,compiledInstructions:we,addressTableLookups:Ce})}}const In={deserializeMessageVersion(e){const r=e[0],n=r&yn;return n===r?"legacy":n},deserialize:e=>{const r=In.deserializeMessageVersion(e);if("legacy"===r)return Message.from(e);if(0===r)return MessageV0.deserialize(e);throw new Error(`Transaction message version ${r} deserialization is not supported`)}};let Cn=function(e){return e[e.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",e[e.PROCESSED=1]="PROCESSED",e[e.TIMED_OUT=2]="TIMED_OUT",e[e.NONCE_INVALID=3]="NONCE_INVALID",e}({});const Bn=s.Buffer.alloc(bn).fill(0);class TransactionInstruction{constructor(e){this.keys=void 0,this.programId=void 0,this.data=s.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map((({pubkey:e,isSigner:r,isWritable:n})=>({pubkey:e.toJSON(),isSigner:r,isWritable:n}))),programId:this.programId.toJSON(),data:[...this.data]}}}class Transaction{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:r,nonceInfo:n}=e;this.minNonceContextSlot=r,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:r,lastValidBlockHeight:n}=e;this.recentBlockhash=r,this.lastValidBlockHeight=n}else{const{recentBlockhash:r,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=r}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map((e=>e.toJSON())),signers:this.signatures.map((({publicKey:e})=>e.toJSON()))}}add(...e){if(0===e.length)throw new Error("No instructions");return e.forEach((e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new TransactionInstruction(e))})),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,r,n;if(this.nonceInfo?(e=this.nonceInfo.nonce,r=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(e=this.recentBlockhash,r=this.instructions),!e)throw new Error("Transaction recentBlockhash required");if(r.length<1&&console.warn("No instructions provided"),this.feePayer)n=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");n=this.signatures[0].publicKey}for(let e=0;e<r.length;e++)if(void 0===r[e].programId)throw new Error(`Transaction instruction index ${e} has undefined program id`);const i=[],s=[];r.forEach((e=>{e.keys.forEach((e=>{s.push({...e})}));const r=e.programId.toString();i.includes(r)||i.push(r)})),i.forEach((e=>{s.push({pubkey:new PublicKey(e),isSigner:!1,isWritable:!1})}));const a=[];s.forEach((e=>{const r=e.pubkey.toString(),n=a.findIndex((e=>e.pubkey.toString()===r));n>-1?(a[n].isWritable=a[n].isWritable||e.isWritable,a[n].isSigner=a[n].isSigner||e.isSigner):a.push(e)})),a.sort((function(e,r){if(e.isSigner!==r.isSigner)return e.isSigner?-1:1;if(e.isWritable!==r.isWritable)return e.isWritable?-1:1;return e.pubkey.toBase58().localeCompare(r.pubkey.toBase58(),"en",{localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"})}));const w=a.findIndex((e=>e.pubkey.equals(n)));if(w>-1){const[e]=a.splice(w,1);e.isSigner=!0,e.isWritable=!0,a.unshift(e)}else a.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const e of this.signatures){const r=a.findIndex((r=>r.pubkey.equals(e.publicKey)));if(!(r>-1))throw new Error(`unknown signer: ${e.publicKey.toString()}`);a[r].isSigner||(a[r].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))}let k=0,I=0,we=0;const Ae=[],Ce=[];a.forEach((({pubkey:e,isSigner:r,isWritable:n})=>{r?(Ae.push(e.toString()),k+=1,n||(I+=1)):(Ce.push(e.toString()),n||(we+=1))}));const Be=Ae.concat(Ce),ze=r.map((e=>{const{data:r,programId:n}=e;return{programIdIndex:Be.indexOf(n.toString()),accounts:e.keys.map((e=>Be.indexOf(e.pubkey.toString()))),data:yr().encode(r)}}));return ze.forEach((e=>{index_browser_esm_assert(e.programIdIndex>=0),e.accounts.forEach((e=>index_browser_esm_assert(e>=0)))})),new Message({header:{numRequiredSignatures:k,numReadonlySignedAccounts:I,numReadonlyUnsignedAccounts:we},accountKeys:Be,recentBlockhash:e,instructions:ze})}_compile(){const e=this.compileMessage(),r=e.accountKeys.slice(0,e.header.numRequiredSignatures);if(this.signatures.length===r.length){if(this.signatures.every(((e,n)=>r[n].equals(e.publicKey))))return e}return this.signatures=r.map((e=>({signature:null,publicKey:e}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(0===e.length)throw new Error("No signers");const r=new Set;this.signatures=e.filter((e=>{const n=e.toString();return!r.has(n)&&(r.add(n),!0)})).map((e=>({signature:null,publicKey:e})))}sign(...e){if(0===e.length)throw new Error("No signers");const r=new Set,n=[];for(const i of e){const e=i.publicKey.toString();r.has(e)||(r.add(e),n.push(i))}this.signatures=n.map((e=>({signature:null,publicKey:e.publicKey})));const i=this._compile();this._partialSign(i,...n)}partialSign(...e){if(0===e.length)throw new Error("No signers");const r=new Set,n=[];for(const i of e){const e=i.publicKey.toString();r.has(e)||(r.add(e),n.push(i))}const i=this._compile();this._partialSign(i,...n)}_partialSign(e,...r){const n=e.serialize();r.forEach((e=>{const r=sign(n,e.secretKey);this._addSignature(e.publicKey,toBuffer(r))}))}addSignature(e,r){this._compile(),this._addSignature(e,r)}_addSignature(e,r){index_browser_esm_assert(64===r.length);const n=this.signatures.findIndex((r=>e.equals(r.publicKey)));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=s.Buffer.from(r)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,r){const n={};for(const{signature:i,publicKey:s}of this.signatures)null===i?r&&(n.missing||=[]).push(s):an(i,e,s.toBytes())||(n.invalid||=[]).push(s);return n.invalid||n.missing?n:void 0}serialize(e){const{requireAllSignatures:r,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),i=this.serializeMessage();if(n){const e=this._getMessageSignednessErrors(i,r);if(e){let r="Signature verification failed.";throw e.invalid&&(r+=`\nInvalid signature for public key${1===e.invalid.length?"":"(s)"} [\`${e.invalid.map((e=>e.toBase58())).join("`, `")}\`].`),e.missing&&(r+=`\nMissing signature for public key${1===e.missing.length?"":"(s)"} [\`${e.missing.map((e=>e.toBase58())).join("`, `")}\`].`),new Error(r)}}return this._serialize(i)}_serialize(e){const{signatures:r}=this,n=[];encodeLength(n,r.length);const i=n.length+64*r.length+e.length,a=s.Buffer.alloc(i);return index_browser_esm_assert(r.length<256),s.Buffer.from(n).copy(a,0),r.forEach((({signature:e},r)=>{null!==e&&(index_browser_esm_assert(64===e.length,"signature has invalid length"),s.Buffer.from(e).copy(a,n.length+64*r))})),e.copy(a,n.length+64*r.length),index_browser_esm_assert(a.length<=mn,`Transaction too large: ${a.length} > ${mn}`),a}get keys(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].keys.map((e=>e.pubkey))}get programId(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].programId}get data(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].data}static from(e){let r=[...e];const n=decodeLength(r);let i=[];for(let e=0;e<n;e++){const e=guardedSplice(r,0,bn);i.push(yr().encode(s.Buffer.from(e)))}return Transaction.populate(Message.from(r),i)}static populate(e,r=[]){const n=new Transaction;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),r.forEach(((r,i)=>{const s={signature:r==yr().encode(Bn)?null:yr().decode(r),publicKey:e.accountKeys[i]};n.signatures.push(s)})),e.instructions.forEach((r=>{const i=r.accounts.map((r=>{const i=e.accountKeys[r];return{pubkey:i,isSigner:n.signatures.some((e=>e.publicKey.toString()===i.toString()))||e.isAccountSigner(r),isWritable:e.isAccountWritable(r)}}));n.instructions.push(new TransactionInstruction({keys:i,programId:e.accountKeys[r.programIdIndex],data:yr().decode(r.data)}))})),n._message=e,n._json=n.toJSON(),n}}class TransactionMessage{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,r){const{header:n,compiledInstructions:i,recentBlockhash:s}=e,{numRequiredSignatures:a,numReadonlySignedAccounts:w,numReadonlyUnsignedAccounts:k}=n,I=a-w;index_browser_esm_assert(I>0,"Message header is invalid");const we=e.staticAccountKeys.length-a-k;index_browser_esm_assert(we>=0,"Message header is invalid");const Ae=e.getAccountKeys(r),Ce=Ae.get(0);if(void 0===Ce)throw new Error("Failed to decompile message because no account keys were found");const Be=[];for(const e of i){const r=[];for(const i of e.accountKeyIndexes){const e=Ae.get(i);if(void 0===e)throw new Error(`Failed to find key for account key index ${i}`);let s;s=i<a?i<I:i<Ae.staticAccountKeys.length?i-a<we:i-Ae.staticAccountKeys.length<Ae.accountKeysFromLookups.writable.length,r.push({pubkey:e,isSigner:i<n.numRequiredSignatures,isWritable:s})}const i=Ae.get(e.programIdIndex);if(void 0===i)throw new Error(`Failed to find program id for program id index ${e.programIdIndex}`);Be.push(new TransactionInstruction({programId:i,data:toBuffer(e.data),keys:r}))}return new TransactionMessage({payerKey:Ce,instructions:Be,recentBlockhash:s})}compileToLegacyMessage(){return Message.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return MessageV0.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class VersionedTransaction{get version(){return this.message.version}constructor(e,r){if(this.signatures=void 0,this.message=void 0,void 0!==r)index_browser_esm_assert(r.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=r;else{const r=[];for(let n=0;n<e.header.numRequiredSignatures;n++)r.push(new Uint8Array(bn));this.signatures=r}this.message=e}serialize(){const e=this.message.serialize(),r=Array();encodeLength(r,this.signatures.length);const n=kr.struct([kr.blob(r.length,"encodedSignaturesLength"),kr.seq(signature(),this.signatures.length,"signatures"),kr.blob(e.length,"serializedMessage")]),i=new Uint8Array(2048),s=n.encode({encodedSignaturesLength:new Uint8Array(r),signatures:this.signatures,serializedMessage:e},i);return i.slice(0,s)}static deserialize(e){let r=[...e];const n=[],i=decodeLength(r);for(let e=0;e<i;e++)n.push(new Uint8Array(guardedSplice(r,0,bn)));const s=In.deserialize(new Uint8Array(r));return new VersionedTransaction(s,n)}sign(e){const r=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const i of e){const e=n.findIndex((e=>e.equals(i.publicKey)));index_browser_esm_assert(e>=0,`Cannot sign with non signer key ${i.publicKey.toBase58()}`),this.signatures[e]=sign(r,i.secretKey)}}addSignature(e,r){index_browser_esm_assert(64===r.byteLength,"Signature must be 64 bytes long");const n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex((r=>r.equals(e)));index_browser_esm_assert(n>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[n]=r}}const Mn=new PublicKey("SysvarC1ock11111111111111111111111111111111"),Wn=new PublicKey("SysvarEpochSchedu1e111111111111111111111111"),Hn=new PublicKey("Sysvar1nstructions1111111111111111111111111"),Zn=new PublicKey("SysvarRecentB1ockHashes11111111111111111111"),Qn=new PublicKey("SysvarRent111111111111111111111111111111111"),ei=new PublicKey("SysvarRewards111111111111111111111111111111"),ti=new PublicKey("SysvarS1otHashes111111111111111111111111111"),ri=new PublicKey("SysvarS1otHistory11111111111111111111111111"),ni=new PublicKey("SysvarStakeHistory1111111111111111111111111");async function sendAndConfirmTransaction(e,r,n,i){const s=i&&{skipPreflight:i.skipPreflight,preflightCommitment:i.preflightCommitment||i.commitment,maxRetries:i.maxRetries,minContextSlot:i.minContextSlot},a=await e.sendTransaction(r,n,s);let w;if(null!=r.recentBlockhash&&null!=r.lastValidBlockHeight)w=(await e.confirmTransaction({abortSignal:i?.abortSignal,signature:a,blockhash:r.recentBlockhash,lastValidBlockHeight:r.lastValidBlockHeight},i&&i.commitment)).value;else if(null!=r.minNonceContextSlot&&null!=r.nonceInfo){const{nonceInstruction:n}=r.nonceInfo,s=n.keys[0].pubkey;w=(await e.confirmTransaction({abortSignal:i?.abortSignal,minContextSlot:r.minNonceContextSlot,nonceAccountPubkey:s,nonceValue:r.nonceInfo.nonce,signature:a},i&&i.commitment)).value}else null!=i?.abortSignal&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),w=(await e.confirmTransaction(a,i&&i.commitment)).value;if(w.err)throw new Error(`Transaction ${a} failed (${JSON.stringify(w)})`);return a}function sleep(e){return new Promise((r=>setTimeout(r,e)))}function encodeData(e,r){const n=e.layout.span>=0?e.layout.span:getAlloc(e,r),i=s.Buffer.alloc(n),a=Object.assign({instruction:e.index},r);return e.layout.encode(a,i),i}function decodeData$1(e,r){let n;try{n=e.layout.decode(r)}catch(e){throw new Error("invalid instruction; "+e)}if(n.instruction!==e.index)throw new Error(`invalid instruction; instruction index mismatch ${n.instruction} != ${e.index}`);return n}const ii=kr.nu64("lamportsPerSignature"),oi=kr.struct([kr.u32("version"),kr.u32("state"),publicKey("authorizedPubkey"),publicKey("nonce"),kr.struct([ii],"feeCalculator")]),si=oi.span;class NonceAccount{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const r=oi.decode(toBuffer(e),0);return new NonceAccount({authorizedPubkey:new PublicKey(r.authorizedPubkey),nonce:new PublicKey(r.nonce).toString(),feeCalculator:r.feeCalculator})}}const ai=(ci=8,e=>{const r=(0,kr.blob)(ci,e),{encode:n,decode:i}=(e=>({decode:e.decode.bind(e),encode:e.encode.bind(e)}))(r),a=r;return a.decode=(e,r)=>{const n=i(e,r);return(0,Ar.toBigIntLE)(s.Buffer.from(n))},a.encode=(e,r,i)=>{const s=(0,Ar.toBufferLE)(e,ci);return n(s,r,i)},a});var ci;class SystemInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=kr.u32("instruction").decode(e.data);let n;for(const[e,i]of Object.entries(ui))if(i.index==r){n=e;break}if(!n)throw new Error("Instruction type incorrect; not a SystemInstruction");return n}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:r,space:n,programId:i}=decodeData$1(ui.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:r,space:n,programId:new PublicKey(i)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:r}=decodeData$1(ui.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:r}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:r,seed:n,programId:i}=decodeData$1(ui.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:r,seed:n,programId:new PublicKey(i)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:r}=decodeData$1(ui.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:r}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:r,seed:n,space:i,programId:s}=decodeData$1(ui.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new PublicKey(r),seed:n,space:i,programId:new PublicKey(s)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:r}=decodeData$1(ui.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new PublicKey(r)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:r,seed:n,programId:i}=decodeData$1(ui.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new PublicKey(r),seed:n,programId:new PublicKey(i)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:r,seed:n,lamports:i,space:s,programId:a}=decodeData$1(ui.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new PublicKey(r),seed:n,lamports:i,space:s,programId:new PublicKey(a)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:r}=decodeData$1(ui.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new PublicKey(r)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),decodeData$1(ui.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:r}=decodeData$1(ui.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:r}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:r}=decodeData$1(ui.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new PublicKey(r)}}static checkProgramId(e){if(!e.equals(SystemProgram.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,r){if(e.length<r)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${r}`)}}const ui=Object.freeze({Create:{index:0,layout:kr.struct([kr.u32("instruction"),kr.ns64("lamports"),kr.ns64("space"),publicKey("programId")])},Assign:{index:1,layout:kr.struct([kr.u32("instruction"),publicKey("programId")])},Transfer:{index:2,layout:kr.struct([kr.u32("instruction"),ai("lamports")])},CreateWithSeed:{index:3,layout:kr.struct([kr.u32("instruction"),publicKey("base"),rustString("seed"),kr.ns64("lamports"),kr.ns64("space"),publicKey("programId")])},AdvanceNonceAccount:{index:4,layout:kr.struct([kr.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:kr.struct([kr.u32("instruction"),kr.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:kr.struct([kr.u32("instruction"),publicKey("authorized")])},AuthorizeNonceAccount:{index:7,layout:kr.struct([kr.u32("instruction"),publicKey("authorized")])},Allocate:{index:8,layout:kr.struct([kr.u32("instruction"),kr.ns64("space")])},AllocateWithSeed:{index:9,layout:kr.struct([kr.u32("instruction"),publicKey("base"),rustString("seed"),kr.ns64("space"),publicKey("programId")])},AssignWithSeed:{index:10,layout:kr.struct([kr.u32("instruction"),publicKey("base"),rustString("seed"),publicKey("programId")])},TransferWithSeed:{index:11,layout:kr.struct([kr.u32("instruction"),ai("lamports"),rustString("seed"),publicKey("programId")])},UpgradeNonceAccount:{index:12,layout:kr.struct([kr.u32("instruction")])}});class SystemProgram{constructor(){}static createAccount(e){const r=encodeData(ui.Create,{lamports:e.lamports,space:e.space,programId:toBuffer(e.programId.toBuffer())});return new TransactionInstruction({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(e){let r,n;if("basePubkey"in e){r=encodeData(ui.TransferWithSeed,{lamports:BigInt(e.lamports),seed:e.seed,programId:toBuffer(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{r=encodeData(ui.Transfer,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new TransactionInstruction({keys:n,programId:this.programId,data:r})}static assign(e){let r,n;if("basePubkey"in e){r=encodeData(ui.AssignWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,programId:toBuffer(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{r=encodeData(ui.Assign,{programId:toBuffer(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:n,programId:this.programId,data:r})}static createAccountWithSeed(e){const r=encodeData(ui.CreateWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:toBuffer(e.programId.toBuffer())});let n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&n.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new TransactionInstruction({keys:n,programId:this.programId,data:r})}static createNonceAccount(e){const r=new Transaction;"basePubkey"in e&&"seed"in e?r.add(SystemProgram.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:si,programId:this.programId})):r.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:si,programId:this.programId}));const n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return r.add(this.nonceInitialize(n)),r}static nonceInitialize(e){const r=encodeData(ui.InitializeNonceAccount,{authorized:toBuffer(e.authorizedPubkey.toBuffer())}),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Zn,isSigner:!1,isWritable:!1},{pubkey:Qn,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new TransactionInstruction(n)}static nonceAdvance(e){const r=encodeData(ui.AdvanceNonceAccount),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Zn,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new TransactionInstruction(n)}static nonceWithdraw(e){const r=encodeData(ui.WithdrawNonceAccount,{lamports:e.lamports});return new TransactionInstruction({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Zn,isSigner:!1,isWritable:!1},{pubkey:Qn,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(e){const r=encodeData(ui.AuthorizeNonceAccount,{authorized:toBuffer(e.newAuthorizedPubkey.toBuffer())});return new TransactionInstruction({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(e){let r,n;if("basePubkey"in e){r=encodeData(ui.AllocateWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:toBuffer(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{r=encodeData(ui.Allocate,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:n,programId:this.programId,data:r})}}SystemProgram.programId=new PublicKey("11111111111111111111111111111111");const di=mn-300;class Loader{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/Loader.chunkSize)+1+1)}static async load(e,r,n,i,a){{const s=await e.getMinimumBalanceForRentExemption(a.length),w=await e.getAccountInfo(n.publicKey,"confirmed");let k=null;if(null!==w){if(w.executable)return console.error("Program load failed, account is already executable"),!1;w.data.length!==a.length&&(k=k||new Transaction,k.add(SystemProgram.allocate({accountPubkey:n.publicKey,space:a.length}))),w.owner.equals(i)||(k=k||new Transaction,k.add(SystemProgram.assign({accountPubkey:n.publicKey,programId:i}))),w.lamports<s&&(k=k||new Transaction,k.add(SystemProgram.transfer({fromPubkey:r.publicKey,toPubkey:n.publicKey,lamports:s-w.lamports})))}else k=(new Transaction).add(SystemProgram.createAccount({fromPubkey:r.publicKey,newAccountPubkey:n.publicKey,lamports:s>0?s:1,space:a.length,programId:i}));null!==k&&await sendAndConfirmTransaction(e,k,[r,n],{commitment:"confirmed"})}const w=kr.struct([kr.u32("instruction"),kr.u32("offset"),kr.u32("bytesLength"),kr.u32("bytesLengthPadding"),kr.seq(kr.u8("byte"),kr.offset(kr.u32(),-8),"bytes")]),k=Loader.chunkSize;let I=0,we=a,Ae=[];for(;we.length>0;){const a=we.slice(0,k),Ce=s.Buffer.alloc(k+16);w.encode({instruction:0,offset:I,bytes:a,bytesLength:0,bytesLengthPadding:0},Ce);const Be=(new Transaction).add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0}],programId:i,data:Ce});if(Ae.push(sendAndConfirmTransaction(e,Be,[r,n],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")){const e=4;await sleep(1e3/e)}I+=k,we=we.slice(k)}await Promise.all(Ae);{const a=kr.struct([kr.u32("instruction")]),w=s.Buffer.alloc(a.span);a.encode({instruction:1},w);const k=(new Transaction).add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0},{pubkey:Qn,isSigner:!1,isWritable:!1}],programId:i,data:w}),I="processed",we=await e.sendTransaction(k,[r,n],{preflightCommitment:I}),{context:Ae,value:Ce}=await e.confirmTransaction({signature:we,lastValidBlockHeight:k.lastValidBlockHeight,blockhash:k.recentBlockhash},I);if(Ce.err)throw new Error(`Transaction ${we} failed (${JSON.stringify(Ce)})`);for(;;){try{if(await e.getSlot({commitment:I})>Ae.slot)break}catch{}await new Promise((e=>setTimeout(e,Math.round(200))))}}return!0}}Loader.chunkSize=di;const li=new PublicKey("BPFLoader2111111111111111111111111111111111");class BpfLoader{static getMinNumSignatures(e){return Loader.getMinNumSignatures(e)}static load(e,r,n,i,s){return Loader.load(e,r,n,s,i)}}function getDefaultExportFromCjs(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var hi=Object.prototype.toString,fi=Object.keys||function(e){var r=[];for(var n in e)r.push(n);return r};function stringify(e,r){var n,i,s,a,w,k,I;if(!0===e)return"true";if(!1===e)return"false";switch(typeof e){case"object":if(null===e)return null;if(e.toJSON&&"function"==typeof e.toJSON)return stringify(e.toJSON(),r);if("[object Array]"===(I=hi.call(e))){for(s="[",i=e.length-1,n=0;n<i;n++)s+=stringify(e[n],!0)+",";return i>-1&&(s+=stringify(e[n],!0)),s+"]"}if("[object Object]"===I){for(i=(a=fi(e).sort()).length,s="",n=0;n<i;)void 0!==(k=stringify(e[w=a[n]],!1))&&(s&&(s+=","),s+=JSON.stringify(w)+":"+k),n++;return"{"+s+"}"}return JSON.stringify(e);case"function":case"undefined":return r?null:void 0;case"string":return JSON.stringify(e);default:return isFinite(e)?e:null}}var gi=getDefaultExportFromCjs((function(e){var r=stringify(e,!1);if(void 0!==r)return""+r}));function trailingZeros(e){let r=0;for(;e>1;)e/=2,r++;return r}class EpochSchedule{constructor(e,r,n,i,s){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=r,this.warmup=n,this.firstNormalEpoch=i,this.firstNormalSlot=s}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const r=trailingZeros(function nextPowerOfTwo(e){return 0===e?1:(e--,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,e|=e>>16,1+(e|=e>>32))}(e+32+1))-trailingZeros(32)-1;return[r,e-(this.getSlotsInEpoch(r)-32)]}{const r=e-this.firstNormalSlot,n=Math.floor(r/this.slotsPerEpoch);return[this.firstNormalEpoch+n,r%this.slotsPerEpoch]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?32*(Math.pow(2,e)-1):(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+trailingZeros(32)):this.slotsPerEpoch}}class SendTransactionError extends Error{constructor(e,r){super(e),this.logs=void 0,this.logs=r}}const pi={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class SolanaJSONRPCError extends Error{constructor({code:e,message:r,data:n},i){super(null!=i?`${i}: ${r}`:r),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}var mi=globalThis.fetch;class RpcWebSocketClient extends vr.A{constructor(e,r,n){super((e=>{const n=(0,Or.A)(e,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...r});return this.underlyingSocket="socket"in n?n.socket:n,n}),e,r,n),this.underlyingSocket=void 0}call(...e){const r=this.underlyingSocket?.readyState;return 1===r?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}notify(...e){const r=this.underlyingSocket?.readyState;return 1===r?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}}class AddressLookupTableAccount{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const r=function decodeData(e,r){let n;try{n=e.layout.decode(r)}catch(e){throw new Error("invalid instruction; "+e)}if(n.typeIndex!==e.index)throw new Error(`invalid account data; account type mismatch ${n.typeIndex} != ${e.index}`);return n}(yi,e),n=e.length-56;index_browser_esm_assert(n>=0,"lookup table is invalid"),index_browser_esm_assert(n%32==0,"lookup table is invalid");const i=n/32,{addresses:s}=kr.struct([kr.seq(publicKey(),i,"addresses")]).decode(e.slice(56));return{deactivationSlot:r.deactivationSlot,lastExtendedSlot:r.lastExtendedSlot,lastExtendedSlotStartIndex:r.lastExtendedStartIndex,authority:0!==r.authority.length?new PublicKey(r.authority[0]):void 0,addresses:s.map((e=>new PublicKey(e)))}}}const yi={index:1,layout:kr.struct([kr.u32("typeIndex"),ai("deactivationSlot"),kr.nu64("lastExtendedSlot"),kr.u8("lastExtendedStartIndex"),kr.u8(),kr.seq(publicKey(),kr.offset(kr.u8(),-1),"authority")])},bi=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;const _i=coerce(instance(PublicKey),string(),(e=>new PublicKey(e))),wi=tuple([string(),literal("base64")]),Si=coerce(instance(s.Buffer),wi,(e=>s.Buffer.from(e[0],"base64"))),Ei=3e4;function extractCommitmentFromConfig(e){let r,n;if("string"==typeof e)r=e;else if(e){const{commitment:i,...s}=e;r=i,n=s}return{commitment:r,config:n}}function createRpcResult(e){return union([type({jsonrpc:literal("2.0"),id:string(),result:e}),type({jsonrpc:literal("2.0"),id:string(),error:type({code:unknown(),message:string(),data:optional(index_es_define("any",(()=>!0)))})})])}const ki=createRpcResult(unknown());function jsonRpcResult(e){return coerce(createRpcResult(e),ki,(r=>"error"in r?r:{...r,result:create(r.result,e)}))}function jsonRpcResultAndContext(e){return jsonRpcResult(type({context:type({slot:index_es_number()}),value:e}))}function notificationResultAndContext(e){return type({context:type({slot:index_es_number()}),value:e})}function versionedMessageFromResponse(e,r){return 0===e?new MessageV0({header:r.header,staticAccountKeys:r.accountKeys.map((e=>new PublicKey(e))),recentBlockhash:r.recentBlockhash,compiledInstructions:r.instructions.map((e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:yr().decode(e.data)}))),addressTableLookups:r.addressTableLookups}):new Message(r)}const Ai=type({foundation:index_es_number(),foundationTerm:index_es_number(),initial:index_es_number(),taper:index_es_number(),terminal:index_es_number()}),Ii=jsonRpcResult(array(nullable(type({epoch:index_es_number(),effectiveSlot:index_es_number(),amount:index_es_number(),postBalance:index_es_number(),commission:optional(nullable(index_es_number()))})))),Ri=array(type({slot:index_es_number(),prioritizationFee:index_es_number()})),vi=type({total:index_es_number(),validator:index_es_number(),foundation:index_es_number(),epoch:index_es_number()}),Oi=type({epoch:index_es_number(),slotIndex:index_es_number(),slotsInEpoch:index_es_number(),absoluteSlot:index_es_number(),blockHeight:optional(index_es_number()),transactionCount:optional(index_es_number())}),xi=type({slotsPerEpoch:index_es_number(),leaderScheduleSlotOffset:index_es_number(),warmup:index_es_boolean(),firstNormalEpoch:index_es_number(),firstNormalSlot:index_es_number()}),Ti=record(string(),array(index_es_number())),Ni=nullable(union([type({}),string()])),Pi=type({err:Ni}),Ci=literal("receivedSignature"),Bi=type({"solana-core":string(),"feature-set":optional(index_es_number())}),Li=jsonRpcResultAndContext(type({err:nullable(union([type({}),string()])),logs:nullable(array(string())),accounts:optional(nullable(array(nullable(type({executable:index_es_boolean(),owner:string(),lamports:index_es_number(),data:array(string()),rentEpoch:optional(index_es_number())}))))),unitsConsumed:optional(index_es_number()),returnData:optional(nullable(type({programId:string(),data:tuple([string(),literal("base64")])})))})),zi=jsonRpcResultAndContext(type({byIdentity:record(string(),array(index_es_number())),range:type({firstSlot:index_es_number(),lastSlot:index_es_number()})}));const Di=jsonRpcResult(Ai),Ki=jsonRpcResult(vi),Ui=jsonRpcResult(Ri),Mi=jsonRpcResult(Oi),Fi=jsonRpcResult(xi),Wi=jsonRpcResult(Ti),qi=jsonRpcResult(index_es_number()),Vi=jsonRpcResultAndContext(type({total:index_es_number(),circulating:index_es_number(),nonCirculating:index_es_number(),nonCirculatingAccounts:array(_i)})),ji=type({amount:string(),uiAmount:nullable(index_es_number()),decimals:index_es_number(),uiAmountString:optional(string())}),Hi=jsonRpcResultAndContext(array(type({address:_i,amount:string(),uiAmount:nullable(index_es_number()),decimals:index_es_number(),uiAmountString:optional(string())}))),$i=jsonRpcResultAndContext(array(type({pubkey:_i,account:type({executable:index_es_boolean(),owner:_i,lamports:index_es_number(),data:Si,rentEpoch:index_es_number()})}))),Yi=type({program:string(),parsed:unknown(),space:index_es_number()}),Gi=jsonRpcResultAndContext(array(type({pubkey:_i,account:type({executable:index_es_boolean(),owner:_i,lamports:index_es_number(),data:Yi,rentEpoch:index_es_number()})}))),Ji=jsonRpcResultAndContext(array(type({lamports:index_es_number(),address:_i}))),Zi=type({executable:index_es_boolean(),owner:_i,lamports:index_es_number(),data:Si,rentEpoch:index_es_number()}),Xi=type({pubkey:_i,account:Zi}),Qi=coerce(union([instance(s.Buffer),Yi]),union([wi,Yi]),(e=>Array.isArray(e)?create(e,Si):e)),eo=type({executable:index_es_boolean(),owner:_i,lamports:index_es_number(),data:Qi,rentEpoch:index_es_number()}),to=type({pubkey:_i,account:eo}),ro=type({state:union([literal("active"),literal("inactive"),literal("activating"),literal("deactivating")]),active:index_es_number(),inactive:index_es_number()}),no=jsonRpcResult(array(type({signature:string(),slot:index_es_number(),err:Ni,memo:nullable(string()),blockTime:optional(nullable(index_es_number()))}))),io=jsonRpcResult(array(type({signature:string(),slot:index_es_number(),err:Ni,memo:nullable(string()),blockTime:optional(nullable(index_es_number()))}))),oo=type({subscription:index_es_number(),result:notificationResultAndContext(Zi)}),so=type({pubkey:_i,account:Zi}),ao=type({subscription:index_es_number(),result:notificationResultAndContext(so)}),co=type({parent:index_es_number(),slot:index_es_number(),root:index_es_number()}),uo=type({subscription:index_es_number(),result:co}),lo=union([type({type:union([literal("firstShredReceived"),literal("completed"),literal("optimisticConfirmation"),literal("root")]),slot:index_es_number(),timestamp:index_es_number()}),type({type:literal("createdBank"),parent:index_es_number(),slot:index_es_number(),timestamp:index_es_number()}),type({type:literal("frozen"),slot:index_es_number(),timestamp:index_es_number(),stats:type({numTransactionEntries:index_es_number(),numSuccessfulTransactions:index_es_number(),numFailedTransactions:index_es_number(),maxTransactionsPerEntry:index_es_number()})}),type({type:literal("dead"),slot:index_es_number(),timestamp:index_es_number(),err:string()})]),ho=type({subscription:index_es_number(),result:lo}),fo=type({subscription:index_es_number(),result:notificationResultAndContext(union([Pi,Ci]))}),go=type({subscription:index_es_number(),result:index_es_number()}),po=type({pubkey:string(),gossip:nullable(string()),tpu:nullable(string()),rpc:nullable(string()),version:nullable(string())}),mo=type({votePubkey:string(),nodePubkey:string(),activatedStake:index_es_number(),epochVoteAccount:index_es_boolean(),epochCredits:array(tuple([index_es_number(),index_es_number(),index_es_number()])),commission:index_es_number(),lastVote:index_es_number(),rootSlot:nullable(index_es_number())}),yo=jsonRpcResult(type({current:array(mo),delinquent:array(mo)})),bo=union([literal("processed"),literal("confirmed"),literal("finalized")]),_o=type({slot:index_es_number(),confirmations:nullable(index_es_number()),err:Ni,confirmationStatus:optional(bo)}),wo=jsonRpcResultAndContext(array(nullable(_o))),So=jsonRpcResult(index_es_number()),Eo=type({accountKey:_i,writableIndexes:array(index_es_number()),readonlyIndexes:array(index_es_number())}),ko=type({signatures:array(string()),message:type({accountKeys:array(string()),header:type({numRequiredSignatures:index_es_number(),numReadonlySignedAccounts:index_es_number(),numReadonlyUnsignedAccounts:index_es_number()}),instructions:array(type({accounts:array(index_es_number()),data:string(),programIdIndex:index_es_number()})),recentBlockhash:string(),addressTableLookups:optional(array(Eo))})}),Ao=type({pubkey:_i,signer:index_es_boolean(),writable:index_es_boolean(),source:optional(union([literal("transaction"),literal("lookupTable")]))}),Io=type({accountKeys:array(Ao),signatures:array(string())}),Ro=type({parsed:unknown(),program:string(),programId:_i}),vo=type({accounts:array(_i),data:string(),programId:_i}),Oo=coerce(union([vo,Ro]),union([type({parsed:unknown(),program:string(),programId:string()}),type({accounts:array(string()),data:string(),programId:string()})]),(e=>create(e,"accounts"in e?vo:Ro))),xo=type({signatures:array(string()),message:type({accountKeys:array(Ao),instructions:array(Oo),recentBlockhash:string(),addressTableLookups:optional(nullable(array(Eo)))})}),To=type({accountIndex:index_es_number(),mint:string(),owner:optional(string()),uiTokenAmount:ji}),No=type({writable:array(_i),readonly:array(_i)}),Po=type({err:Ni,fee:index_es_number(),innerInstructions:optional(nullable(array(type({index:index_es_number(),instructions:array(type({accounts:array(index_es_number()),data:string(),programIdIndex:index_es_number()}))})))),preBalances:array(index_es_number()),postBalances:array(index_es_number()),logMessages:optional(nullable(array(string()))),preTokenBalances:optional(nullable(array(To))),postTokenBalances:optional(nullable(array(To))),loadedAddresses:optional(No),computeUnitsConsumed:optional(index_es_number())}),Co=type({err:Ni,fee:index_es_number(),innerInstructions:optional(nullable(array(type({index:index_es_number(),instructions:array(Oo)})))),preBalances:array(index_es_number()),postBalances:array(index_es_number()),logMessages:optional(nullable(array(string()))),preTokenBalances:optional(nullable(array(To))),postTokenBalances:optional(nullable(array(To))),loadedAddresses:optional(No),computeUnitsConsumed:optional(index_es_number())}),Bo=union([literal(0),literal("legacy")]),Lo=type({pubkey:string(),lamports:index_es_number(),postBalance:nullable(index_es_number()),rewardType:nullable(string()),commission:optional(nullable(index_es_number()))}),zo=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:index_es_number(),transactions:array(type({transaction:ko,meta:nullable(Po),version:optional(Bo)})),rewards:optional(array(Lo)),blockTime:nullable(index_es_number()),blockHeight:nullable(index_es_number())}))),Do=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:index_es_number(),rewards:optional(array(Lo)),blockTime:nullable(index_es_number()),blockHeight:nullable(index_es_number())}))),Ko=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:index_es_number(),transactions:array(type({transaction:Io,meta:nullable(Po),version:optional(Bo)})),rewards:optional(array(Lo)),blockTime:nullable(index_es_number()),blockHeight:nullable(index_es_number())}))),Uo=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:index_es_number(),transactions:array(type({transaction:xo,meta:nullable(Co),version:optional(Bo)})),rewards:optional(array(Lo)),blockTime:nullable(index_es_number()),blockHeight:nullable(index_es_number())}))),Mo=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:index_es_number(),transactions:array(type({transaction:Io,meta:nullable(Co),version:optional(Bo)})),rewards:optional(array(Lo)),blockTime:nullable(index_es_number()),blockHeight:nullable(index_es_number())}))),Fo=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:index_es_number(),rewards:optional(array(Lo)),blockTime:nullable(index_es_number()),blockHeight:nullable(index_es_number())}))),Wo=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:index_es_number(),transactions:array(type({transaction:ko,meta:nullable(Po)})),rewards:optional(array(Lo)),blockTime:nullable(index_es_number())}))),qo=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:index_es_number(),signatures:array(string()),blockTime:nullable(index_es_number())}))),Vo=jsonRpcResult(nullable(type({slot:index_es_number(),meta:nullable(Po),blockTime:optional(nullable(index_es_number())),transaction:ko,version:optional(Bo)}))),jo=jsonRpcResult(nullable(type({slot:index_es_number(),transaction:xo,meta:nullable(Co),blockTime:optional(nullable(index_es_number())),version:optional(Bo)}))),Ho=jsonRpcResultAndContext(type({blockhash:string(),feeCalculator:type({lamportsPerSignature:index_es_number()})})),$o=jsonRpcResultAndContext(type({blockhash:string(),lastValidBlockHeight:index_es_number()})),Yo=jsonRpcResultAndContext(index_es_boolean()),Go=jsonRpcResult(array(type({slot:index_es_number(),numTransactions:index_es_number(),numSlots:index_es_number(),samplePeriodSecs:index_es_number()}))),Jo=jsonRpcResultAndContext(nullable(type({feeCalculator:type({lamportsPerSignature:index_es_number()})}))),Zo=jsonRpcResult(string()),Xo=jsonRpcResult(string()),Qo=type({err:Ni,logs:array(string()),signature:string()}),es=type({result:notificationResultAndContext(Qo),subscription:index_es_number()}),ts={"solana-client":"js/0.0.0-development"};class Connection{constructor(e,r){let n,i,s,a,w,k;this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const e={};return async r=>{const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgs([],n,void 0,i),a=gi(s);return e[a]=e[a]??(async()=>{try{const e=create(await this._rpcRequest("getBlockHeight",s),jsonRpcResult(index_es_number()));if("error"in e)throw new SolanaJSONRPCError(e.error,"failed to get block height information");return e.result}finally{delete e[a]}})(),await e[a]}})(),r&&"string"==typeof r?this._commitment=r:r&&(this._commitment=r.commitment,this._confirmTransactionInitialTimeout=r.confirmTransactionInitialTimeout,n=r.wsEndpoint,i=r.httpHeaders,s=r.fetch,a=r.fetchMiddleware,w=r.disableRetryOnRateLimit,k=r.httpAgent),this._rpcEndpoint=function assertEndpointUrl(e){if(!1===/^https?:/.test(e))throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return e}(e),this._rpcWsEndpoint=n||function makeWebsocketUrl(e){const r=e.match(bi);if(null==r)throw TypeError(`Failed to validate endpoint URL \`${e}\``);const[n,i,s,a]=r,w=e.startsWith("https:")?"wss:":"ws:",k=null==s?null:parseInt(s.slice(1),10);return`${w}//${i}${null==k?"":`:${k+1}`}${a}`}(e),this._rpcClient=function createRpcClient(e,r,n,i,s,a){const w=n||mi;let k;return null!=a&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments."),i&&(k=async(e,r)=>{const n=await new Promise(((n,s)=>{try{i(e,r,((e,r)=>n([e,r])))}catch(e){s(e)}}));return await w(...n)}),new(Rr())((async(n,i)=>{const a={method:"POST",body:n,agent:void 0,headers:Object.assign({"Content-Type":"application/json"},r||{},ts)};try{let r,n=5,I=500;for(;r=k?await k(e,a):await w(e,a),429===r.status&&!0!==s&&(n-=1,0!==n);)console.error(`Server responded with ${r.status} ${r.statusText}.  Retrying after ${I}ms delay...`),await sleep(I),I*=2;const we=await r.text();r.ok?i(null,we):i(new Error(`${r.status} ${r.statusText}: ${we}`))}catch(e){e instanceof Error&&i(e)}}),{})}(e,i,s,a,w,k),this._rpcRequest=function createRpcRequest(e){return(r,n)=>new Promise(((i,s)=>{e.request(r,n,((e,r)=>{e?s(e):i(r)}))}))}(this._rpcClient),this._rpcBatchRequest=function createRpcBatchRequest(e){return r=>new Promise(((n,i)=>{0===r.length&&n([]);const s=r.map((r=>e.request(r.methodName,r.args)));e.request(s,((e,r)=>{e?i(e):n(r)}))}))}(this._rpcClient),this._rpcWebSocket=new RpcWebSocketClient(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgs([e.toBase58()],n,void 0,i),a=create(await this._rpcRequest("getBalance",s),jsonRpcResultAndContext(index_es_number()));if("error"in a)throw new SolanaJSONRPCError(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,r){return await this.getBalanceAndContext(e,r).then((e=>e.value)).catch((r=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+r)}))}async getBlockTime(e){const r=create(await this._rpcRequest("getBlockTime",[e]),jsonRpcResult(nullable(index_es_number())));if("error"in r)throw new SolanaJSONRPCError(r.error,`failed to get block time for slot ${e}`);return r.result}async getMinimumLedgerSlot(){const e=create(await this._rpcRequest("minimumLedgerSlot",[]),jsonRpcResult(index_es_number()));if("error"in e)throw new SolanaJSONRPCError(e.error,"failed to get minimum ledger slot");return e.result}async getFirstAvailableBlock(){const e=create(await this._rpcRequest("getFirstAvailableBlock",[]),qi);if("error"in e)throw new SolanaJSONRPCError(e.error,"failed to get first available block");return e.result}async getSupply(e){let r={};r="string"==typeof e?{commitment:e}:e?{...e,commitment:e&&e.commitment||this.commitment}:{commitment:this.commitment};const n=create(await this._rpcRequest("getSupply",[r]),Vi);if("error"in n)throw new SolanaJSONRPCError(n.error,"failed to get supply");return n.result}async getTokenSupply(e,r){const n=this._buildArgs([e.toBase58()],r),i=create(await this._rpcRequest("getTokenSupply",n),jsonRpcResultAndContext(ji));if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get token supply");return i.result}async getTokenAccountBalance(e,r){const n=this._buildArgs([e.toBase58()],r),i=create(await this._rpcRequest("getTokenAccountBalance",n),jsonRpcResultAndContext(ji));if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get token account balance");return i.result}async getTokenAccountsByOwner(e,r,n){const{commitment:i,config:s}=extractCommitmentFromConfig(n);let a=[e.toBase58()];"mint"in r?a.push({mint:r.mint.toBase58()}):a.push({programId:r.programId.toBase58()});const w=this._buildArgs(a,i,"base64",s),k=create(await this._rpcRequest("getTokenAccountsByOwner",w),$i);if("error"in k)throw new SolanaJSONRPCError(k.error,`failed to get token accounts owned by account ${e.toBase58()}`);return k.result}async getParsedTokenAccountsByOwner(e,r,n){let i=[e.toBase58()];"mint"in r?i.push({mint:r.mint.toBase58()}):i.push({programId:r.programId.toBase58()});const s=this._buildArgs(i,n,"jsonParsed"),a=create(await this._rpcRequest("getTokenAccountsByOwner",s),Gi);if("error"in a)throw new SolanaJSONRPCError(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const r={...e,commitment:e&&e.commitment||this.commitment},n=r.filter||r.commitment?[r]:[],i=create(await this._rpcRequest("getLargestAccounts",n),Ji);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get largest accounts");return i.result}async getTokenLargestAccounts(e,r){const n=this._buildArgs([e.toBase58()],r),i=create(await this._rpcRequest("getTokenLargestAccounts",n),Hi);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get token largest accounts");return i.result}async getAccountInfoAndContext(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgs([e.toBase58()],n,"base64",i),a=create(await this._rpcRequest("getAccountInfo",s),jsonRpcResultAndContext(nullable(Zi)));if("error"in a)throw new SolanaJSONRPCError(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgs([e.toBase58()],n,"jsonParsed",i),a=create(await this._rpcRequest("getAccountInfo",s),jsonRpcResultAndContext(nullable(eo)));if("error"in a)throw new SolanaJSONRPCError(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,r){try{return(await this.getAccountInfoAndContext(e,r)).value}catch(r){throw new Error("failed to get info about account "+e.toBase58()+": "+r)}}async getMultipleParsedAccounts(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=e.map((e=>e.toBase58())),a=this._buildArgs([s],n,"jsonParsed",i),w=create(await this._rpcRequest("getMultipleAccounts",a),jsonRpcResultAndContext(array(nullable(eo))));if("error"in w)throw new SolanaJSONRPCError(w.error,`failed to get info for accounts ${s}`);return w.result}async getMultipleAccountsInfoAndContext(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=e.map((e=>e.toBase58())),a=this._buildArgs([s],n,"base64",i),w=create(await this._rpcRequest("getMultipleAccounts",a),jsonRpcResultAndContext(array(nullable(Zi))));if("error"in w)throw new SolanaJSONRPCError(w.error,`failed to get info for accounts ${s}`);return w.result}async getMultipleAccountsInfo(e,r){return(await this.getMultipleAccountsInfoAndContext(e,r)).value}async getStakeActivation(e,r,n){const{commitment:i,config:s}=extractCommitmentFromConfig(r),a=this._buildArgs([e.toBase58()],i,void 0,{...s,epoch:null!=n?n:s?.epoch}),w=create(await this._rpcRequest("getStakeActivation",a),jsonRpcResult(ro));if("error"in w)throw new SolanaJSONRPCError(w.error,`failed to get Stake Activation ${e.toBase58()}`);return w.result}async getProgramAccounts(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),{encoding:s,...a}=i||{},w=this._buildArgs([e.toBase58()],n,s||"base64",a),k=await this._rpcRequest("getProgramAccounts",w),I=array(Xi),we=!0===a.withContext?create(k,jsonRpcResultAndContext(I)):create(k,jsonRpcResult(I));if("error"in we)throw new SolanaJSONRPCError(we.error,`failed to get accounts owned by program ${e.toBase58()}`);return we.result}async getParsedProgramAccounts(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgs([e.toBase58()],n,"jsonParsed",i),a=create(await this._rpcRequest("getProgramAccounts",s),jsonRpcResult(array(to)));if("error"in a)throw new SolanaJSONRPCError(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,r){let n,i;if("string"==typeof e)n=e;else{const r=e;if(r.abortSignal?.aborted)return Promise.reject(r.abortSignal.reason);n=r.signature}try{i=yr().decode(n)}catch(e){throw new Error("signature must be base58 encoded: "+n)}return index_browser_esm_assert(64===i.length,"signature has invalid length"),"string"==typeof e?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:r||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:r||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:r||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise(((r,n)=>{null!=e&&(e.aborted?n(e.reason):e.addEventListener("abort",(()=>{n(e.reason)})))}))}getTransactionConfirmationPromise({commitment:e,signature:r}){let n,i,s=!1;return{abortConfirmation:()=>{i&&(i(),i=void 0),null!=n&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:new Promise(((a,w)=>{try{n=this.onSignature(r,((e,r)=>{n=void 0;const i={context:r,value:e};a({__type:Cn.PROCESSED,response:i})}),e);const k=new Promise((e=>{null==n?e():i=this._onSubscriptionStateChange(n,(r=>{"subscribed"===r&&e()}))}));(async()=>{if(await k,s)return;const n=await this.getSignatureStatus(r);if(s)return;if(null==n)return;const{context:i,value:I}=n;if(null!=I)if(I?.err)w(I.err);else{switch(e){case"confirmed":case"single":case"singleGossip":if("processed"===I.confirmationStatus)return;break;case"finalized":case"max":case"root":if("processed"===I.confirmationStatus||"confirmed"===I.confirmationStatus)return}s=!0,a({__type:Cn.PROCESSED,response:{context:i,value:I}})}})()}catch(e){w(e)}}))}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:r,lastValidBlockHeight:n,signature:i}}){let s=!1;const a=new Promise((r=>{const checkBlockHeight=async()=>{try{return await this.getBlockHeight(e)}catch(e){return-1}};(async()=>{let e=await checkBlockHeight();if(!s){for(;e<=n;){if(await sleep(1e3),s)return;if(e=await checkBlockHeight(),s)return}r({__type:Cn.BLOCKHEIGHT_EXCEEDED})}})()})),{abortConfirmation:w,confirmationPromise:k}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),I=this.getCancellationPromise(r);let we;try{const e=await Promise.race([I,k,a]);if(e.__type!==Cn.PROCESSED)throw new TransactionExpiredBlockheightExceededError(i);we=e.response}finally{s=!0,w()}return we}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:r,minContextSlot:n,nonceAccountPubkey:i,nonceValue:s,signature:a}}){let w=!1;const k=new Promise((r=>{let a=s,k=null;const getCurrentNonceValue=async()=>{try{const{context:r,value:s}=await this.getNonceAndContext(i,{commitment:e,minContextSlot:n});return k=r.slot,s?.nonce}catch(e){return a}};(async()=>{if(a=await getCurrentNonceValue(),!w)for(;;){if(s!==a)return void r({__type:Cn.NONCE_INVALID,slotInWhichNonceDidAdvance:k});if(await sleep(2e3),w)return;if(a=await getCurrentNonceValue(),w)return}})()})),{abortConfirmation:I,confirmationPromise:we}=this.getTransactionConfirmationPromise({commitment:e,signature:a}),Ae=this.getCancellationPromise(r);let Ce;try{const r=await Promise.race([Ae,we,k]);if(r.__type===Cn.PROCESSED)Ce=r.response;else{let i;for(;;){const e=await this.getSignatureStatus(a);if(null==e)break;if(!(e.context.slot<(r.slotInWhichNonceDidAdvance??n))){i=e;break}await sleep(400)}if(!i?.value)throw new TransactionExpiredNonceInvalidError(a);{const r=e||"finalized",{confirmationStatus:n}=i.value;switch(r){case"processed":case"recent":if("processed"!==n&&"confirmed"!==n&&"finalized"!==n)throw new TransactionExpiredNonceInvalidError(a);break;case"confirmed":case"single":case"singleGossip":if("confirmed"!==n&&"finalized"!==n)throw new TransactionExpiredNonceInvalidError(a);break;case"finalized":case"max":case"root":if("finalized"!==n)throw new TransactionExpiredNonceInvalidError(a)}Ce={context:i.context,value:{err:i.value.err}}}}}finally{w=!0,I()}return Ce}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:r}){let n;const i=new Promise((r=>{let i=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":i=this._confirmTransactionInitialTimeout||3e4}n=setTimeout((()=>r({__type:Cn.TIMED_OUT,timeoutMs:i})),i)})),{abortConfirmation:s,confirmationPromise:a}=this.getTransactionConfirmationPromise({commitment:e,signature:r});let w;try{const e=await Promise.race([a,i]);if(e.__type!==Cn.PROCESSED)throw new TransactionExpiredTimeoutError(r,e.timeoutMs/1e3);w=e.response}finally{clearTimeout(n),s()}return w}async getClusterNodes(){const e=create(await this._rpcRequest("getClusterNodes",[]),jsonRpcResult(array(po)));if("error"in e)throw new SolanaJSONRPCError(e.error,"failed to get cluster nodes");return e.result}async getVoteAccounts(e){const r=this._buildArgs([],e),n=create(await this._rpcRequest("getVoteAccounts",r),yo);if("error"in n)throw new SolanaJSONRPCError(n.error,"failed to get vote accounts");return n.result}async getSlot(e){const{commitment:r,config:n}=extractCommitmentFromConfig(e),i=this._buildArgs([],r,void 0,n),s=create(await this._rpcRequest("getSlot",i),jsonRpcResult(index_es_number()));if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get slot");return s.result}async getSlotLeader(e){const{commitment:r,config:n}=extractCommitmentFromConfig(e),i=this._buildArgs([],r,void 0,n),s=create(await this._rpcRequest("getSlotLeader",i),jsonRpcResult(string()));if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get slot leader");return s.result}async getSlotLeaders(e,r){const n=[e,r],i=create(await this._rpcRequest("getSlotLeaders",n),jsonRpcResult(array(_i)));if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get slot leaders");return i.result}async getSignatureStatus(e,r){const{context:n,value:i}=await this.getSignatureStatuses([e],r);index_browser_esm_assert(1===i.length);return{context:n,value:i[0]}}async getSignatureStatuses(e,r){const n=[e];r&&n.push(r);const i=create(await this._rpcRequest("getSignatureStatuses",n),wo);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get signature status");return i.result}async getTransactionCount(e){const{commitment:r,config:n}=extractCommitmentFromConfig(e),i=this._buildArgs([],r,void 0,n),s=create(await this._rpcRequest("getTransactionCount",i),jsonRpcResult(index_es_number()));if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get transaction count");return s.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const r=this._buildArgs([],e),n=create(await this._rpcRequest("getInflationGovernor",r),Di);if("error"in n)throw new SolanaJSONRPCError(n.error,"failed to get inflation");return n.result}async getInflationReward(e,r,n){const{commitment:i,config:s}=extractCommitmentFromConfig(n),a=this._buildArgs([e.map((e=>e.toBase58()))],i,void 0,{...s,epoch:null!=r?r:s?.epoch}),w=create(await this._rpcRequest("getInflationReward",a),Ii);if("error"in w)throw new SolanaJSONRPCError(w.error,"failed to get inflation reward");return w.result}async getInflationRate(){const e=create(await this._rpcRequest("getInflationRate",[]),Ki);if("error"in e)throw new SolanaJSONRPCError(e.error,"failed to get inflation rate");return e.result}async getEpochInfo(e){const{commitment:r,config:n}=extractCommitmentFromConfig(e),i=this._buildArgs([],r,void 0,n),s=create(await this._rpcRequest("getEpochInfo",i),Mi);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get epoch info");return s.result}async getEpochSchedule(){const e=create(await this._rpcRequest("getEpochSchedule",[]),Fi);if("error"in e)throw new SolanaJSONRPCError(e.error,"failed to get epoch schedule");const r=e.result;return new EpochSchedule(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const e=create(await this._rpcRequest("getLeaderSchedule",[]),Wi);if("error"in e)throw new SolanaJSONRPCError(e.error,"failed to get leader schedule");return e.result}async getMinimumBalanceForRentExemption(e,r){const n=this._buildArgs([e],r),i=create(await this._rpcRequest("getMinimumBalanceForRentExemption",n),So);return"error"in i?(console.warn("Unable to fetch minimum balance for rent exemption"),0):i.result}async getRecentBlockhashAndContext(e){const r=this._buildArgs([],e),n=create(await this._rpcRequest("getRecentBlockhash",r),Ho);if("error"in n)throw new SolanaJSONRPCError(n.error,"failed to get recent blockhash");return n.result}async getRecentPerformanceSamples(e){const r=create(await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),Go);if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(e,r){const n=this._buildArgs([e],r),i=create(await this._rpcRequest("getFeeCalculatorForBlockhash",n),Jo);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get fee calculator");const{context:s,value:a}=i.result;return{context:s,value:null!==a?a.feeCalculator:null}}async getFeeForMessage(e,r){const n=toBuffer(e.serialize()).toString("base64"),i=this._buildArgs([n],r),s=create(await this._rpcRequest("getFeeForMessage",i),jsonRpcResultAndContext(nullable(index_es_number())));if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get fee for message");if(null===s.result)throw new Error("invalid blockhash");return s.result}async getRecentPrioritizationFees(e){const r=e?.lockedWritableAccounts?.map((e=>e.toBase58())),n=r?.length?[r]:[],i=create(await this._rpcRequest("getRecentPrioritizationFees",n),Ui);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get recent prioritization fees");return i.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhashAndContext(e){const{commitment:r,config:n}=extractCommitmentFromConfig(e),i=this._buildArgs([],r,void 0,n),s=create(await this._rpcRequest("getLatestBlockhash",i),$o);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get latest blockhash");return s.result}async isBlockhashValid(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgs([e],n,void 0,i),a=create(await this._rpcRequest("isBlockhashValid",s),Yo);if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){const e=create(await this._rpcRequest("getVersion",[]),jsonRpcResult(Bi));if("error"in e)throw new SolanaJSONRPCError(e.error,"failed to get version");return e.result}async getGenesisHash(){const e=create(await this._rpcRequest("getGenesisHash",[]),jsonRpcResult(string()));if("error"in e)throw new SolanaJSONRPCError(e.error,"failed to get genesis hash");return e.result}async getBlock(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgsAtLeastConfirmed([e],n,void 0,i),a=await this._rpcRequest("getBlock",s);try{switch(i?.transactionDetails){case"accounts":{const e=create(a,Ko);if("error"in e)throw e.error;return e.result}case"none":{const e=create(a,Do);if("error"in e)throw e.error;return e.result}default:{const e=create(a,zo);if("error"in e)throw e.error;const{result:r}=e;return r?{...r,transactions:r.transactions.map((({transaction:e,meta:r,version:n})=>({meta:r,transaction:{...e,message:versionedMessageFromResponse(n,e.message)},version:n})))}:null}}}catch(e){throw new SolanaJSONRPCError(e,"failed to get confirmed block")}}async getParsedBlock(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",i),a=await this._rpcRequest("getBlock",s);try{switch(i?.transactionDetails){case"accounts":{const e=create(a,Mo);if("error"in e)throw e.error;return e.result}case"none":{const e=create(a,Fo);if("error"in e)throw e.error;return e.result}default:{const e=create(a,Uo);if("error"in e)throw e.error;return e.result}}}catch(e){throw new SolanaJSONRPCError(e,"failed to get block")}}async getBlockProduction(e){let r,n;if("string"==typeof e)n=e;else if(e){const{commitment:i,...s}=e;n=i,r=s}const i=this._buildArgs([],n,"base64",r),s=create(await this._rpcRequest("getBlockProduction",i),zi);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get block production information");return s.result}async getTransaction(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgsAtLeastConfirmed([e],n,void 0,i),a=create(await this._rpcRequest("getTransaction",s),Vo);if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to get transaction");const w=a.result;return w?{...w,transaction:{...w.transaction,message:versionedMessageFromResponse(w.version,w.transaction.message)}}:w}async getParsedTransaction(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",i),a=create(await this._rpcRequest("getTransaction",s),jo);if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=e.map((e=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",i)})));return(await this._rpcBatchRequest(s)).map((e=>{const r=create(e,jo);if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get transactions");return r.result}))}async getTransactions(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=e.map((e=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([e],n,void 0,i)})));return(await this._rpcBatchRequest(s)).map((e=>{const r=create(e,Vo);if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get transactions");const n=r.result;return n?{...n,transaction:{...n.transaction,message:versionedMessageFromResponse(n.version,n.transaction.message)}}:n}))}async getConfirmedBlock(e,r){const n=this._buildArgsAtLeastConfirmed([e],r),i=create(await this._rpcRequest("getConfirmedBlock",n),Wo);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get confirmed block");const s=i.result;if(!s)throw new Error("Confirmed block "+e+" not found");const a={...s,transactions:s.transactions.map((({transaction:e,meta:r})=>{const n=new Message(e.message);return{meta:r,transaction:{...e,message:n}}}))};return{...a,transactions:a.transactions.map((({transaction:e,meta:r})=>({meta:r,transaction:Transaction.populate(e.message,e.signatures)})))}}async getBlocks(e,r,n){const i=this._buildArgsAtLeastConfirmed(void 0!==r?[e,r]:[e],n),s=create(await this._rpcRequest("getBlocks",i),jsonRpcResult(array(index_es_number())));if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get blocks");return s.result}async getBlockSignatures(e,r){const n=this._buildArgsAtLeastConfirmed([e],r,void 0,{transactionDetails:"signatures",rewards:!1}),i=create(await this._rpcRequest("getBlock",n),qo);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get block");const s=i.result;if(!s)throw new Error("Block "+e+" not found");return s}async getConfirmedBlockSignatures(e,r){const n=this._buildArgsAtLeastConfirmed([e],r,void 0,{transactionDetails:"signatures",rewards:!1}),i=create(await this._rpcRequest("getConfirmedBlock",n),qo);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get confirmed block");const s=i.result;if(!s)throw new Error("Confirmed block "+e+" not found");return s}async getConfirmedTransaction(e,r){const n=this._buildArgsAtLeastConfirmed([e],r),i=create(await this._rpcRequest("getConfirmedTransaction",n),Vo);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get transaction");const s=i.result;if(!s)return s;const a=new Message(s.transaction.message),w=s.transaction.signatures;return{...s,transaction:Transaction.populate(a,w)}}async getParsedConfirmedTransaction(e,r){const n=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed"),i=create(await this._rpcRequest("getConfirmedTransaction",n),jo);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get confirmed transaction");return i.result}async getParsedConfirmedTransactions(e,r){const n=e.map((e=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([e],r,"jsonParsed")})));return(await this._rpcBatchRequest(n)).map((e=>{const r=create(e,jo);if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get confirmed transactions");return r.result}))}async getConfirmedSignaturesForAddress(e,r,n){let i={},s=await this.getFirstAvailableBlock();for(;!("until"in i)&&!(--r<=0||r<s);)try{const e=await this.getConfirmedBlockSignatures(r,"finalized");e.signatures.length>0&&(i.until=e.signatures[e.signatures.length-1].toString())}catch(e){if(e instanceof Error&&e.message.includes("skipped"))continue;throw e}let a=await this.getSlot("finalized");for(;!("before"in i||++n>a);)try{const e=await this.getConfirmedBlockSignatures(n);e.signatures.length>0&&(i.before=e.signatures[e.signatures.length-1].toString())}catch(e){if(e instanceof Error&&e.message.includes("skipped"))continue;throw e}return(await this.getConfirmedSignaturesForAddress2(e,i)).map((e=>e.signature))}async getConfirmedSignaturesForAddress2(e,r,n){const i=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,r),s=create(await this._rpcRequest("getConfirmedSignaturesForAddress2",i),no);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get confirmed signatures for address");return s.result}async getSignaturesForAddress(e,r,n){const i=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,r),s=create(await this._rpcRequest("getSignaturesForAddress",i),io);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get signatures for address");return s.result}async getAddressLookupTable(e,r){const{context:n,value:i}=await this.getAccountInfoAndContext(e,r);let s=null;return null!==i&&(s=new AddressLookupTableAccount({key:e,state:AddressLookupTableAccount.deserialize(i.data)})),{context:n,value:s}}async getNonceAndContext(e,r){const{context:n,value:i}=await this.getAccountInfoAndContext(e,r);let s=null;return null!==i&&(s=NonceAccount.fromAccountData(i.data)),{context:n,value:s}}async getNonce(e,r){return await this.getNonceAndContext(e,r).then((e=>e.value)).catch((r=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+r)}))}async requestAirdrop(e,r){const n=create(await this._rpcRequest("requestAirdrop",[e.toBase58(),r]),Zo);if("error"in n)throw new SolanaJSONRPCError(n.error,`airdrop to ${e.toBase58()} failed`);return n.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await sleep(100);const e=Date.now()-this._blockhashInfo.lastFetch>=Ei;if(null!==this._blockhashInfo.latestBlockhash&&!e)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),r=this._blockhashInfo.latestBlockhash,n=r?r.blockhash:null;for(let e=0;e<50;e++){const e=await this.getLatestBlockhash("finalized");if(n!==e.blockhash)return this._blockhashInfo={latestBlockhash:e,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},e;await sleep(200)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:r,config:n}=extractCommitmentFromConfig(e),i=this._buildArgs([],r,"base64",n),s=create(await this._rpcRequest("getStakeMinimumDelegation",i),jsonRpcResultAndContext(index_es_number()));if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get stake minimum delegation");return s.result}async simulateTransaction(e,r,n){if("message"in e){const i=e.serialize(),a=s.Buffer.from(i).toString("base64");if(Array.isArray(r)||void 0!==n)throw new Error("Invalid arguments");const w=r||{};w.encoding="base64","commitment"in w||(w.commitment=this.commitment);const k=[a,w],I=create(await this._rpcRequest("simulateTransaction",k),Li);if("error"in I)throw new Error("failed to simulate transaction: "+I.error.message);return I.result}let i;if(e instanceof Transaction){let r=e;i=new Transaction,i.feePayer=r.feePayer,i.instructions=e.instructions,i.nonceInfo=r.nonceInfo,i.signatures=r.signatures}else i=Transaction.populate(e),i._message=i._json=void 0;if(void 0!==r&&!Array.isArray(r))throw new Error("Invalid arguments");const a=r;if(i.nonceInfo&&a)i.sign(...a);else{let e=this._disableBlockhashCaching;for(;;){const r=await this._blockhashWithExpiryBlockHeight(e);if(i.lastValidBlockHeight=r.lastValidBlockHeight,i.recentBlockhash=r.blockhash,!a)break;if(i.sign(...a),!i.signature)throw new Error("!signature");const n=i.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(n)&&!this._blockhashInfo.transactionSignatures.includes(n)){this._blockhashInfo.simulatedSignatures.push(n);break}e=!0}}const w=i._compile(),k=w.serialize(),I=i._serialize(k).toString("base64"),we={encoding:"base64",commitment:this.commitment};if(n){const e=(Array.isArray(n)?n:w.nonProgramIds()).map((e=>e.toBase58()));we.accounts={encoding:"base64",addresses:e}}a&&(we.sigVerify=!0);const Ae=[I,we],Ce=create(await this._rpcRequest("simulateTransaction",Ae),Li);if("error"in Ce){let e;if("data"in Ce.error&&(e=Ce.error.data.logs,e&&Array.isArray(e))){const r="\n    ",n=r+e.join(r);console.error(Ce.error.message,n)}throw new SendTransactionError("failed to simulate transaction: "+Ce.error.message,e)}return Ce.result}async sendTransaction(e,r,n){if("version"in e){if(r&&Array.isArray(r))throw new Error("Invalid arguments");const n=e.serialize();return await this.sendRawTransaction(n,r)}if(void 0===r||!Array.isArray(r))throw new Error("Invalid arguments");const i=r;if(e.nonceInfo)e.sign(...i);else{let r=this._disableBlockhashCaching;for(;;){const n=await this._blockhashWithExpiryBlockHeight(r);if(e.lastValidBlockHeight=n.lastValidBlockHeight,e.recentBlockhash=n.blockhash,e.sign(...i),!e.signature)throw new Error("!signature");const s=e.signature.toString("base64");if(!this._blockhashInfo.transactionSignatures.includes(s)){this._blockhashInfo.transactionSignatures.push(s);break}r=!0}}const s=e.serialize();return await this.sendRawTransaction(s,n)}async sendRawTransaction(e,r){const n=toBuffer(e).toString("base64");return await this.sendEncodedTransaction(n,r)}async sendEncodedTransaction(e,r){const n={encoding:"base64"},i=r&&r.skipPreflight,s=!0===i?"processed":r&&r.preflightCommitment||this.commitment;r&&null!=r.maxRetries&&(n.maxRetries=r.maxRetries),r&&null!=r.minContextSlot&&(n.minContextSlot=r.minContextSlot),i&&(n.skipPreflight=i),s&&(n.preflightCommitment=s);const a=[e,n],w=create(await this._rpcRequest("sendTransaction",a),Xo);if("error"in w){let e;throw"data"in w.error&&(e=w.error.data.logs),new SendTransactionError("failed to send transaction: "+w.error.message,e)}return w.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval((()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()}),5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),1e3!==e?(this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach((([e,r])=>{this._setSubscription(e,{...r,state:"pending"})}))):this._updateSubscriptions()}_setSubscription(e,r){const n=this._subscriptionsByHash[e]?.state;if(this._subscriptionsByHash[e]=r,n!==r.state){const n=this._subscriptionStateChangeCallbacksByHash[e];n&&n.forEach((e=>{try{e(r.state)}catch{}}))}}_onSubscriptionStateChange(e,r){const n=this._subscriptionHashByClientSubscriptionId[e];if(null==n)return()=>{};const i=this._subscriptionStateChangeCallbacksByHash[n]||=new Set;return i.add(r),()=>{i.delete(r),0===i.size&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(0===Object.keys(this._subscriptionsByHash).length)return void(this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout((()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(e){e instanceof Error&&console.log(`Error when closing socket connection: ${e.message}`)}}),500)));if(null!==this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected)return void this._rpcWebSocket.connect();const e=this._rpcWebSocketGeneration,isCurrentConnectionStillActive=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map((async e=>{const r=this._subscriptionsByHash[e];if(void 0!==r)switch(r.state){case"pending":case"unsubscribed":if(0===r.callbacks.size)return delete this._subscriptionsByHash[e],"unsubscribed"===r.state&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],void await this._updateSubscriptions();await(async()=>{const{args:n,method:i}=r;try{this._setSubscription(e,{...r,state:"subscribing"});const s=await this._rpcWebSocket.call(i,n);this._setSubscription(e,{...r,serverSubscriptionId:s,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[s]=r.callbacks,await this._updateSubscriptions()}catch(s){if(s instanceof Error&&console.error(`${i} error for argument`,n,s.message),!isCurrentConnectionStillActive())return;this._setSubscription(e,{...r,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":0===r.callbacks.size&&await(async()=>{const{serverSubscriptionId:n,unsubscribeMethod:i}=r;if(this._subscriptionsAutoDisposedByRpc.has(n))this._subscriptionsAutoDisposedByRpc.delete(n);else{this._setSubscription(e,{...r,state:"unsubscribing"}),this._setSubscription(e,{...r,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[n])}catch(n){if(n instanceof Error&&console.error(`${i} error:`,n.message),!isCurrentConnectionStillActive())return;return this._setSubscription(e,{...r,state:"subscribed"}),void await this._updateSubscriptions()}}this._setSubscription(e,{...r,state:"unsubscribed"}),await this._updateSubscriptions()})()}})))}_handleServerNotification(e,r){const n=this._subscriptionCallbacksByServerSubscriptionId[e];void 0!==n&&n.forEach((e=>{try{e(...r)}catch(e){console.error(e)}}))}_wsOnAccountNotification(e){const{result:r,subscription:n}=create(e,oo);this._handleServerNotification(n,[r.value,r.context])}_makeSubscription(e,r){const n=this._nextClientSubscriptionId++,i=gi([e.method,r]),s=this._subscriptionsByHash[i];return void 0===s?this._subscriptionsByHash[i]={...e,args:r,callbacks:new Set([e.callback]),state:"pending"}:s.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=i,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const r=this._subscriptionsByHash[i];index_browser_esm_assert(void 0!==r,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),r.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,r,n){const i=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64");return this._makeSubscription({callback:r,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},i)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:r,subscription:n}=create(e,ao);this._handleServerNotification(n,[{accountId:r.value.pubkey,accountInfo:r.value.account},r.context])}onProgramAccountChange(e,r,n,i){const s=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64",i?{filters:i}:void 0);return this._makeSubscription({callback:r,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},s)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,r,n){const i=this._buildArgs(["object"==typeof e?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:r,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},i)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:r,subscription:n}=create(e,es);this._handleServerNotification(n,[r.value,r.context])}_wsOnSlotNotification(e){const{result:r,subscription:n}=create(e,uo);this._handleServerNotification(n,[r])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:r,subscription:n}=create(e,ho);this._handleServerNotification(n,[r])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,r){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${r}' events could not be found.`)}_buildArgs(e,r,n,i){const s=r||this._commitment;if(s||n||i){let r={};n&&(r.encoding=n),s&&(r.commitment=s),i&&(r=Object.assign(r,i)),e.push(r)}return e}_buildArgsAtLeastConfirmed(e,r,n,i){const s=r||this._commitment;if(s&&!["confirmed","finalized"].includes(s))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,r,n,i)}_wsOnSignatureNotification(e){const{result:r,subscription:n}=create(e,fo);"receivedSignature"!==r.value&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,"receivedSignature"===r.value?[{type:"received"},r.context]:[{type:"status",result:r.value},r.context])}onSignature(e,r,n){const i=this._buildArgs([e],n||this._commitment||"finalized"),s=this._makeSubscription({callback:(e,n)=>{if("status"===e.type){r(e.result,n);try{this.removeSignatureListener(s)}catch(e){}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return s}onSignatureWithOptions(e,r,n){const{commitment:i,...s}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},a=this._buildArgs([e],i,void 0,s),w=this._makeSubscription({callback:(e,n)=>{r(e,n);try{this.removeSignatureListener(w)}catch(e){}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},a);return w}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:r,subscription:n}=create(e,go);this._handleServerNotification(n,[r])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Keypair{constructor(e){this._keypair=void 0,this._keypair=e??generateKeypair()}static generate(){return new Keypair(generateKeypair())}static fromSecretKey(e,r){if(64!==e.byteLength)throw new Error("bad secret key size");const n=e.slice(32,64);if(!r||!r.skipValidation){const r=e.slice(0,32),i=sn(r);for(let e=0;e<32;e++)if(n[e]!==i[e])throw new Error("provided secretKey is invalid")}return new Keypair({publicKey:n,secretKey:e})}static fromSeed(e){const r=sn(e),n=new Uint8Array(64);return n.set(e),n.set(r,32),new Keypair({publicKey:r,secretKey:n})}get publicKey(){return new PublicKey(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const rs=Object.freeze({CreateLookupTable:{index:0,layout:kr.struct([kr.u32("instruction"),ai("recentSlot"),kr.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:kr.struct([kr.u32("instruction")])},ExtendLookupTable:{index:2,layout:kr.struct([kr.u32("instruction"),ai(),kr.seq(publicKey(),kr.offset(kr.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:kr.struct([kr.u32("instruction")])},CloseLookupTable:{index:4,layout:kr.struct([kr.u32("instruction")])}});class AddressLookupTableInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=kr.u32("instruction").decode(e.data);let n;for(const[e,i]of Object.entries(rs))if(i.index==r){n=e;break}if(!n)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return n}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:r}=decodeData$1(rs.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(r)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:r}=decodeData$1(rs.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:r.map((e=>new PublicKey(e)))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(AddressLookupTableProgram.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,r){if(e.length<r)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${r}`)}}class AddressLookupTableProgram{constructor(){}static createLookupTable(e){const[r,n]=PublicKey.findProgramAddressSync([e.authority.toBuffer(),(0,Ar.toBufferLE)(BigInt(e.recentSlot),8)],this.programId),i=encodeData(rs.CreateLookupTable,{recentSlot:BigInt(e.recentSlot),bumpSeed:n}),s=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}];return[new TransactionInstruction({programId:this.programId,keys:s,data:i}),r]}static freezeLookupTable(e){const r=encodeData(rs.FreezeLookupTable),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:n,data:r})}static extendLookupTable(e){const r=encodeData(rs.ExtendLookupTable,{addresses:e.addresses.map((e=>e.toBytes()))}),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&n.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}),new TransactionInstruction({programId:this.programId,keys:n,data:r})}static deactivateLookupTable(e){const r=encodeData(rs.DeactivateLookupTable),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:n,data:r})}static closeLookupTable(e){const r=encodeData(rs.CloseLookupTable),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new TransactionInstruction({programId:this.programId,keys:n,data:r})}}AddressLookupTableProgram.programId=new PublicKey("AddressLookupTab1e1111111111111111111111111");class ComputeBudgetInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=kr.u8("instruction").decode(e.data);let n;for(const[e,i]of Object.entries(ns))if(i.index==r){n=e;break}if(!n)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return n}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:r,additionalFee:n}=decodeData$1(ns.RequestUnits,e.data);return{units:r,additionalFee:n}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:r}=decodeData$1(ns.RequestHeapFrame,e.data);return{bytes:r}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:r}=decodeData$1(ns.SetComputeUnitLimit,e.data);return{units:r}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:r}=decodeData$1(ns.SetComputeUnitPrice,e.data);return{microLamports:r}}static checkProgramId(e){if(!e.equals(ComputeBudgetProgram.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const ns=Object.freeze({RequestUnits:{index:0,layout:kr.struct([kr.u8("instruction"),kr.u32("units"),kr.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:kr.struct([kr.u8("instruction"),kr.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:kr.struct([kr.u8("instruction"),kr.u32("units")])},SetComputeUnitPrice:{index:3,layout:kr.struct([kr.u8("instruction"),ai("microLamports")])}});class ComputeBudgetProgram{constructor(){}static requestUnits(e){const r=encodeData(ns.RequestUnits,e);return new TransactionInstruction({keys:[],programId:this.programId,data:r})}static requestHeapFrame(e){const r=encodeData(ns.RequestHeapFrame,e);return new TransactionInstruction({keys:[],programId:this.programId,data:r})}static setComputeUnitLimit(e){const r=encodeData(ns.SetComputeUnitLimit,e);return new TransactionInstruction({keys:[],programId:this.programId,data:r})}static setComputeUnitPrice(e){const r=encodeData(ns.SetComputeUnitPrice,{microLamports:BigInt(e.microLamports)});return new TransactionInstruction({keys:[],programId:this.programId,data:r})}}ComputeBudgetProgram.programId=new PublicKey("ComputeBudget111111111111111111111111111111");const os=kr.struct([kr.u8("numSignatures"),kr.u8("padding"),kr.u16("signatureOffset"),kr.u16("signatureInstructionIndex"),kr.u16("publicKeyOffset"),kr.u16("publicKeyInstructionIndex"),kr.u16("messageDataOffset"),kr.u16("messageDataSize"),kr.u16("messageInstructionIndex")]);class Ed25519Program{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:r,message:n,signature:i,instructionIndex:a}=e;index_browser_esm_assert(32===r.length,`Public Key must be 32 bytes but received ${r.length} bytes`),index_browser_esm_assert(64===i.length,`Signature must be 64 bytes but received ${i.length} bytes`);const w=os.span,k=w+r.length,I=k+i.length,we=s.Buffer.alloc(I+n.length),Ae=null==a?65535:a;return os.encode({numSignatures:1,padding:0,signatureOffset:k,signatureInstructionIndex:Ae,publicKeyOffset:w,publicKeyInstructionIndex:Ae,messageDataOffset:I,messageDataSize:n.length,messageInstructionIndex:Ae},we),we.fill(r,w),we.fill(i,k),we.fill(n,I),new TransactionInstruction({keys:[],programId:Ed25519Program.programId,data:we})}static createInstructionWithPrivateKey(e){const{privateKey:r,message:n,instructionIndex:i}=e;index_browser_esm_assert(64===r.length,`Private key must be 64 bytes but received ${r.length} bytes`);try{const e=Keypair.fromSecretKey(r),s=e.publicKey.toBytes(),a=sign(n,e.secretKey);return this.createInstructionWithPublicKey({publicKey:s,message:n,signature:a,instructionIndex:i})}catch(e){throw new Error(`Error creating instruction; ${e}`)}}}Ed25519Program.programId=new PublicKey("Ed25519SigVerify111111111111111111111111111");Xr.utils.isValidPrivateKey;const ss=Xr.getPublicKey,as=kr.struct([kr.u8("numSignatures"),kr.u16("signatureOffset"),kr.u8("signatureInstructionIndex"),kr.u16("ethAddressOffset"),kr.u8("ethAddressInstructionIndex"),kr.u16("messageDataOffset"),kr.u16("messageDataSize"),kr.u8("messageInstructionIndex"),kr.blob(20,"ethAddress"),kr.blob(64,"signature"),kr.u8("recoveryId")]);class Secp256k1Program{constructor(){}static publicKeyToEthAddress(e){index_browser_esm_assert(64===e.length,`Public key must be 64 bytes but received ${e.length} bytes`);try{return s.Buffer.from(Mr(toBuffer(e))).slice(-20)}catch(e){throw new Error(`Error constructing Ethereum address: ${e}`)}}static createInstructionWithPublicKey(e){const{publicKey:r,message:n,signature:i,recoveryId:s,instructionIndex:a}=e;return Secp256k1Program.createInstructionWithEthAddress({ethAddress:Secp256k1Program.publicKeyToEthAddress(r),message:n,signature:i,recoveryId:s,instructionIndex:a})}static createInstructionWithEthAddress(e){const{ethAddress:r,message:n,signature:i,recoveryId:a,instructionIndex:w=0}=e;let k;k="string"==typeof r?r.startsWith("0x")?s.Buffer.from(r.substr(2),"hex"):s.Buffer.from(r,"hex"):r,index_browser_esm_assert(20===k.length,`Address must be 20 bytes but received ${k.length} bytes`);const I=12+k.length,we=I+i.length+1,Ae=s.Buffer.alloc(as.span+n.length);return as.encode({numSignatures:1,signatureOffset:I,signatureInstructionIndex:w,ethAddressOffset:12,ethAddressInstructionIndex:w,messageDataOffset:we,messageDataSize:n.length,messageInstructionIndex:w,signature:toBuffer(i),ethAddress:toBuffer(k),recoveryId:a},Ae),Ae.fill(toBuffer(n),as.span),new TransactionInstruction({keys:[],programId:Secp256k1Program.programId,data:Ae})}static createInstructionWithPrivateKey(e){const{privateKey:r,message:n,instructionIndex:i}=e;index_browser_esm_assert(32===r.length,`Private key must be 32 bytes but received ${r.length} bytes`);try{const e=toBuffer(r),a=ss(e,!1).slice(1),w=s.Buffer.from(Mr(toBuffer(n))),[k,I]=((e,r)=>{const n=Xr.sign(e,r);return[n.toCompactRawBytes(),n.recovery]})(w,e);return this.createInstructionWithPublicKey({publicKey:a,message:n,signature:k,recoveryId:I,instructionIndex:i})}catch(e){throw new Error(`Error creating instruction; ${e}`)}}}var cs;Secp256k1Program.programId=new PublicKey("KeccakSecp256k11111111111111111111111111111");const us=new PublicKey("StakeConfig11111111111111111111111111111111");class Authorized{constructor(e,r){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=r}}class Lockup{constructor(e,r,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=r,this.custodian=n}}cs=Lockup,Lockup.default=new cs(0,0,PublicKey.default);class StakeInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=kr.u32("instruction").decode(e.data);let n;for(const[e,i]of Object.entries(ds))if(i.index==r){n=e;break}if(!n)throw new Error("Instruction type incorrect; not a StakeInstruction");return n}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:r,lockup:n}=decodeData$1(ds.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new Authorized(new PublicKey(r.staker),new PublicKey(r.withdrawer)),lockup:new Lockup(n.unixTimestamp,n.epoch,new PublicKey(n.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),decodeData$1(ds.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:r,stakeAuthorizationType:n}=decodeData$1(ds.Authorize,e.data),i={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new PublicKey(r),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(i.custodianPubkey=e.keys[3].pubkey),i}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:r,stakeAuthorizationType:n,authoritySeed:i,authorityOwner:s}=decodeData$1(ds.AuthorizeWithSeed,e.data),a={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:i,authorityOwner:new PublicKey(s),newAuthorizedPubkey:new PublicKey(r),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(a.custodianPubkey=e.keys[3].pubkey),a}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:r}=decodeData$1(ds.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:r}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),decodeData$1(ds.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:r}=decodeData$1(ds.Withdraw,e.data),n={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:r};return e.keys.length>5&&(n.custodianPubkey=e.keys[5].pubkey),n}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),decodeData$1(ds.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(StakeProgram.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,r){if(e.length<r)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${r}`)}}const ds=Object.freeze({Initialize:{index:0,layout:kr.struct([kr.u32("instruction"),((e="authorized")=>kr.struct([publicKey("staker"),publicKey("withdrawer")],e))(),((e="lockup")=>kr.struct([kr.ns64("unixTimestamp"),kr.ns64("epoch"),publicKey("custodian")],e))()])},Authorize:{index:1,layout:kr.struct([kr.u32("instruction"),publicKey("newAuthorized"),kr.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:kr.struct([kr.u32("instruction")])},Split:{index:3,layout:kr.struct([kr.u32("instruction"),kr.ns64("lamports")])},Withdraw:{index:4,layout:kr.struct([kr.u32("instruction"),kr.ns64("lamports")])},Deactivate:{index:5,layout:kr.struct([kr.u32("instruction")])},Merge:{index:7,layout:kr.struct([kr.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:kr.struct([kr.u32("instruction"),publicKey("newAuthorized"),kr.u32("stakeAuthorizationType"),rustString("authoritySeed"),publicKey("authorityOwner")])}}),ls=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class StakeProgram{constructor(){}static initialize(e){const{stakePubkey:r,authorized:n,lockup:i}=e,s=i||Lockup.default,a=encodeData(ds.Initialize,{authorized:{staker:toBuffer(n.staker.toBuffer()),withdrawer:toBuffer(n.withdrawer.toBuffer())},lockup:{unixTimestamp:s.unixTimestamp,epoch:s.epoch,custodian:toBuffer(s.custodian.toBuffer())}}),w={keys:[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Qn,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new TransactionInstruction(w)}static createAccountWithSeed(e){const r=new Transaction;r.add(SystemProgram.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:i,lockup:s}=e;return r.add(this.initialize({stakePubkey:n,authorized:i,lockup:s}))}static createAccount(e){const r=new Transaction;r.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:i,lockup:s}=e;return r.add(this.initialize({stakePubkey:n,authorized:i,lockup:s}))}static delegate(e){const{stakePubkey:r,authorizedPubkey:n,votePubkey:i}=e,s=encodeData(ds.Delegate);return(new Transaction).add({keys:[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Mn,isSigner:!1,isWritable:!1},{pubkey:ni,isSigner:!1,isWritable:!1},{pubkey:us,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static authorize(e){const{stakePubkey:r,authorizedPubkey:n,newAuthorizedPubkey:i,stakeAuthorizationType:s,custodianPubkey:a}=e,w=encodeData(ds.Authorize,{newAuthorized:toBuffer(i.toBuffer()),stakeAuthorizationType:s.index}),k=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Mn,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return a&&k.push({pubkey:a,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:k,programId:this.programId,data:w})}static authorizeWithSeed(e){const{stakePubkey:r,authorityBase:n,authoritySeed:i,authorityOwner:s,newAuthorizedPubkey:a,stakeAuthorizationType:w,custodianPubkey:k}=e,I=encodeData(ds.AuthorizeWithSeed,{newAuthorized:toBuffer(a.toBuffer()),stakeAuthorizationType:w.index,authoritySeed:i,authorityOwner:toBuffer(s.toBuffer())}),we=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:Mn,isSigner:!1,isWritable:!1}];return k&&we.push({pubkey:k,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:we,programId:this.programId,data:I})}static splitInstruction(e){const{stakePubkey:r,authorizedPubkey:n,splitStakePubkey:i,lamports:s}=e,a=encodeData(ds.Split,{lamports:s});return new TransactionInstruction({keys:[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e,r){const n=new Transaction;return n.add(SystemProgram.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:r,space:this.space,programId:this.programId})),n.add(this.splitInstruction(e))}static splitWithSeed(e,r){const{stakePubkey:n,authorizedPubkey:i,splitStakePubkey:s,basePubkey:a,seed:w,lamports:k}=e,I=new Transaction;return I.add(SystemProgram.allocate({accountPubkey:s,basePubkey:a,seed:w,space:this.space,programId:this.programId})),r&&r>0&&I.add(SystemProgram.transfer({fromPubkey:e.authorizedPubkey,toPubkey:s,lamports:r})),I.add(this.splitInstruction({stakePubkey:n,authorizedPubkey:i,splitStakePubkey:s,lamports:k}))}static merge(e){const{stakePubkey:r,sourceStakePubKey:n,authorizedPubkey:i}=e,s=encodeData(ds.Merge);return(new Transaction).add({keys:[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Mn,isSigner:!1,isWritable:!1},{pubkey:ni,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static withdraw(e){const{stakePubkey:r,authorizedPubkey:n,toPubkey:i,lamports:s,custodianPubkey:a}=e,w=encodeData(ds.Withdraw,{lamports:s}),k=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:Mn,isSigner:!1,isWritable:!1},{pubkey:ni,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return a&&k.push({pubkey:a,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:k,programId:this.programId,data:w})}static deactivate(e){const{stakePubkey:r,authorizedPubkey:n}=e,i=encodeData(ds.Deactivate);return(new Transaction).add({keys:[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Mn,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}}StakeProgram.programId=new PublicKey("Stake11111111111111111111111111111111111111"),StakeProgram.space=200;class VoteInit{constructor(e,r,n,i){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=r,this.authorizedWithdrawer=n,this.commission=i}}class VoteInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=kr.u32("instruction").decode(e.data);let n;for(const[e,i]of Object.entries(hs))if(i.index==r){n=e;break}if(!n)throw new Error("Instruction type incorrect; not a VoteInstruction");return n}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:r}=decodeData$1(hs.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new VoteInit(new PublicKey(r.nodePubkey),new PublicKey(r.authorizedVoter),new PublicKey(r.authorizedWithdrawer),r.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:r,voteAuthorizationType:n}=decodeData$1(hs.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new PublicKey(r),voteAuthorizationType:{index:n}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorized:i,voteAuthorizationType:s}}=decodeData$1(hs.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new PublicKey(r),currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:new PublicKey(i),voteAuthorizationType:{index:s},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:r}=decodeData$1(hs.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:r,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(VoteProgram.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,r){if(e.length<r)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${r}`)}}const hs=Object.freeze({InitializeAccount:{index:0,layout:kr.struct([kr.u32("instruction"),((e="voteInit")=>kr.struct([publicKey("nodePubkey"),publicKey("authorizedVoter"),publicKey("authorizedWithdrawer"),kr.u8("commission")],e))()])},Authorize:{index:1,layout:kr.struct([kr.u32("instruction"),publicKey("newAuthorized"),kr.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:kr.struct([kr.u32("instruction"),kr.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:kr.struct([kr.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:kr.struct([kr.u32("instruction"),((e="voteAuthorizeWithSeedArgs")=>kr.struct([kr.u32("voteAuthorizationType"),publicKey("currentAuthorityDerivedKeyOwnerPubkey"),rustString("currentAuthorityDerivedKeySeed"),publicKey("newAuthorized")],e))()])}}),fs=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class VoteProgram{constructor(){}static initializeAccount(e){const{votePubkey:r,nodePubkey:n,voteInit:i}=e,s=encodeData(hs.InitializeAccount,{voteInit:{nodePubkey:toBuffer(i.nodePubkey.toBuffer()),authorizedVoter:toBuffer(i.authorizedVoter.toBuffer()),authorizedWithdrawer:toBuffer(i.authorizedWithdrawer.toBuffer()),commission:i.commission}}),a={keys:[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Qn,isSigner:!1,isWritable:!1},{pubkey:Mn,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s};return new TransactionInstruction(a)}static createAccount(e){const r=new Transaction;return r.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),r.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:r,authorizedPubkey:n,newAuthorizedPubkey:i,voteAuthorizationType:s}=e,a=encodeData(hs.Authorize,{newAuthorized:toBuffer(i.toBuffer()),voteAuthorizationType:s.index}),w=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Mn,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:w,programId:this.programId,data:a})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:r,currentAuthorityDerivedKeyOwnerPubkey:n,currentAuthorityDerivedKeySeed:i,newAuthorizedPubkey:s,voteAuthorizationType:a,votePubkey:w}=e,k=encodeData(hs.AuthorizeWithSeed,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:toBuffer(n.toBuffer()),currentAuthorityDerivedKeySeed:i,newAuthorized:toBuffer(s.toBuffer()),voteAuthorizationType:a.index}}),I=[{pubkey:w,isSigner:!1,isWritable:!0},{pubkey:Mn,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:I,programId:this.programId,data:k})}static withdraw(e){const{votePubkey:r,authorizedWithdrawerPubkey:n,lamports:i,toPubkey:s}=e,a=encodeData(hs.Withdraw,{lamports:i}),w=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:w,programId:this.programId,data:a})}static safeWithdraw(e,r,n){if(e.lamports>r-n)throw new Error("Withdraw will leave vote account with insufficient funds.");return VoteProgram.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:r,authorizedWithdrawerPubkey:n,nodePubkey:i}=e,s=encodeData(hs.UpdateValidatorIdentity),a=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:a,programId:this.programId,data:s})}}VoteProgram.programId=new PublicKey("Vote111111111111111111111111111111111111111"),VoteProgram.space=3762;const gs=new PublicKey("Va1idator1nfo111111111111111111111111111111"),ps=type({name:string(),website:optional(string()),details:optional(string()),keybaseUsername:optional(string())});class ValidatorInfo{constructor(e,r){this.key=void 0,this.info=void 0,this.key=e,this.info=r}static fromConfigData(e){let r=[...e];if(2!==decodeLength(r))return null;const n=[];for(let e=0;e<2;e++){const e=new PublicKey(guardedSplice(r,0,ln)),i=1===guardedShift(r);n.push({publicKey:e,isSigner:i})}if(n[0].publicKey.equals(gs)&&n[1].isSigner){const e=rustString().decode(s.Buffer.from(r)),i=JSON.parse(e);return index_es_assert(i,ps),new ValidatorInfo(n[1].publicKey,i)}return null}}const ms=new PublicKey("Vote111111111111111111111111111111111111111"),ys=kr.struct([publicKey("nodePubkey"),publicKey("authorizedWithdrawer"),kr.u8("commission"),kr.nu64(),kr.seq(kr.struct([kr.nu64("slot"),kr.u32("confirmationCount")]),kr.offset(kr.u32(),-8),"votes"),kr.u8("rootSlotValid"),kr.nu64("rootSlot"),kr.nu64(),kr.seq(kr.struct([kr.nu64("epoch"),publicKey("authorizedVoter")]),kr.offset(kr.u32(),-8),"authorizedVoters"),kr.struct([kr.seq(kr.struct([publicKey("authorizedPubkey"),kr.nu64("epochOfLastAuthorizedSwitch"),kr.nu64("targetEpoch")]),32,"buf"),kr.nu64("idx"),kr.u8("isEmpty")],"priorVoters"),kr.nu64(),kr.seq(kr.struct([kr.nu64("epoch"),kr.nu64("credits"),kr.nu64("prevCredits")]),kr.offset(kr.u32(),-8),"epochCredits"),kr.struct([kr.nu64("slot"),kr.nu64("timestamp")],"lastTimestamp")]);class VoteAccount{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const r=ys.decode(toBuffer(e),4);let n=r.rootSlot;return r.rootSlotValid||(n=null),new VoteAccount({nodePubkey:new PublicKey(r.nodePubkey),authorizedWithdrawer:new PublicKey(r.authorizedWithdrawer),commission:r.commission,votes:r.votes,rootSlot:n,authorizedVoters:r.authorizedVoters.map(parseAuthorizedVoter),priorVoters:getPriorVoters(r.priorVoters),epochCredits:r.epochCredits,lastTimestamp:r.lastTimestamp})}}function parseAuthorizedVoter({authorizedVoter:e,epoch:r}){return{epoch:r,authorizedVoter:new PublicKey(e)}}function parsePriorVoters({authorizedPubkey:e,epochOfLastAuthorizedSwitch:r,targetEpoch:n}){return{authorizedPubkey:new PublicKey(e),epochOfLastAuthorizedSwitch:r,targetEpoch:n}}function getPriorVoters({buf:e,idx:r,isEmpty:n}){return n?[]:[...e.slice(r+1).map(parsePriorVoters),...e.slice(0,r).map(parsePriorVoters)]}const bs={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function clusterApiUrl(e,r){const n=!1===r?"http":"https";if(!e)return bs[n].devnet;const i=bs[n][e];if(!i)throw new Error(`Unknown ${n} cluster: ${e}`);return i}async function sendAndConfirmRawTransaction(e,r,n,i){let s,a;n&&Object.prototype.hasOwnProperty.call(n,"lastValidBlockHeight")||n&&Object.prototype.hasOwnProperty.call(n,"nonceValue")?(s=n,a=i):a=n;const w=a&&{skipPreflight:a.skipPreflight,preflightCommitment:a.preflightCommitment||a.commitment,minContextSlot:a.minContextSlot},k=await e.sendRawTransaction(r,w),I=a&&a.commitment,we=s?e.confirmTransaction(s,I):e.confirmTransaction(k,I),Ae=(await we).value;if(Ae.err)throw new Error(`Raw transaction ${k} failed (${JSON.stringify(Ae)})`);return k}const _s=1e9},50162:(e,r,n)=>{var i=n(901048).Buffer;const s=n(828985),a=n(678180);class CommonClient extends s.EventEmitter{address;rpc_id;queue;options;autoconnect;ready;reconnect;reconnect_timer_id;reconnect_interval;max_reconnects;rest_options;current_reconnects;generate_request_id;socket;webSocketFactory;dataPack;constructor(e,r="ws://localhost:8080",{autoconnect:n=!0,reconnect:i=!0,reconnect_interval:s=1e3,max_reconnects:w=5,...k}={},I,we){super(),this.webSocketFactory=e,this.queue={},this.rpc_id=0,this.address=r,this.autoconnect=n,this.ready=!1,this.reconnect=i,this.reconnect_timer_id=void 0,this.reconnect_interval=s,this.max_reconnects=w,this.rest_options=k,this.current_reconnects=0,this.generate_request_id=I||(()=>++this.rpc_id),this.dataPack=we||new a.DefaultDataPack,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(e,r,n,i){return i||"object"!=typeof n||(i=n,n=null),new Promise(((s,a)=>{if(!this.ready)return a(new Error("socket not ready"));const w=this.generate_request_id(e,r),k={jsonrpc:"2.0",method:e,params:r||void 0,id:w};this.socket.send(this.dataPack.encode(k),i,(e=>{if(e)return a(e);this.queue[w]={promise:[s,a]},n&&(this.queue[w].timeout=setTimeout((()=>{delete this.queue[w],a(new Error("reply timeout"))}),n))}))}))}async login(e){const r=await this.call("rpc.login",e);if(!r)throw new Error("authentication failed");return r}async listMethods(){return await this.call("__listMethods")}notify(e,r){return new Promise(((n,i)=>{if(!this.ready)return i(new Error("socket not ready"));const s={jsonrpc:"2.0",method:e,params:r};this.socket.send(this.dataPack.encode(s),(e=>{if(e)return i(e);n()}))}))}async subscribe(e){"string"==typeof e&&(e=[e]);const r=await this.call("rpc.on",e);if("string"==typeof e&&"ok"!==r[e])throw new Error("Failed subscribing to an event '"+e+"' with: "+r[e]);return r}async unsubscribe(e){"string"==typeof e&&(e=[e]);const r=await this.call("rpc.off",e);if("string"==typeof e&&"ok"!==r[e])throw new Error("Failed unsubscribing from an event with: "+r);return r}close(e,r){this.socket.close(e||1e3,r)}setAutoReconnect(e){this.reconnect=e}setReconnectInterval(e){this.reconnect_interval=e}setMaxReconnects(e){this.max_reconnects=e}_connect(e,r){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(e,r),this.socket.addEventListener("open",(()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0})),this.socket.addEventListener("message",(({data:e})=>{e instanceof ArrayBuffer&&(e=i.from(e).toString());try{e=this.dataPack.decode(e)}catch(e){return}if(e.notification&&this.listeners(e.notification).length){if(!Object.keys(e.params).length)return this.emit(e.notification);const r=[e.notification];if(e.params.constructor===Object)r.push(e.params);else for(let n=0;n<e.params.length;n++)r.push(e.params[n]);return Promise.resolve().then((()=>{this.emit.apply(this,r)}))}if(!this.queue[e.id])return e.method?Promise.resolve().then((()=>{this.emit(e.method,e?.params)})):void 0;"error"in e=="result"in e&&this.queue[e.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[e.id].timeout&&clearTimeout(this.queue[e.id].timeout),e.error?this.queue[e.id].promise[1](e.error):this.queue[e.id].promise[0](e.result),delete this.queue[e.id]})),this.socket.addEventListener("error",(e=>this.emit("error",e))),this.socket.addEventListener("close",(({code:n,reason:i})=>{this.ready&&setTimeout((()=>this.emit("close",n,i)),0),this.ready=!1,this.socket=void 0,1e3!==n&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||0===this.max_reconnects)&&(this.reconnect_timer_id=setTimeout((()=>this._connect(e,r)),this.reconnect_interval)))}))}}r.A=CommonClient},172208:(e,r,n)=>{const i=n(828985);class WebSocketBrowserImpl extends i.EventEmitter{socket;constructor(e,r,n){super(),this.socket=new window.WebSocket(e,n),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=e=>this.emit("message",e.data),this.socket.onerror=e=>this.emit("error",e),this.socket.onclose=e=>{this.emit("close",e.code,e.reason)}}send(e,r,n){const i=n||r;try{this.socket.send(e),i()}catch(e){i(e)}}close(e,r){this.socket.close(e,r)}addEventListener(e,r,n){this.socket.addEventListener(e,r,n)}}r.A=function default_1(e,r){return new WebSocketBrowserImpl(e,r)}},678180:(e,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.createError=r.DefaultDataPack=void 0;const n=new Map([[-32e3,"Event not provided"],[-32600,"Invalid Request"],[-32601,"Method not found"],[-32602,"Invalid params"],[-32603,"Internal error"],[-32604,"Params not found"],[-32605,"Method forbidden"],[-32606,"Event forbidden"],[-32700,"Parse error"]]);r.DefaultDataPack=class DefaultDataPack{encode(e){return JSON.stringify(e)}decode(e){return JSON.parse(e)}},r.createError=function createError(e,r){const i={code:e,message:n.get(e)||"Internal Server Error"};return r&&(i.data=r),i}},692363:(e,r,n)=>{n.d(r,{lc:()=>bool,jE:()=>publicKey,_l:()=>w});var i=n(878918),s=n(856115);const base_encodeDecode=e=>({decode:e.decode.bind(e),encode:e.encode.bind(e)});var a=n(901048).Buffer;const bigInt=e=>r=>{const n=(0,i.blob)(e,r),{encode:w,decode:k}=base_encodeDecode(n),I=n;return I.decode=(e,r)=>{const n=k(e,r);return(0,s.toBigIntLE)(a.from(n))},I.encode=(r,n,i)=>{const a=(0,s.toBufferLE)(r,e);return w(a,n,i)},I},bigIntBE=e=>r=>{const n=(0,i.blob)(e,r),{encode:w,decode:k}=base_encodeDecode(n),I=n;return I.decode=(e,r)=>{const n=k(e,r);return(0,s.toBigIntBE)(a.from(n))},I.encode=(r,n,i)=>{const a=(0,s.toBufferBE)(r,e);return w(a,n,i)},I},w=bigInt(8);bigIntBE(8),bigInt(16),bigIntBE(16),bigInt(24),bigIntBE(24),bigInt(32),bigIntBE(32);new(n(241440).A)("1e+18");const bool=e=>{const r=(0,i.u8)(e),{encode:n,decode:s}=base_encodeDecode(r),a=r;return a.decode=(e,r)=>!!s(e,r),a.encode=(e,r,i)=>{const s=Number(e);return n(s,r,i)},a};var k=n(629862);const publicKey=e=>{const r=(0,i.blob)(32,e),{encode:n,decode:s}=base_encodeDecode(r),a=r;return a.decode=(e,r)=>{const n=s(e,r);return new k.PublicKey(n)},a.encode=(e,r,i)=>{const s=e.toBuffer();return n(s,r,i)},a}},629862:(e,r,n)=>{n.r(r),n.d(r,{Account:()=>Account,AddressLookupTableAccount:()=>AddressLookupTableAccount,AddressLookupTableInstruction:()=>AddressLookupTableInstruction,AddressLookupTableProgram:()=>AddressLookupTableProgram,Authorized:()=>Authorized,BLOCKHASH_CACHE_TIMEOUT_MS:()=>ki,BPF_LOADER_DEPRECATED_PROGRAM_ID:()=>mn,BPF_LOADER_PROGRAM_ID:()=>hi,BpfLoader:()=>BpfLoader,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS:()=>cs,ComputeBudgetInstruction:()=>ComputeBudgetInstruction,ComputeBudgetProgram:()=>ComputeBudgetProgram,Connection:()=>Connection,Ed25519Program:()=>Ed25519Program,Enum:()=>Enum,EpochSchedule:()=>EpochSchedule,FeeCalculatorLayout:()=>oi,Keypair:()=>Keypair,LAMPORTS_PER_SOL:()=>ks,LOOKUP_TABLE_INSTRUCTION_LAYOUTS:()=>as,Loader:()=>Loader,Lockup:()=>Lockup,MAX_SEED_LENGTH:()=>ln,Message:()=>Message,MessageAccountKeys:()=>MessageAccountKeys,MessageV0:()=>MessageV0,NONCE_ACCOUNT_LENGTH:()=>ai,NonceAccount:()=>NonceAccount,PACKET_DATA_SIZE:()=>yn,PUBLIC_KEY_LENGTH:()=>gn,PublicKey:()=>PublicKey,SIGNATURE_LENGTH_IN_BYTES:()=>kn,SOLANA_SCHEMA:()=>un,STAKE_CONFIG_ID:()=>fs,STAKE_INSTRUCTION_LAYOUTS:()=>gs,SYSTEM_INSTRUCTION_LAYOUTS:()=>di,SYSVAR_CLOCK_PUBKEY:()=>Wn,SYSVAR_EPOCH_SCHEDULE_PUBKEY:()=>Hn,SYSVAR_INSTRUCTIONS_PUBKEY:()=>Zn,SYSVAR_RECENT_BLOCKHASHES_PUBKEY:()=>Qn,SYSVAR_RENT_PUBKEY:()=>ei,SYSVAR_REWARDS_PUBKEY:()=>ti,SYSVAR_SLOT_HASHES_PUBKEY:()=>ri,SYSVAR_SLOT_HISTORY_PUBKEY:()=>ni,SYSVAR_STAKE_HISTORY_PUBKEY:()=>ii,Secp256k1Program:()=>Secp256k1Program,SendTransactionError:()=>SendTransactionError,SolanaJSONRPCError:()=>SolanaJSONRPCError,SolanaJSONRPCErrorCode:()=>mi,StakeAuthorizationLayout:()=>ps,StakeInstruction:()=>StakeInstruction,StakeProgram:()=>StakeProgram,Struct:()=>Struct,SystemInstruction:()=>SystemInstruction,SystemProgram:()=>SystemProgram,Transaction:()=>Transaction,TransactionExpiredBlockheightExceededError:()=>TransactionExpiredBlockheightExceededError,TransactionExpiredNonceInvalidError:()=>TransactionExpiredNonceInvalidError,TransactionExpiredTimeoutError:()=>TransactionExpiredTimeoutError,TransactionInstruction:()=>TransactionInstruction,TransactionMessage:()=>TransactionMessage,TransactionStatus:()=>Bn,VALIDATOR_INFO_KEY:()=>bs,VERSION_PREFIX_MASK:()=>bn,VOTE_PROGRAM_ID:()=>ws,ValidatorInfo:()=>ValidatorInfo,VersionedMessage:()=>Cn,VersionedTransaction:()=>VersionedTransaction,VoteAccount:()=>VoteAccount,VoteAuthorizationLayout:()=>ys,VoteInit:()=>VoteInit,VoteInstruction:()=>VoteInstruction,VoteProgram:()=>VoteProgram,clusterApiUrl:()=>clusterApiUrl,sendAndConfirmRawTransaction:()=>sendAndConfirmRawTransaction,sendAndConfirmTransaction:()=>sendAndConfirmTransaction});var i={};n.r(i),n.d(i,{DO:()=>utils_abytes,OG:()=>bitMask,My:()=>abstract_utils_bytesToHex,bytesToNumberBE:()=>utils_bytesToNumberBE,lX:()=>utils_bytesToNumberLE,Id:()=>abstract_utils_concatBytes,fg:()=>createHmacDrbg,qj:()=>utils_ensureBytes,hexToBytes:()=>utils_hexToBytes,aY:()=>abstract_utils_isBytes,lq:()=>utils_numberToBytesBE,z:()=>utils_numberToBytesLE,Q5:()=>validateObject});var s=n(901048);function number(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function bytes(e,...r){if(!function isBytes(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}(e))throw new Error("Uint8Array expected");if(r.length>0&&!r.includes(e.length))throw new Error(`Uint8Array expected of length ${r}, not of length=${e.length}`)}function _assert_hash(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");number(e.outputLen),number(e.blockLen)}function exists(e,r=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(r&&e.finished)throw new Error("Hash#digest() has already been called")}function output(e,r){bytes(e);const n=r.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const a="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;const createView=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),rotr=(e,r)=>e<<32-r|e>>>r,w=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],byteSwap=e=>e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255;function byteSwap32(e){for(let r=0;r<e.length;r++)e[r]=byteSwap(e[r])}function utils_utf8ToBytes(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}function toBytes(e){return"string"==typeof e&&(e=utils_utf8ToBytes(e)),bytes(e),e}function utils_concatBytes(...e){let r=0;for(let n=0;n<e.length;n++){const i=e[n];bytes(i),r+=i.length}const n=new Uint8Array(r);for(let r=0,i=0;r<e.length;r++){const s=e[r];n.set(s,i),i+=s.length}return n}class Hash{clone(){return this._cloneInto()}}function utils_wrapConstructor(e){const hashC=r=>e().update(toBytes(r)).digest(),r=e();return hashC.outputLen=r.outputLen,hashC.blockLen=r.blockLen,hashC.create=()=>e(),hashC}function utils_randomBytes(e=32){if(a&&"function"==typeof a.getRandomValues)return a.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}const Maj=(e,r,n)=>e&r^e&n^r&n;class HashMD extends Hash{constructor(e,r,n,i){super(),this.blockLen=e,this.outputLen=r,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView(this.buffer)}update(e){exists(this);const{view:r,buffer:n,blockLen:i}=this,s=(e=toBytes(e)).length;for(let a=0;a<s;){const w=Math.min(i-this.pos,s-a);if(w!==i)n.set(e.subarray(a,a+w),this.pos),this.pos+=w,a+=w,this.pos===i&&(this.process(r,0),this.pos=0);else{const r=createView(e);for(;i<=s-a;a+=i)this.process(r,a)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){exists(this),output(e,this),this.finished=!0;const{buffer:r,view:n,blockLen:i,isLE:s}=this;let{pos:a}=this;r[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>i-a&&(this.process(n,0),a=0);for(let e=a;e<i;e++)r[e]=0;!function setBigUint64(e,r,n,i){if("function"==typeof e.setBigUint64)return e.setBigUint64(r,n,i);const s=BigInt(32),a=BigInt(4294967295),w=Number(n>>s&a),k=Number(n&a),I=i?4:0,we=i?0:4;e.setUint32(r+I,w,i),e.setUint32(r+we,k,i)}(n,i-8,BigInt(8*this.length),s),this.process(n,0);const w=createView(e),k=this.outputLen;if(k%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const I=k/4,we=this.get();if(I>we.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<I;e++)w.setUint32(4*e,we[e],s)}digest(){const{buffer:e,outputLen:r}=this;this.digestInto(e);const n=e.slice(0,r);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:r,buffer:n,length:i,finished:s,destroyed:a,pos:w}=this;return e.length=i,e.pos=w,e.finished=s,e.destroyed=a,i%r&&e.buffer.set(n),e}}const k=BigInt(2**32-1),I=BigInt(32);function fromBig(e,r=!1){return r?{h:Number(e&k),l:Number(e>>I&k)}:{h:0|Number(e>>I&k),l:0|Number(e&k)}}function split(e,r=!1){let n=new Uint32Array(e.length),i=new Uint32Array(e.length);for(let s=0;s<e.length;s++){const{h:a,l:w}=fromBig(e[s],r);[n[s],i[s]]=[a,w]}return[n,i]}const rotlSH=(e,r,n)=>e<<n|r>>>32-n,rotlSL=(e,r,n)=>r<<n|e>>>32-n,rotlBH=(e,r,n)=>r<<n-32|e>>>64-n,rotlBL=(e,r,n)=>e<<n-32|r>>>64-n;const we={fromBig,split,toBig:(e,r)=>BigInt(e>>>0)<<I|BigInt(r>>>0),shrSH:(e,r,n)=>e>>>n,shrSL:(e,r,n)=>e<<32-n|r>>>n,rotrSH:(e,r,n)=>e>>>n|r<<32-n,rotrSL:(e,r,n)=>e<<32-n|r>>>n,rotrBH:(e,r,n)=>e<<64-n|r>>>n-32,rotrBL:(e,r,n)=>e>>>n-32|r<<64-n,rotr32H:(e,r)=>r,rotr32L:(e,r)=>e,rotlSH,rotlSL,rotlBH,rotlBL,add:function add(e,r,n,i){const s=(r>>>0)+(i>>>0);return{h:e+n+(s/2**32|0)|0,l:0|s}},add3L:(e,r,n)=>(e>>>0)+(r>>>0)+(n>>>0),add3H:(e,r,n,i)=>r+n+i+(e/2**32|0)|0,add4L:(e,r,n,i)=>(e>>>0)+(r>>>0)+(n>>>0)+(i>>>0),add4H:(e,r,n,i,s)=>r+n+i+s+(e/2**32|0)|0,add5H:(e,r,n,i,s,a)=>r+n+i+s+a+(e/2**32|0)|0,add5L:(e,r,n,i,s)=>(e>>>0)+(r>>>0)+(n>>>0)+(i>>>0)+(s>>>0)},[Ae,Ce]=(()=>we.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((e=>BigInt(e)))))(),Be=new Uint32Array(80),ze=new Uint32Array(80);class SHA512 extends HashMD{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:r,Bh:n,Bl:i,Ch:s,Cl:a,Dh:w,Dl:k,Eh:I,El:we,Fh:Ae,Fl:Ce,Gh:Be,Gl:ze,Hh:qe,Hl:$e}=this;return[e,r,n,i,s,a,w,k,I,we,Ae,Ce,Be,ze,qe,$e]}set(e,r,n,i,s,a,w,k,I,we,Ae,Ce,Be,ze,qe,$e){this.Ah=0|e,this.Al=0|r,this.Bh=0|n,this.Bl=0|i,this.Ch=0|s,this.Cl=0|a,this.Dh=0|w,this.Dl=0|k,this.Eh=0|I,this.El=0|we,this.Fh=0|Ae,this.Fl=0|Ce,this.Gh=0|Be,this.Gl=0|ze,this.Hh=0|qe,this.Hl=0|$e}process(e,r){for(let n=0;n<16;n++,r+=4)Be[n]=e.getUint32(r),ze[n]=e.getUint32(r+=4);for(let e=16;e<80;e++){const r=0|Be[e-15],n=0|ze[e-15],i=we.rotrSH(r,n,1)^we.rotrSH(r,n,8)^we.shrSH(r,n,7),s=we.rotrSL(r,n,1)^we.rotrSL(r,n,8)^we.shrSL(r,n,7),a=0|Be[e-2],w=0|ze[e-2],k=we.rotrSH(a,w,19)^we.rotrBH(a,w,61)^we.shrSH(a,w,6),I=we.rotrSL(a,w,19)^we.rotrBL(a,w,61)^we.shrSL(a,w,6),Ae=we.add4L(s,I,ze[e-7],ze[e-16]),Ce=we.add4H(Ae,i,k,Be[e-7],Be[e-16]);Be[e]=0|Ce,ze[e]=0|Ae}let{Ah:n,Al:i,Bh:s,Bl:a,Ch:w,Cl:k,Dh:I,Dl:qe,Eh:$e,El:Ye,Fh:Je,Fl:et,Gh:rt,Gl:it,Hh:ot,Hl:ht}=this;for(let e=0;e<80;e++){const r=we.rotrSH($e,Ye,14)^we.rotrSH($e,Ye,18)^we.rotrBH($e,Ye,41),ft=we.rotrSL($e,Ye,14)^we.rotrSL($e,Ye,18)^we.rotrBL($e,Ye,41),pt=$e&Je^~$e&rt,yt=Ye&et^~Ye&it,_t=we.add5L(ht,ft,yt,Ce[e],ze[e]),St=we.add5H(_t,ot,r,pt,Ae[e],Be[e]),kt=0|_t,Dt=we.rotrSH(n,i,28)^we.rotrBH(n,i,34)^we.rotrBH(n,i,39),Mt=we.rotrSL(n,i,28)^we.rotrBL(n,i,34)^we.rotrBL(n,i,39),qt=n&s^n&w^s&w,Gt=i&a^i&k^a&k;ot=0|rt,ht=0|it,rt=0|Je,it=0|et,Je=0|$e,et=0|Ye,({h:$e,l:Ye}=we.add(0|I,0|qe,0|St,0|kt)),I=0|w,qe=0|k,w=0|s,k=0|a,s=0|n,a=0|i;const Qt=we.add3L(kt,Mt,Gt);n=we.add3H(Qt,St,Dt,qt),i=0|Qt}({h:n,l:i}=we.add(0|this.Ah,0|this.Al,0|n,0|i)),({h:s,l:a}=we.add(0|this.Bh,0|this.Bl,0|s,0|a)),({h:w,l:k}=we.add(0|this.Ch,0|this.Cl,0|w,0|k)),({h:I,l:qe}=we.add(0|this.Dh,0|this.Dl,0|I,0|qe)),({h:$e,l:Ye}=we.add(0|this.Eh,0|this.El,0|$e,0|Ye)),({h:Je,l:et}=we.add(0|this.Fh,0|this.Fl,0|Je,0|et)),({h:rt,l:it}=we.add(0|this.Gh,0|this.Gl,0|rt,0|it)),({h:ot,l:ht}=we.add(0|this.Hh,0|this.Hl,0|ot,0|ht)),this.set(n,i,s,a,w,k,I,qe,$e,Ye,Je,et,rt,it,ot,ht)}roundClean(){Be.fill(0),ze.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const qe=utils_wrapConstructor((()=>new SHA512)),$e=(BigInt(0),BigInt(1)),Ye=BigInt(2);function abstract_utils_isBytes(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}function utils_abytes(e){if(!abstract_utils_isBytes(e))throw new Error("Uint8Array expected")}const Je=Array.from({length:256},((e,r)=>r.toString(16).padStart(2,"0")));function abstract_utils_bytesToHex(e){utils_abytes(e);let r="";for(let n=0;n<e.length;n++)r+=Je[e[n]];return r}function hexToNumber(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}const et={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function utils_asciiToBase16(e){return e>=et._0&&e<=et._9?e-et._0:e>=et._A&&e<=et._F?e-(et._A-10):e>=et._a&&e<=et._f?e-(et._a-10):void 0}function utils_hexToBytes(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const r=e.length,n=r/2;if(r%2)throw new Error("padded hex string expected, got unpadded hex of length "+r);const i=new Uint8Array(n);for(let r=0,s=0;r<n;r++,s+=2){const n=utils_asciiToBase16(e.charCodeAt(s)),a=utils_asciiToBase16(e.charCodeAt(s+1));if(void 0===n||void 0===a){const r=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+r+'" at index '+s)}i[r]=16*n+a}return i}function utils_bytesToNumberBE(e){return hexToNumber(abstract_utils_bytesToHex(e))}function utils_bytesToNumberLE(e){return utils_abytes(e),hexToNumber(abstract_utils_bytesToHex(Uint8Array.from(e).reverse()))}function utils_numberToBytesBE(e,r){return utils_hexToBytes(e.toString(16).padStart(2*r,"0"))}function utils_numberToBytesLE(e,r){return utils_numberToBytesBE(e,r).reverse()}function utils_ensureBytes(e,r,n){let i;if("string"==typeof r)try{i=utils_hexToBytes(r)}catch(n){throw new Error(`${e} must be valid hex string, got "${r}". Cause: ${n}`)}else{if(!abstract_utils_isBytes(r))throw new Error(`${e} must be hex string or Uint8Array`);i=Uint8Array.from(r)}const s=i.length;if("number"==typeof n&&s!==n)throw new Error(`${e} expected ${n} bytes, got ${s}`);return i}function abstract_utils_concatBytes(...e){let r=0;for(let n=0;n<e.length;n++){const i=e[n];utils_abytes(i),r+=i.length}const n=new Uint8Array(r);for(let r=0,i=0;r<e.length;r++){const s=e[r];n.set(s,i),i+=s.length}return n}const bitMask=e=>(Ye<<BigInt(e-1))-$e,u8n=e=>new Uint8Array(e),u8fr=e=>Uint8Array.from(e);function createHmacDrbg(e,r,n){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof r||r<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let i=u8n(e),s=u8n(e),a=0;const reset=()=>{i.fill(1),s.fill(0),a=0},h=(...e)=>n(s,i,...e),reseed=(e=u8n())=>{s=h(u8fr([0]),e),i=h(),0!==e.length&&(s=h(u8fr([1]),e),i=h())},gen=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const n=[];for(;e<r;){i=h();const r=i.slice();n.push(r),e+=i.length}return abstract_utils_concatBytes(...n)};return(e,r)=>{let n;for(reset(),reseed(e);!(n=r(gen()));)reseed();return reset(),n}}const rt={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||abstract_utils_isBytes(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,r)=>r.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function validateObject(e,r,n={}){const checkField=(r,n,i)=>{const s=rt[n];if("function"!=typeof s)throw new Error(`Invalid validator "${n}", expected function`);const a=e[r];if(!(i&&void 0===a||s(a,e)))throw new Error(`Invalid param ${String(r)}=${a} (${typeof a}), expected ${n}`)};for(const[e,n]of Object.entries(r))checkField(e,n,!1);for(const[e,r]of Object.entries(n))checkField(e,r,!0);return e}const it=BigInt(0),ot=BigInt(1),ht=BigInt(2),ft=BigInt(3),pt=BigInt(4),yt=BigInt(5),_t=BigInt(8);BigInt(9),BigInt(16);function modular_mod(e,r){const n=e%r;return n>=it?n:r+n}function pow(e,r,n){if(n<=it||r<it)throw new Error("Expected power/modulo > 0");if(n===ot)return it;let i=ot;for(;r>it;)r&ot&&(i=i*e%n),e=e*e%n,r>>=ot;return i}function modular_pow2(e,r,n){let i=e;for(;r-- >it;)i*=i,i%=n;return i}function invert(e,r){if(e===it||r<=it)throw new Error(`invert: expected positive integers, got n=${e} mod=${r}`);let n=modular_mod(e,r),i=r,s=it,a=ot,w=ot,k=it;for(;n!==it;){const e=i/n,r=i%n,I=s-w*e,we=a-k*e;i=n,n=r,s=w,a=k,w=I,k=we}if(i!==ot)throw new Error("invert: does not exist");return modular_mod(s,r)}function FpSqrt(e){if(e%pt===ft){const r=(e+ot)/pt;return function sqrt3mod4(e,n){const i=e.pow(n,r);if(!e.eql(e.sqr(i),n))throw new Error("Cannot find square root");return i}}if(e%_t===yt){const r=(e-yt)/_t;return function sqrt5mod8(e,n){const i=e.mul(n,ht),s=e.pow(i,r),a=e.mul(n,s),w=e.mul(e.mul(a,ht),s),k=e.mul(a,e.sub(w,e.ONE));if(!e.eql(e.sqr(k),n))throw new Error("Cannot find square root");return k}}return function tonelliShanks(e){const r=(e-ot)/ht;let n,i,s;for(n=e-ot,i=0;n%ht===it;n/=ht,i++);for(s=ht;s<e&&pow(s,r,e)!==e-ot;s++);if(1===i){const r=(e+ot)/pt;return function tonelliFast(e,n){const i=e.pow(n,r);if(!e.eql(e.sqr(i),n))throw new Error("Cannot find square root");return i}}const a=(n+ot)/ht;return function tonelliSlow(e,w){if(e.pow(w,r)===e.neg(e.ONE))throw new Error("Cannot find square root");let k=i,I=e.pow(e.mul(e.ONE,s),n),we=e.pow(w,a),Ae=e.pow(w,n);for(;!e.eql(Ae,e.ONE);){if(e.eql(Ae,e.ZERO))return e.ZERO;let r=1;for(let n=e.sqr(Ae);r<k&&!e.eql(n,e.ONE);r++)n=e.sqr(n);const n=e.pow(I,ot<<BigInt(k-r-1));I=e.sqr(n),we=e.mul(we,n),Ae=e.mul(Ae,I),k=r}return we}}(e)}const modular_isNegativeLE=(e,r)=>(modular_mod(e,r)&ot)===ot,St=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function nLength(e,r){const n=void 0!==r?r:e.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function Field(e,r,n=!1,i={}){if(e<=it)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:s,nByteLength:a}=nLength(e,r);if(a>2048)throw new Error("Field lengths over 2048 bytes are not supported");const w=FpSqrt(e),k=Object.freeze({ORDER:e,BITS:s,BYTES:a,MASK:bitMask(s),ZERO:it,ONE:ot,create:r=>modular_mod(r,e),isValid:r=>{if("bigint"!=typeof r)throw new Error("Invalid field element: expected bigint, got "+typeof r);return it<=r&&r<e},is0:e=>e===it,isOdd:e=>(e&ot)===ot,neg:r=>modular_mod(-r,e),eql:(e,r)=>e===r,sqr:r=>modular_mod(r*r,e),add:(r,n)=>modular_mod(r+n,e),sub:(r,n)=>modular_mod(r-n,e),mul:(r,n)=>modular_mod(r*n,e),pow:(e,r)=>function FpPow(e,r,n){if(n<it)throw new Error("Expected power > 0");if(n===it)return e.ONE;if(n===ot)return r;let i=e.ONE,s=r;for(;n>it;)n&ot&&(i=e.mul(i,s)),s=e.sqr(s),n>>=ot;return i}(k,e,r),div:(r,n)=>modular_mod(r*invert(n,e),e),sqrN:e=>e*e,addN:(e,r)=>e+r,subN:(e,r)=>e-r,mulN:(e,r)=>e*r,inv:r=>invert(r,e),sqrt:i.sqrt||(e=>w(k,e)),invertBatch:e=>function FpInvertBatch(e,r){const n=new Array(r.length),i=r.reduce(((r,i,s)=>e.is0(i)?r:(n[s]=r,e.mul(r,i))),e.ONE),s=e.inv(i);return r.reduceRight(((r,i,s)=>e.is0(i)?r:(n[s]=e.mul(r,n[s]),e.mul(r,i))),s),n}(k,e),cmov:(e,r,n)=>n?r:e,toBytes:e=>n?utils_numberToBytesLE(e,a):utils_numberToBytesBE(e,a),fromBytes:e=>{if(e.length!==a)throw new Error(`Fp.fromBytes: expected ${a}, got ${e.length}`);return n?utils_bytesToNumberLE(e):utils_bytesToNumberBE(e)}});return Object.freeze(k)}function getFieldBytesLength(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const r=e.toString(2).length;return Math.ceil(r/8)}function getMinHashLength(e){const r=getFieldBytesLength(e);return r+Math.ceil(r/2)}const kt=BigInt(0),Dt=BigInt(1);function wNAF(e,r){const constTimeNegate=(e,r)=>{const n=r.negate();return e?n:r},opts=e=>({windows:Math.ceil(r/e)+1,windowSize:2**(e-1)});return{constTimeNegate,unsafeLadder(r,n){let i=e.ZERO,s=r;for(;n>kt;)n&Dt&&(i=i.add(s)),s=s.double(),n>>=Dt;return i},precomputeWindow(e,r){const{windows:n,windowSize:i}=opts(r),s=[];let a=e,w=a;for(let e=0;e<n;e++){w=a,s.push(w);for(let e=1;e<i;e++)w=w.add(a),s.push(w);a=w.double()}return s},wNAF(r,n,i){const{windows:s,windowSize:a}=opts(r);let w=e.ZERO,k=e.BASE;const I=BigInt(2**r-1),we=2**r,Ae=BigInt(r);for(let e=0;e<s;e++){const r=e*a;let s=Number(i&I);i>>=Ae,s>a&&(s-=we,i+=Dt);const Ce=r,Be=r+Math.abs(s)-1,ze=e%2!=0,qe=s<0;0===s?k=k.add(constTimeNegate(ze,n[Ce])):w=w.add(constTimeNegate(qe,n[Be]))}return{p:w,f:k}},wNAFCached(e,r,n,i){const s=e._WINDOW_SIZE||1;let a=r.get(e);return a||(a=this.precomputeWindow(e,s),1!==s&&r.set(e,i(a))),this.wNAF(s,a,n)}}}function validateBasic(e){return function validateField(e){return validateObject(e,St.reduce(((e,r)=>(e[r]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}(e.Fp),validateObject(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}const Mt=BigInt(0),qt=BigInt(1),Gt=BigInt(2),Qt=BigInt(8),er={zip215:!0};function twistedEdwards(e){const r=function validateOpts(e){const r=validateBasic(e);return validateObject(e,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...r})}(e),{Fp:n,n:i,prehash:s,hash:a,randomBytes:w,nByteLength:k,h:I}=r,we=Gt<<BigInt(8*k)-qt,Ae=n.create,Ce=r.uvRatio||((e,r)=>{try{return{isValid:!0,value:n.sqrt(e*n.inv(r))}}catch(e){return{isValid:!1,value:Mt}}}),Be=r.adjustScalarBytes||(e=>e),ze=r.domain||((e,r,n)=>{if(r.length||n)throw new Error("Contexts/pre-hash are not supported");return e}),inBig=e=>"bigint"==typeof e&&Mt<e,inRange=(e,r)=>inBig(e)&&inBig(r)&&e<r,in0MaskRange=e=>e===Mt||inRange(e,we);function assertInRange(e,r){if(inRange(e,r))return e;throw new Error(`Expected valid scalar < ${r}, got ${typeof e} ${e}`)}function assertGE0(e){return e===Mt?e:assertInRange(e,i)}const qe=new Map;function isPoint(e){if(!(e instanceof Point))throw new Error("ExtendedPoint expected")}class Point{constructor(e,r,n,i){if(this.ex=e,this.ey=r,this.ez=n,this.et=i,!in0MaskRange(e))throw new Error("x required");if(!in0MaskRange(r))throw new Error("y required");if(!in0MaskRange(n))throw new Error("z required");if(!in0MaskRange(i))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(e){if(e instanceof Point)throw new Error("extended point not allowed");const{x:r,y:n}=e||{};if(!in0MaskRange(r)||!in0MaskRange(n))throw new Error("invalid affine point");return new Point(r,n,qt,Ae(r*n))}static normalizeZ(e){const r=n.invertBatch(e.map((e=>e.ez)));return e.map(((e,n)=>e.toAffine(r[n]))).map(Point.fromAffine)}_setWindowSize(e){this._WINDOW_SIZE=e,qe.delete(this)}assertValidity(){const{a:e,d:n}=r;if(this.is0())throw new Error("bad point: ZERO");const{ex:i,ey:s,ez:a,et:w}=this,k=Ae(i*i),I=Ae(s*s),we=Ae(a*a),Ce=Ae(we*we),Be=Ae(k*e);if(Ae(we*Ae(Be+I))!==Ae(Ce+Ae(n*Ae(k*I))))throw new Error("bad point: equation left != right (1)");if(Ae(i*s)!==Ae(a*w))throw new Error("bad point: equation left != right (2)")}equals(e){isPoint(e);const{ex:r,ey:n,ez:i}=this,{ex:s,ey:a,ez:w}=e,k=Ae(r*w),I=Ae(s*i),we=Ae(n*w),Ce=Ae(a*i);return k===I&&we===Ce}is0(){return this.equals(Point.ZERO)}negate(){return new Point(Ae(-this.ex),this.ey,this.ez,Ae(-this.et))}double(){const{a:e}=r,{ex:n,ey:i,ez:s}=this,a=Ae(n*n),w=Ae(i*i),k=Ae(Gt*Ae(s*s)),I=Ae(e*a),we=n+i,Ce=Ae(Ae(we*we)-a-w),Be=I+w,ze=Be-k,qe=I-w,$e=Ae(Ce*ze),Ye=Ae(Be*qe),Je=Ae(Ce*qe),et=Ae(ze*Be);return new Point($e,Ye,et,Je)}add(e){isPoint(e);const{a:n,d:i}=r,{ex:s,ey:a,ez:w,et:k}=this,{ex:I,ey:we,ez:Ce,et:Be}=e;if(n===BigInt(-1)){const e=Ae((a-s)*(we+I)),r=Ae((a+s)*(we-I)),n=Ae(r-e);if(n===Mt)return this.double();const i=Ae(w*Gt*Be),ze=Ae(k*Gt*Ce),qe=ze+i,$e=r+e,Ye=ze-i,Je=Ae(qe*n),et=Ae($e*Ye),rt=Ae(qe*Ye),it=Ae(n*$e);return new Point(Je,et,it,rt)}const ze=Ae(s*I),qe=Ae(a*we),$e=Ae(k*i*Be),Ye=Ae(w*Ce),Je=Ae((s+a)*(I+we)-ze-qe),et=Ye-$e,rt=Ye+$e,it=Ae(qe-n*ze),ot=Ae(Je*et),ht=Ae(rt*it),ft=Ae(Je*it),pt=Ae(et*rt);return new Point(ot,ht,pt,ft)}subtract(e){return this.add(e.negate())}wNAF(e){return Je.wNAFCached(this,qe,e,Point.normalizeZ)}multiply(e){const{p:r,f:n}=this.wNAF(assertInRange(e,i));return Point.normalizeZ([r,n])[0]}multiplyUnsafe(e){let r=assertGE0(e);return r===Mt?Ye:this.equals(Ye)||r===qt?this:this.equals($e)?this.wNAF(r).p:Je.unsafeLadder(this,r)}isSmallOrder(){return this.multiplyUnsafe(I).is0()}isTorsionFree(){return Je.unsafeLadder(this,i).is0()}toAffine(e){const{ex:r,ey:i,ez:s}=this,a=this.is0();null==e&&(e=a?Qt:n.inv(s));const w=Ae(r*e),k=Ae(i*e),I=Ae(s*e);if(a)return{x:Mt,y:qt};if(I!==qt)throw new Error("invZ was invalid");return{x:w,y:k}}clearCofactor(){const{h:e}=r;return e===qt?this:this.multiplyUnsafe(e)}static fromHex(e,i=!1){const{d:s,a}=r,w=n.BYTES,k=(e=utils_ensureBytes("pointHex",e,w)).slice(),I=e[w-1];k[w-1]=-129&I;const Be=utils_bytesToNumberLE(k);Be===Mt||assertInRange(Be,i?we:n.ORDER);const ze=Ae(Be*Be),qe=Ae(ze-qt),$e=Ae(s*ze-a);let{isValid:Ye,value:Je}=Ce(qe,$e);if(!Ye)throw new Error("Point.fromHex: invalid y coordinate");const et=(Je&qt)===qt,rt=!!(128&I);if(!i&&Je===Mt&&rt)throw new Error("Point.fromHex: x=0 and x_0=1");return rt!==et&&(Je=Ae(-Je)),Point.fromAffine({x:Je,y:Be})}static fromPrivateKey(e){return getExtendedPublicKey(e).point}toRawBytes(){const{x:e,y:r}=this.toAffine(),i=utils_numberToBytesLE(r,n.BYTES);return i[i.length-1]|=e&qt?128:0,i}toHex(){return abstract_utils_bytesToHex(this.toRawBytes())}}Point.BASE=new Point(r.Gx,r.Gy,qt,Ae(r.Gx*r.Gy)),Point.ZERO=new Point(Mt,qt,qt,Mt);const{BASE:$e,ZERO:Ye}=Point,Je=wNAF(Point,8*k);function modN(e){return modular_mod(e,i)}function modN_LE(e){return modN(utils_bytesToNumberLE(e))}function getExtendedPublicKey(e){const r=k;e=utils_ensureBytes("private key",e,r);const n=utils_ensureBytes("hashed private key",a(e),2*r),i=Be(n.slice(0,r)),s=n.slice(r,2*r),w=modN_LE(i),I=$e.multiply(w),we=I.toRawBytes();return{head:i,prefix:s,scalar:w,point:I,pointBytes:we}}function hashDomainToScalar(e=new Uint8Array,...r){const n=abstract_utils_concatBytes(...r);return modN_LE(a(ze(n,utils_ensureBytes("context",e),!!s)))}const et=er;$e._setWindowSize(8);return{CURVE:r,getPublicKey:function getPublicKey(e){return getExtendedPublicKey(e).pointBytes},sign:function sign(e,r,i={}){e=utils_ensureBytes("message",e),s&&(e=s(e));const{prefix:a,scalar:w,pointBytes:I}=getExtendedPublicKey(r),we=hashDomainToScalar(i.context,a,e),Ae=$e.multiply(we).toRawBytes(),Ce=modN(we+hashDomainToScalar(i.context,Ae,I,e)*w);return assertGE0(Ce),utils_ensureBytes("result",abstract_utils_concatBytes(Ae,utils_numberToBytesLE(Ce,n.BYTES)),2*k)},verify:function verify(e,r,i,a=et){const{context:w,zip215:k}=a,I=n.BYTES;e=utils_ensureBytes("signature",e,2*I),r=utils_ensureBytes("message",r),s&&(r=s(r));const we=utils_bytesToNumberLE(e.slice(I,2*I));let Ae,Ce,Be;try{Ae=Point.fromHex(i,k),Ce=Point.fromHex(e.slice(0,I),k),Be=$e.multiplyUnsafe(we)}catch(e){return!1}if(!k&&Ae.isSmallOrder())return!1;const ze=hashDomainToScalar(w,Ce.toRawBytes(),Ae.toRawBytes(),r);return Ce.add(Ae.multiplyUnsafe(ze)).subtract(Be).clearCofactor().equals(Point.ZERO)},ExtendedPoint:Point,utils:{getExtendedPublicKey,randomPrivateKey:()=>w(n.BYTES),precompute:(e=8,r=Point.BASE)=>(r._setWindowSize(e),r.multiply(BigInt(3)),r)}}}const tr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),rr=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),nr=(BigInt(0),BigInt(1)),ir=BigInt(2),or=BigInt(5),sr=BigInt(10),ar=BigInt(20),cr=BigInt(40),ur=BigInt(80);function ed25519_pow_2_252_3(e){const r=tr,n=e*e%r*e%r,i=modular_pow2(n,ir,r)*n%r,s=modular_pow2(i,nr,r)*e%r,a=modular_pow2(s,or,r)*s%r,w=modular_pow2(a,sr,r)*a%r,k=modular_pow2(w,ar,r)*w%r,I=modular_pow2(k,cr,r)*k%r,we=modular_pow2(I,ur,r)*I%r,Ae=modular_pow2(we,ur,r)*I%r,Ce=modular_pow2(Ae,sr,r)*a%r;return{pow_p_5_8:modular_pow2(Ce,ir,r)*e%r,b2:n}}function adjustScalarBytes(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}function uvRatio(e,r){const n=tr,i=modular_mod(r*r*r,n),s=modular_mod(i*i*r,n);let a=modular_mod(e*i*ed25519_pow_2_252_3(e*s).pow_p_5_8,n);const w=modular_mod(r*a*a,n),k=a,I=modular_mod(a*rr,n),we=w===e,Ae=w===modular_mod(-e,n),Ce=w===modular_mod(-e*rr,n);return we&&(a=k),(Ae||Ce)&&(a=I),modular_isNegativeLE(a,n)&&(a=modular_mod(-a,n)),{isValid:we||Ae,value:a}}const dr=Field(tr,void 0,!0),lr={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:dr,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:qe,randomBytes:utils_randomBytes,adjustScalarBytes,uvRatio},hr=twistedEdwards(lr);function ed25519_domain(e,r,n){if(r.length>255)throw new Error("Context is too big");return utils_concatBytes(utils_utf8ToBytes("SigEd25519 no Ed25519 collisions"),new Uint8Array([n?1:0,r.length]),r,e)}const fr=(dr.ORDER+BigInt(3))/BigInt(8);dr.pow(ir,fr),dr.sqrt(dr.neg(dr.ONE)),dr.ORDER,BigInt(5),BigInt(8),BigInt(486662);(function FpSqrtEven(e,r){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const n=e.sqrt(r);return e.isOdd(n)?e.neg(n):n})(dr,dr.neg(BigInt(486664)));BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");var gr=n(682823),pr=n.n(gr),mr=n(939216),yr=n.n(mr);const br=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),_r=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),wr=new Uint32Array(64);class SHA256 extends HashMD{constructor(){super(64,32,8,!1),this.A=0|_r[0],this.B=0|_r[1],this.C=0|_r[2],this.D=0|_r[3],this.E=0|_r[4],this.F=0|_r[5],this.G=0|_r[6],this.H=0|_r[7]}get(){const{A:e,B:r,C:n,D:i,E:s,F:a,G:w,H:k}=this;return[e,r,n,i,s,a,w,k]}set(e,r,n,i,s,a,w,k){this.A=0|e,this.B=0|r,this.C=0|n,this.D=0|i,this.E=0|s,this.F=0|a,this.G=0|w,this.H=0|k}process(e,r){for(let n=0;n<16;n++,r+=4)wr[n]=e.getUint32(r,!1);for(let e=16;e<64;e++){const r=wr[e-15],n=wr[e-2],i=rotr(r,7)^rotr(r,18)^r>>>3,s=rotr(n,17)^rotr(n,19)^n>>>10;wr[e]=s+wr[e-7]+i+wr[e-16]|0}let{A:n,B:i,C:s,D:a,E:w,F:k,G:I,H:we}=this;for(let e=0;e<64;e++){const r=we+(rotr(w,6)^rotr(w,11)^rotr(w,25))+((Ae=w)&k^~Ae&I)+br[e]+wr[e]|0,Ce=(rotr(n,2)^rotr(n,13)^rotr(n,22))+Maj(n,i,s)|0;we=I,I=k,k=w,w=a+r|0,a=s,s=i,i=n,n=r+Ce|0}var Ae;n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,a=a+this.D|0,w=w+this.E|0,k=k+this.F|0,I=I+this.G|0,we=we+this.H|0,this.set(n,i,s,a,w,k,I,we)}roundClean(){wr.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Sr=utils_wrapConstructor((()=>new SHA256));var Er=n(881818),kr=n(878918),Ar=n(856115),Ir=n(727801),Rr=n(759499),vr=n.n(Rr),Or=n(69026),xr=n(131392);const Tr=[],Nr=[],Pr=[],Cr=BigInt(0),Br=BigInt(1),Lr=BigInt(2),zr=BigInt(7),Dr=BigInt(256),Kr=BigInt(113);for(let e=0,r=Br,n=1,i=0;e<24;e++){[n,i]=[i,(2*n+3*i)%5],Tr.push(2*(5*i+n)),Nr.push((e+1)*(e+2)/2%64);let s=Cr;for(let e=0;e<7;e++)r=(r<<Br^(r>>zr)*Kr)%Dr,r&Lr&&(s^=Br<<(Br<<BigInt(e))-Br);Pr.push(s)}const[Ur,Mr]=split(Pr,!0),rotlH=(e,r,n)=>n>32?rotlBH(e,r,n):rotlSH(e,r,n),rotlL=(e,r,n)=>n>32?rotlBL(e,r,n):rotlSL(e,r,n);class Keccak extends Hash{constructor(e,r,n,i=!1,s=24){if(super(),this.blockLen=e,this.suffix=r,this.outputLen=n,this.enableXOF=i,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,number(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var a;this.state=new Uint8Array(200),this.state32=(a=this.state,new Uint32Array(a.buffer,a.byteOffset,Math.floor(a.byteLength/4)))}keccak(){w||byteSwap32(this.state32),function keccakP(e,r=24){const n=new Uint32Array(10);for(let i=24-r;i<24;i++){for(let r=0;r<10;r++)n[r]=e[r]^e[r+10]^e[r+20]^e[r+30]^e[r+40];for(let r=0;r<10;r+=2){const i=(r+8)%10,s=(r+2)%10,a=n[s],w=n[s+1],k=rotlH(a,w,1)^n[i],I=rotlL(a,w,1)^n[i+1];for(let n=0;n<50;n+=10)e[r+n]^=k,e[r+n+1]^=I}let r=e[2],s=e[3];for(let n=0;n<24;n++){const i=Nr[n],a=rotlH(r,s,i),w=rotlL(r,s,i),k=Tr[n];r=e[k],s=e[k+1],e[k]=a,e[k+1]=w}for(let r=0;r<50;r+=10){for(let i=0;i<10;i++)n[i]=e[r+i];for(let i=0;i<10;i++)e[r+i]^=~n[(i+2)%10]&n[(i+4)%10]}e[0]^=Ur[i],e[1]^=Mr[i]}n.fill(0)}(this.state32,this.rounds),w||byteSwap32(this.state32),this.posOut=0,this.pos=0}update(e){exists(this);const{blockLen:r,state:n}=this,i=(e=toBytes(e)).length;for(let s=0;s<i;){const a=Math.min(r-this.pos,i-s);for(let r=0;r<a;r++)n[this.pos++]^=e[s++];this.pos===r&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:r,pos:n,blockLen:i}=this;e[n]^=r,128&r&&n===i-1&&this.keccak(),e[i-1]^=128,this.keccak()}writeInto(e){exists(this,!1),bytes(e),this.finish();const r=this.state,{blockLen:n}=this;for(let i=0,s=e.length;i<s;){this.posOut>=n&&this.keccak();const a=Math.min(n-this.posOut,s-i);e.set(r.subarray(this.posOut,this.posOut+a),i),this.posOut+=a,i+=a}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return number(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(output(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:r,suffix:n,outputLen:i,rounds:s,enableXOF:a}=this;return e||(e=new Keccak(r,n,i,a,s)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=s,e.suffix=n,e.outputLen=i,e.enableXOF=a,e.destroyed=this.destroyed,e}}const gen=(e,r,n)=>utils_wrapConstructor((()=>new Keccak(r,e,n))),Fr=gen(1,136,32);class HMAC extends Hash{constructor(e,r){super(),this.finished=!1,this.destroyed=!1,_assert_hash(e);const n=toBytes(r);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(n.length>i?e.create().update(n).digest():n);for(let e=0;e<s.length;e++)s[e]^=54;this.iHash.update(s),this.oHash=e.create();for(let e=0;e<s.length;e++)s[e]^=106;this.oHash.update(s),s.fill(0)}update(e){return exists(this),this.iHash.update(e),this}digestInto(e){exists(this),bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:n,finished:i,destroyed:s,blockLen:a,outputLen:w}=this;return e.finished=i,e.destroyed=s,e.blockLen=a,e.outputLen=w,e.oHash=r._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(e,r,n)=>new HMAC(e,r).update(n).digest();hmac.create=(e,r)=>new HMAC(e,r);const{bytesToNumberBE:Wr,hexToBytes:qr}=i,Vr={Err:class DERErr extends Error{constructor(e=""){super(e)}},_parseInt(e){const{Err:r}=Vr;if(e.length<2||2!==e[0])throw new r("Invalid signature integer tag");const n=e[1],i=e.subarray(2,n+2);if(!n||i.length!==n)throw new r("Invalid signature integer: wrong length");if(128&i[0])throw new r("Invalid signature integer: negative");if(0===i[0]&&!(128&i[1]))throw new r("Invalid signature integer: unnecessary leading zero");return{d:Wr(i),l:e.subarray(n+2)}},toSig(e){const{Err:r}=Vr,n="string"==typeof e?qr(e):e;utils_abytes(n);let i=n.length;if(i<2||48!=n[0])throw new r("Invalid signature tag");if(n[1]!==i-2)throw new r("Invalid signature: incorrect length");const{d:s,l:a}=Vr._parseInt(n.subarray(2)),{d:w,l:k}=Vr._parseInt(a);if(k.length)throw new r("Invalid signature: left bytes after parsing");return{r:s,s:w}},hexFromSig(e){const slice=e=>8&Number.parseInt(e[0],16)?"00"+e:e,h=e=>{const r=e.toString(16);return 1&r.length?`0${r}`:r},r=slice(h(e.s)),n=slice(h(e.r)),i=r.length/2,s=n.length/2,a=h(i),w=h(s);return`30${h(s+i+4)}02${w}${n}02${a}${r}`}},jr=BigInt(0),Hr=BigInt(1),$r=(BigInt(2),BigInt(3));BigInt(4);function weierstrassPoints(e){const r=function validatePointOpts(e){const r=validateBasic(e);validateObject(r,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:i,a:s}=r;if(n){if(!i.eql(s,i.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...r})}(e),{Fp:n}=r,i=r.toBytes||((e,r,i)=>{const s=r.toAffine();return abstract_utils_concatBytes(Uint8Array.from([4]),n.toBytes(s.x),n.toBytes(s.y))}),s=r.fromBytes||(e=>{const r=e.subarray(1);return{x:n.fromBytes(r.subarray(0,n.BYTES)),y:n.fromBytes(r.subarray(n.BYTES,2*n.BYTES))}});function weierstrassEquation(e){const{a:i,b:s}=r,a=n.sqr(e),w=n.mul(a,e);return n.add(n.add(w,n.mul(e,i)),s)}if(!n.eql(n.sqr(r.Gy),weierstrassEquation(r.Gx)))throw new Error("bad generator point: equation left != right");function isWithinCurveOrder(e){return"bigint"==typeof e&&jr<e&&e<r.n}function assertGE(e){if(!isWithinCurveOrder(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function normPrivateKeyToScalar(e){const{allowedPrivateKeyLengths:n,nByteLength:i,wrapPrivateKey:s,n:a}=r;if(n&&"bigint"!=typeof e){if(abstract_utils_isBytes(e)&&(e=abstract_utils_bytesToHex(e)),"string"!=typeof e||!n.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*i,"0")}let w;try{w="bigint"==typeof e?e:utils_bytesToNumberBE(utils_ensureBytes("private key",e,i))}catch(r){throw new Error(`private key must be ${i} bytes, hex or bigint, not ${typeof e}`)}return s&&(w=modular_mod(w,a)),assertGE(w),w}const a=new Map;function assertPrjPoint(e){if(!(e instanceof Point))throw new Error("ProjectivePoint expected")}class Point{constructor(e,r,i){if(this.px=e,this.py=r,this.pz=i,null==e||!n.isValid(e))throw new Error("x required");if(null==r||!n.isValid(r))throw new Error("y required");if(null==i||!n.isValid(i))throw new Error("z required")}static fromAffine(e){const{x:r,y:i}=e||{};if(!e||!n.isValid(r)||!n.isValid(i))throw new Error("invalid affine point");if(e instanceof Point)throw new Error("projective point not allowed");const is0=e=>n.eql(e,n.ZERO);return is0(r)&&is0(i)?Point.ZERO:new Point(r,i,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const r=n.invertBatch(e.map((e=>e.pz)));return e.map(((e,n)=>e.toAffine(r[n]))).map(Point.fromAffine)}static fromHex(e){const r=Point.fromAffine(s(utils_ensureBytes("pointHex",e)));return r.assertValidity(),r}static fromPrivateKey(e){return Point.BASE.multiply(normPrivateKeyToScalar(e))}_setWindowSize(e){this._WINDOW_SIZE=e,a.delete(this)}assertValidity(){if(this.is0()){if(r.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:e,y:i}=this.toAffine();if(!n.isValid(e)||!n.isValid(i))throw new Error("bad point: x or y not FE");const s=n.sqr(i),a=weierstrassEquation(e);if(!n.eql(s,a))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(n.isOdd)return!n.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){assertPrjPoint(e);const{px:r,py:i,pz:s}=this,{px:a,py:w,pz:k}=e,I=n.eql(n.mul(r,k),n.mul(a,s)),we=n.eql(n.mul(i,k),n.mul(w,s));return I&&we}negate(){return new Point(this.px,n.neg(this.py),this.pz)}double(){const{a:e,b:i}=r,s=n.mul(i,$r),{px:a,py:w,pz:k}=this;let I=n.ZERO,we=n.ZERO,Ae=n.ZERO,Ce=n.mul(a,a),Be=n.mul(w,w),ze=n.mul(k,k),qe=n.mul(a,w);return qe=n.add(qe,qe),Ae=n.mul(a,k),Ae=n.add(Ae,Ae),I=n.mul(e,Ae),we=n.mul(s,ze),we=n.add(I,we),I=n.sub(Be,we),we=n.add(Be,we),we=n.mul(I,we),I=n.mul(qe,I),Ae=n.mul(s,Ae),ze=n.mul(e,ze),qe=n.sub(Ce,ze),qe=n.mul(e,qe),qe=n.add(qe,Ae),Ae=n.add(Ce,Ce),Ce=n.add(Ae,Ce),Ce=n.add(Ce,ze),Ce=n.mul(Ce,qe),we=n.add(we,Ce),ze=n.mul(w,k),ze=n.add(ze,ze),Ce=n.mul(ze,qe),I=n.sub(I,Ce),Ae=n.mul(ze,Be),Ae=n.add(Ae,Ae),Ae=n.add(Ae,Ae),new Point(I,we,Ae)}add(e){assertPrjPoint(e);const{px:i,py:s,pz:a}=this,{px:w,py:k,pz:I}=e;let we=n.ZERO,Ae=n.ZERO,Ce=n.ZERO;const Be=r.a,ze=n.mul(r.b,$r);let qe=n.mul(i,w),$e=n.mul(s,k),Ye=n.mul(a,I),Je=n.add(i,s),et=n.add(w,k);Je=n.mul(Je,et),et=n.add(qe,$e),Je=n.sub(Je,et),et=n.add(i,a);let rt=n.add(w,I);return et=n.mul(et,rt),rt=n.add(qe,Ye),et=n.sub(et,rt),rt=n.add(s,a),we=n.add(k,I),rt=n.mul(rt,we),we=n.add($e,Ye),rt=n.sub(rt,we),Ce=n.mul(Be,et),we=n.mul(ze,Ye),Ce=n.add(we,Ce),we=n.sub($e,Ce),Ce=n.add($e,Ce),Ae=n.mul(we,Ce),$e=n.add(qe,qe),$e=n.add($e,qe),Ye=n.mul(Be,Ye),et=n.mul(ze,et),$e=n.add($e,Ye),Ye=n.sub(qe,Ye),Ye=n.mul(Be,Ye),et=n.add(et,Ye),qe=n.mul($e,et),Ae=n.add(Ae,qe),qe=n.mul(rt,et),we=n.mul(Je,we),we=n.sub(we,qe),qe=n.mul(Je,$e),Ce=n.mul(rt,Ce),Ce=n.add(Ce,qe),new Point(we,Ae,Ce)}subtract(e){return this.add(e.negate())}is0(){return this.equals(Point.ZERO)}wNAF(e){return k.wNAFCached(this,a,e,(e=>{const r=n.invertBatch(e.map((e=>e.pz)));return e.map(((e,n)=>e.toAffine(r[n]))).map(Point.fromAffine)}))}multiplyUnsafe(e){const i=Point.ZERO;if(e===jr)return i;if(assertGE(e),e===Hr)return this;const{endo:s}=r;if(!s)return k.unsafeLadder(this,e);let{k1neg:a,k1:w,k2neg:I,k2:we}=s.splitScalar(e),Ae=i,Ce=i,Be=this;for(;w>jr||we>jr;)w&Hr&&(Ae=Ae.add(Be)),we&Hr&&(Ce=Ce.add(Be)),Be=Be.double(),w>>=Hr,we>>=Hr;return a&&(Ae=Ae.negate()),I&&(Ce=Ce.negate()),Ce=new Point(n.mul(Ce.px,s.beta),Ce.py,Ce.pz),Ae.add(Ce)}multiply(e){assertGE(e);let i,s,a=e;const{endo:w}=r;if(w){const{k1neg:e,k1:r,k2neg:I,k2:we}=w.splitScalar(a);let{p:Ae,f:Ce}=this.wNAF(r),{p:Be,f:ze}=this.wNAF(we);Ae=k.constTimeNegate(e,Ae),Be=k.constTimeNegate(I,Be),Be=new Point(n.mul(Be.px,w.beta),Be.py,Be.pz),i=Ae.add(Be),s=Ce.add(ze)}else{const{p:e,f:r}=this.wNAF(a);i=e,s=r}return Point.normalizeZ([i,s])[0]}multiplyAndAddUnsafe(e,r,n){const i=Point.BASE,mul=(e,r)=>r!==jr&&r!==Hr&&e.equals(i)?e.multiply(r):e.multiplyUnsafe(r),s=mul(this,r).add(mul(e,n));return s.is0()?void 0:s}toAffine(e){const{px:r,py:i,pz:s}=this,a=this.is0();null==e&&(e=a?n.ONE:n.inv(s));const w=n.mul(r,e),k=n.mul(i,e),I=n.mul(s,e);if(a)return{x:n.ZERO,y:n.ZERO};if(!n.eql(I,n.ONE))throw new Error("invZ was invalid");return{x:w,y:k}}isTorsionFree(){const{h:e,isTorsionFree:n}=r;if(e===Hr)return!0;if(n)return n(Point,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:n}=r;return e===Hr?this:n?n(Point,this):this.multiplyUnsafe(r.h)}toRawBytes(e=!0){return this.assertValidity(),i(Point,this,e)}toHex(e=!0){return abstract_utils_bytesToHex(this.toRawBytes(e))}}Point.BASE=new Point(r.Gx,r.Gy,n.ONE),Point.ZERO=new Point(n.ZERO,n.ONE,n.ZERO);const w=r.nBitLength,k=wNAF(Point,r.endo?Math.ceil(w/2):w);return{CURVE:r,ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}}function weierstrass(e){const r=function weierstrass_validateOpts(e){const r=validateBasic(e);return validateObject(r,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...r})}(e),{Fp:n,n:i}=r,s=n.BYTES+1,a=2*n.BYTES+1;function modN(e){return modular_mod(e,i)}function invN(e){return invert(e,i)}const{ProjectivePoint:w,normPrivateKeyToScalar:k,weierstrassEquation:I,isWithinCurveOrder:we}=weierstrassPoints({...r,toBytes(e,r,i){const s=r.toAffine(),a=n.toBytes(s.x),w=abstract_utils_concatBytes;return i?w(Uint8Array.from([r.hasEvenY()?2:3]),a):w(Uint8Array.from([4]),a,n.toBytes(s.y))},fromBytes(e){const r=e.length,i=e[0],w=e.subarray(1);if(r!==s||2!==i&&3!==i){if(r===a&&4===i){return{x:n.fromBytes(w.subarray(0,n.BYTES)),y:n.fromBytes(w.subarray(n.BYTES,2*n.BYTES))}}throw new Error(`Point of length ${r} was invalid. Expected ${s} compressed bytes or ${a} uncompressed bytes`)}{const e=utils_bytesToNumberBE(w);if(!function isValidFieldElement(e){return jr<e&&e<n.ORDER}(e))throw new Error("Point is not on curve");const r=I(e);let s;try{s=n.sqrt(r)}catch(e){const r=e instanceof Error?": "+e.message:"";throw new Error("Point is not on curve"+r)}return!(1&~i)!==((s&Hr)===Hr)&&(s=n.neg(s)),{x:e,y:s}}}}),numToNByteStr=e=>abstract_utils_bytesToHex(utils_numberToBytesBE(e,r.nByteLength));function isBiggerThanHalfOrder(e){return e>i>>Hr}const slcNum=(e,r,n)=>utils_bytesToNumberBE(e.slice(r,n));class Signature{constructor(e,r,n){this.r=e,this.s=r,this.recovery=n,this.assertValidity()}static fromCompact(e){const n=r.nByteLength;return e=utils_ensureBytes("compactSignature",e,2*n),new Signature(slcNum(e,0,n),slcNum(e,n,2*n))}static fromDER(e){const{r,s:n}=Vr.toSig(utils_ensureBytes("DER",e));return new Signature(r,n)}assertValidity(){if(!we(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!we(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new Signature(this.r,this.s,e)}recoverPublicKey(e){const{r:i,s,recovery:a}=this,k=Be(utils_ensureBytes("msgHash",e));if(null==a||![0,1,2,3].includes(a))throw new Error("recovery id invalid");const I=2===a||3===a?i+r.n:i;if(I>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const we=1&a?"03":"02",Ae=w.fromHex(we+numToNByteStr(I)),Ce=invN(I),ze=modN(-k*Ce),qe=modN(s*Ce),$e=w.BASE.multiplyAndAddUnsafe(Ae,ze,qe);if(!$e)throw new Error("point at infinify");return $e.assertValidity(),$e}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return utils_hexToBytes(this.toDERHex())}toDERHex(){return Vr.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return utils_hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}}const Ae={isValidPrivateKey(e){try{return k(e),!0}catch(e){return!1}},normPrivateKeyToScalar:k,randomPrivateKey:()=>{const e=getMinHashLength(r.n);return function mapHashToField(e,r,n=!1){const i=e.length,s=getFieldBytesLength(r),a=getMinHashLength(r);if(i<16||i<a||i>1024)throw new Error(`expected ${a}-1024 bytes of input, got ${i}`);const w=modular_mod(n?utils_bytesToNumberBE(e):utils_bytesToNumberLE(e),r-ot)+ot;return n?utils_numberToBytesLE(w,s):utils_numberToBytesBE(w,s)}(r.randomBytes(e),r.n)},precompute:(e=8,r=w.BASE)=>(r._setWindowSize(e),r.multiply(BigInt(3)),r)};function isProbPub(e){const r=abstract_utils_isBytes(e),n="string"==typeof e,i=(r||n)&&e.length;return r?i===s||i===a:n?i===2*s||i===2*a:e instanceof w}const Ce=r.bits2int||function(e){const n=utils_bytesToNumberBE(e),i=8*e.length-r.nBitLength;return i>0?n>>BigInt(i):n},Be=r.bits2int_modN||function(e){return modN(Ce(e))},ze=bitMask(r.nBitLength);function int2octets(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(jr<=e&&e<ze))throw new Error(`bigint expected < 2^${r.nBitLength}`);return utils_numberToBytesBE(e,r.nByteLength)}function prepSig(e,i,s=qe){if(["recovered","canonical"].some((e=>e in s)))throw new Error("sign() legacy options not supported");const{hash:a,randomBytes:I}=r;let{lowS:Ae,prehash:ze,extraEntropy:$e}=s;null==Ae&&(Ae=!0),e=utils_ensureBytes("msgHash",e),ze&&(e=utils_ensureBytes("prehashed msgHash",a(e)));const Ye=Be(e),Je=k(i),et=[int2octets(Je),int2octets(Ye)];if(null!=$e&&!1!==$e){const e=!0===$e?I(n.BYTES):$e;et.push(utils_ensureBytes("extraEntropy",e))}const rt=abstract_utils_concatBytes(...et),it=Ye;return{seed:rt,k2sig:function k2sig(e){const r=Ce(e);if(!we(r))return;const n=invN(r),i=w.BASE.multiply(r).toAffine(),s=modN(i.x);if(s===jr)return;const a=modN(n*modN(it+s*Je));if(a===jr)return;let k=(i.x===s?0:2)|Number(i.y&Hr),I=a;return Ae&&isBiggerThanHalfOrder(a)&&(I=function normalizeS(e){return isBiggerThanHalfOrder(e)?modN(-e):e}(a),k^=1),new Signature(s,I,k)}}}const qe={lowS:r.lowS,prehash:!1},$e={lowS:r.lowS,prehash:!1};return w.BASE._setWindowSize(8),{CURVE:r,getPublicKey:function getPublicKey(e,r=!0){return w.fromPrivateKey(e).toRawBytes(r)},getSharedSecret:function getSharedSecret(e,r,n=!0){if(isProbPub(e))throw new Error("first arg must be private key");if(!isProbPub(r))throw new Error("second arg must be public key");return w.fromHex(r).multiply(k(e)).toRawBytes(n)},sign:function sign(e,n,i=qe){const{seed:s,k2sig:a}=prepSig(e,n,i),w=r;return createHmacDrbg(w.hash.outputLen,w.nByteLength,w.hmac)(s,a)},verify:function verify(e,n,i,s=$e){const a=e;if(n=utils_ensureBytes("msgHash",n),i=utils_ensureBytes("publicKey",i),"strict"in s)throw new Error("options.strict was renamed to lowS");const{lowS:k,prehash:I}=s;let we,Ae;try{if("string"==typeof a||abstract_utils_isBytes(a))try{we=Signature.fromDER(a)}catch(e){if(!(e instanceof Vr.Err))throw e;we=Signature.fromCompact(a)}else{if("object"!=typeof a||"bigint"!=typeof a.r||"bigint"!=typeof a.s)throw new Error("PARSE");{const{r:e,s:r}=a;we=new Signature(e,r)}}Ae=w.fromHex(i)}catch(e){if("PARSE"===e.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(k&&we.hasHighS())return!1;I&&(n=r.hash(n));const{r:Ce,s:ze}=we,qe=Be(n),Ye=invN(ze),Je=modN(qe*Ye),et=modN(Ce*Ye),rt=w.BASE.multiplyAndAddUnsafe(Ae,Je,et)?.toAffine();return!!rt&&modN(rt.x)===Ce},ProjectivePoint:w,Signature,utils:Ae}}function getHash(e){return{hash:e,hmac:(r,...n)=>hmac(e,r,utils_concatBytes(...n)),randomBytes:utils_randomBytes}}const Yr=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Gr=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Jr=BigInt(1),Zr=BigInt(2),divNearest=(e,r)=>(e+r/Zr)/r;function sqrtMod(e){const r=Yr,n=BigInt(3),i=BigInt(6),s=BigInt(11),a=BigInt(22),w=BigInt(23),k=BigInt(44),I=BigInt(88),we=e*e*e%r,Ae=we*we*e%r,Ce=modular_pow2(Ae,n,r)*Ae%r,Be=modular_pow2(Ce,n,r)*Ae%r,ze=modular_pow2(Be,Zr,r)*we%r,qe=modular_pow2(ze,s,r)*ze%r,$e=modular_pow2(qe,a,r)*qe%r,Ye=modular_pow2($e,k,r)*$e%r,Je=modular_pow2(Ye,I,r)*Ye%r,et=modular_pow2(Je,k,r)*$e%r,rt=modular_pow2(et,n,r)*Ae%r,it=modular_pow2(rt,w,r)*qe%r,ot=modular_pow2(it,i,r)*we%r,ht=modular_pow2(ot,Zr,r);if(!Xr.eql(Xr.sqr(ht),e))throw new Error("Cannot find square root");return ht}const Xr=Field(Yr,void 0,void 0,{sqrt:sqrtMod}),Qr=function createCurve(e,r){const create=r=>weierstrass({...e,...getHash(r)});return Object.freeze({...create(r),create})}({a:BigInt(0),b:BigInt(7),Fp:Xr,n:Gr,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const r=Gr,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),i=-Jr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),a=n,w=BigInt("0x100000000000000000000000000000000"),k=divNearest(a*e,r),I=divNearest(-i*e,r);let we=modular_mod(e-k*n-I*s,r),Ae=modular_mod(-k*i-I*a,r);const Ce=we>w,Be=Ae>w;if(Ce&&(we=r-we),Be&&(Ae=r-Ae),we>w||Ae>w)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:Ce,k1:we,k2neg:Be,k2:Ae}}}},Sr);BigInt(0);Qr.ProjectivePoint;const sn=hr.utils.randomPrivateKey,generateKeypair=()=>{const e=hr.utils.randomPrivateKey(),r=an(e),n=new Uint8Array(64);return n.set(e),n.set(r,32),{publicKey:r,secretKey:n}},an=hr.getPublicKey;function isOnCurve(e){try{return hr.ExtendedPoint.fromHex(e),!0}catch{return!1}}const sign=(e,r)=>hr.sign(e,r.slice(0,32)),cn=hr.verify,toBuffer=e=>s.Buffer.isBuffer(e)?e:e instanceof Uint8Array?s.Buffer.from(e.buffer,e.byteOffset,e.byteLength):s.Buffer.from(e);class Struct{constructor(e){Object.assign(this,e)}encode(){return s.Buffer.from((0,Er.serialize)(un,this))}static decode(e){return(0,Er.deserialize)(un,this,e)}static decodeUnchecked(e){return(0,Er.deserializeUnchecked)(un,this,e)}}class Enum extends Struct{constructor(e){if(super(e),this.enum="",1!==Object.keys(e).length)throw new Error("Enum can only take single value");Object.keys(e).map((e=>{this.enum=e}))}}const un=new Map;var dn;const ln=32,gn=32;let pn=1;class PublicKey extends Struct{constructor(e){if(super({}),this._bn=void 0,function isPublicKeyData(e){return void 0!==e._bn}(e))this._bn=e._bn;else{if("string"==typeof e){const r=yr().decode(e);if(r.length!=gn)throw new Error("Invalid public key input");this._bn=new(pr())(r)}else this._bn=new(pr())(e);if(this._bn.byteLength()>gn)throw new Error("Invalid public key input")}}static unique(){const e=new PublicKey(pn);return pn+=1,new PublicKey(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return yr().encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(s.Buffer);if(e.length===gn)return e;const r=s.Buffer.alloc(32);return e.copy(r,32-e.length),r}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,r,n){const i=s.Buffer.concat([e.toBuffer(),s.Buffer.from(r),n.toBuffer()]),a=Sr(i);return new PublicKey(a)}static createProgramAddressSync(e,r){let n=s.Buffer.alloc(0);e.forEach((function(e){if(e.length>ln)throw new TypeError("Max seed length exceeded");n=s.Buffer.concat([n,toBuffer(e)])})),n=s.Buffer.concat([n,r.toBuffer(),s.Buffer.from("ProgramDerivedAddress")]);const i=Sr(n);if(isOnCurve(i))throw new Error("Invalid seeds, address must fall off the curve");return new PublicKey(i)}static async createProgramAddress(e,r){return this.createProgramAddressSync(e,r)}static findProgramAddressSync(e,r){let n,i=255;for(;0!=i;){try{const a=e.concat(s.Buffer.from([i]));n=this.createProgramAddressSync(a,r)}catch(e){if(e instanceof TypeError)throw e;i--;continue}return[n,i]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,r){return this.findProgramAddressSync(e,r)}static isOnCurve(e){return isOnCurve(new PublicKey(e).toBytes())}}dn=PublicKey,PublicKey.default=new dn("11111111111111111111111111111111"),un.set(PublicKey,{kind:"struct",fields:[["_bn","u256"]]});class Account{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const r=toBuffer(e);if(64!==e.length)throw new Error("bad secret key size");this._publicKey=r.slice(32,64),this._secretKey=r.slice(0,32)}else this._secretKey=toBuffer(sn()),this._publicKey=toBuffer(an(this._secretKey))}get publicKey(){return new PublicKey(this._publicKey)}get secretKey(){return s.Buffer.concat([this._secretKey,this._publicKey],64)}}const mn=new PublicKey("BPFLoader1111111111111111111111111111111111"),yn=1232,bn=127,kn=64;class TransactionExpiredBlockheightExceededError extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class TransactionExpiredTimeoutError extends Error{constructor(e,r){super(`Transaction was not confirmed in ${r.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredTimeoutError.prototype,"name",{value:"TransactionExpiredTimeoutError"});class TransactionExpiredNonceInvalidError extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredNonceInvalidError.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class MessageAccountKeys{constructor(e,r){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=r}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const r of this.keySegments()){if(e<r.length)return r[e];e-=r.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach(((e,n)=>{r.set(e.toBase58(),n)}));const findKeyIndex=e=>{const n=r.get(e.toBase58());if(void 0===n)throw new Error("Encountered an unknown instruction account key during compilation");return n};return e.map((e=>({programIdIndex:findKeyIndex(e.programId),accountKeyIndexes:e.keys.map((e=>findKeyIndex(e.pubkey))),data:e.data})))}}const publicKey=(e="publicKey")=>kr.blob(32,e),signature=(e="signature")=>kr.blob(64,e),rustString=(e="string")=>{const r=kr.struct([kr.u32("length"),kr.u32("lengthPadding"),kr.blob(kr.offset(kr.u32(),-8),"chars")],e),n=r.decode.bind(r),i=r.encode.bind(r),a=r;return a.decode=(e,r)=>n(e,r).chars.toString(),a.encode=(e,r,n)=>{const a={chars:s.Buffer.from(e,"utf8")};return i(a,r,n)},a.alloc=e=>kr.u32().span+kr.u32().span+s.Buffer.from(e,"utf8").length,a};function getAlloc(e,r){const getItemAlloc=e=>{if(e.span>=0)return e.span;if("function"==typeof e.alloc)return e.alloc(r[e.property]);if("count"in e&&"elementLayout"in e){const n=r[e.property];if(Array.isArray(n))return n.length*getItemAlloc(e.elementLayout)}else if("fields"in e)return getAlloc({layout:e},r[e.property]);return 0};let n=0;return e.layout.fields.forEach((e=>{n+=getItemAlloc(e)})),n}function decodeLength(e){let r=0,n=0;for(;;){let i=e.shift();if(r|=(127&i)<<7*n,n+=1,!(128&i))break}return r}function encodeLength(e,r){let n=r;for(;;){let r=127&n;if(n>>=7,0==n){e.push(r);break}r|=128,e.push(r)}}function index_browser_esm_assert(e,r){if(!e)throw new Error(r||"Assertion failed")}class CompiledKeys{constructor(e,r){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=r}static compile(e,r){const n=new Map,getOrInsertDefault=e=>{const r=e.toBase58();let i=n.get(r);return void 0===i&&(i={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(r,i)),i},i=getOrInsertDefault(r);i.isSigner=!0,i.isWritable=!0;for(const r of e){getOrInsertDefault(r.programId).isInvoked=!0;for(const e of r.keys){const r=getOrInsertDefault(e.pubkey);r.isSigner||=e.isSigner,r.isWritable||=e.isWritable}}return new CompiledKeys(r,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];index_browser_esm_assert(e.length<=256,"Max static account keys length exceeded");const r=e.filter((([,e])=>e.isSigner&&e.isWritable)),n=e.filter((([,e])=>e.isSigner&&!e.isWritable)),i=e.filter((([,e])=>!e.isSigner&&e.isWritable)),s=e.filter((([,e])=>!e.isSigner&&!e.isWritable)),a={numRequiredSignatures:r.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:s.length};{index_browser_esm_assert(r.length>0,"Expected at least one writable signer key");const[e]=r[0];index_browser_esm_assert(e===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}return[a,[...r.map((([e])=>new PublicKey(e))),...n.map((([e])=>new PublicKey(e))),...i.map((([e])=>new PublicKey(e))),...s.map((([e])=>new PublicKey(e)))]]}extractTableLookup(e){const[r,n]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&e.isWritable)),[i,s]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&!e.isWritable));if(0!==r.length||0!==i.length)return[{accountKey:e.key,writableIndexes:r,readonlyIndexes:i},{writable:n,readonly:s}]}drainKeysFoundInLookupTable(e,r){const n=new Array,i=new Array;for(const[s,a]of this.keyMetaMap.entries())if(r(a)){const r=new PublicKey(s),a=e.findIndex((e=>e.equals(r)));a>=0&&(index_browser_esm_assert(a<256,"Max lookup table index exceeded"),n.push(a),i.push(r),this.keyMetaMap.delete(s))}return[n,i]}}const In="Reached end of buffer unexpectedly";function guardedShift(e){if(0===e.length)throw new Error(In);return e.shift()}function guardedSplice(e,...r){const[n]=r;if(2===r.length?n+(r[1]??0)>e.length:n>=e.length)throw new Error(In);return e.splice(...r)}class Message{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map((e=>new PublicKey(e))),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach((e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex])))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map((e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:yr().decode(e.data)})))}get addressTableLookups(){return[]}getAccountKeys(){return new MessageAccountKeys(this.staticAccountKeys)}static compile(e){const r=CompiledKeys.compile(e.instructions,e.payerKey),[n,i]=r.getMessageComponents(),s=new MessageAccountKeys(i).compileInstructions(e.instructions).map((e=>({programIdIndex:e.programIdIndex,accounts:e.accountKeyIndexes,data:yr().encode(e.data)})));return new Message({header:n,accountKeys:i,recentBlockhash:e.recentBlockhash,instructions:s})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const r=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){return e-r<this.accountKeys.length-r-this.header.numReadonlyUnsignedAccounts}return e<r-this.header.numReadonlySignedAccounts}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter(((e,r)=>!this.isProgramId(r)))}serialize(){const e=this.accountKeys.length;let r=[];encodeLength(r,e);const n=this.instructions.map((e=>{const{accounts:r,programIdIndex:n}=e,i=Array.from(yr().decode(e.data));let a=[];encodeLength(a,r.length);let w=[];return encodeLength(w,i.length),{programIdIndex:n,keyIndicesCount:s.Buffer.from(a),keyIndices:r,dataLength:s.Buffer.from(w),data:i}}));let i=[];encodeLength(i,n.length);let a=s.Buffer.alloc(yn);s.Buffer.from(i).copy(a);let w=i.length;n.forEach((e=>{const r=kr.struct([kr.u8("programIdIndex"),kr.blob(e.keyIndicesCount.length,"keyIndicesCount"),kr.seq(kr.u8("keyIndex"),e.keyIndices.length,"keyIndices"),kr.blob(e.dataLength.length,"dataLength"),kr.seq(kr.u8("userdatum"),e.data.length,"data")]).encode(e,a,w);w+=r})),a=a.slice(0,w);const k=kr.struct([kr.blob(1,"numRequiredSignatures"),kr.blob(1,"numReadonlySignedAccounts"),kr.blob(1,"numReadonlyUnsignedAccounts"),kr.blob(r.length,"keyCount"),kr.seq(publicKey("key"),e,"keys"),publicKey("recentBlockhash")]),I={numRequiredSignatures:s.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:s.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:s.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:s.Buffer.from(r),keys:this.accountKeys.map((e=>toBuffer(e.toBytes()))),recentBlockhash:yr().decode(this.recentBlockhash)};let we=s.Buffer.alloc(2048);const Ae=k.encode(I,we);return a.copy(we,Ae),we.slice(0,Ae+a.length)}static from(e){let r=[...e];const n=guardedShift(r);if(n!==(n&bn))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const i=guardedShift(r),a=guardedShift(r),w=decodeLength(r);let k=[];for(let e=0;e<w;e++){const e=guardedSplice(r,0,gn);k.push(new PublicKey(s.Buffer.from(e)))}const I=guardedSplice(r,0,gn),we=decodeLength(r);let Ae=[];for(let e=0;e<we;e++){const e=guardedShift(r),n=guardedSplice(r,0,decodeLength(r)),i=guardedSplice(r,0,decodeLength(r)),a=yr().encode(s.Buffer.from(i));Ae.push({programIdIndex:e,accounts:n,data:a})}const Ce={header:{numRequiredSignatures:n,numReadonlySignedAccounts:i,numReadonlyUnsignedAccounts:a},recentBlockhash:yr().encode(s.Buffer.from(I)),accountKeys:k,instructions:Ae};return new Message(Ce)}}class MessageV0{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const r of this.addressTableLookups)e+=r.readonlyIndexes.length+r.writableIndexes.length;return e}getAccountKeys(e){let r;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");r=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)r=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new MessageAccountKeys(this.staticAccountKeys,r)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const r=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){return e-n<this.addressTableLookups.reduce(((e,r)=>e+r.writableIndexes.length),0)}if(e>=this.header.numRequiredSignatures){return e-r<n-r-this.header.numReadonlyUnsignedAccounts}return e<r-this.header.numReadonlySignedAccounts}resolveAddressTableLookups(e){const r={writable:[],readonly:[]};for(const n of this.addressTableLookups){const i=e.find((e=>e.key.equals(n.accountKey)));if(!i)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const e of n.writableIndexes){if(!(e<i.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${n.accountKey.toBase58()}`);r.writable.push(i.state.addresses[e])}for(const e of n.readonlyIndexes){if(!(e<i.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${n.accountKey.toBase58()}`);r.readonly.push(i.state.addresses[e])}}return r}static compile(e){const r=CompiledKeys.compile(e.instructions,e.payerKey),n=new Array,i={writable:new Array,readonly:new Array},s=e.addressLookupTableAccounts||[];for(const e of s){const s=r.extractTableLookup(e);if(void 0!==s){const[e,{writable:r,readonly:a}]=s;n.push(e),i.writable.push(...r),i.readonly.push(...a)}}const[a,w]=r.getMessageComponents(),k=new MessageAccountKeys(w,i).compileInstructions(e.instructions);return new MessageV0({header:a,staticAccountKeys:w,recentBlockhash:e.recentBlockhash,compiledInstructions:k,addressTableLookups:n})}serialize(){const e=Array();encodeLength(e,this.staticAccountKeys.length);const r=this.serializeInstructions(),n=Array();encodeLength(n,this.compiledInstructions.length);const i=this.serializeAddressTableLookups(),s=Array();encodeLength(s,this.addressTableLookups.length);const a=kr.struct([kr.u8("prefix"),kr.struct([kr.u8("numRequiredSignatures"),kr.u8("numReadonlySignedAccounts"),kr.u8("numReadonlyUnsignedAccounts")],"header"),kr.blob(e.length,"staticAccountKeysLength"),kr.seq(publicKey(),this.staticAccountKeys.length,"staticAccountKeys"),publicKey("recentBlockhash"),kr.blob(n.length,"instructionsLength"),kr.blob(r.length,"serializedInstructions"),kr.blob(s.length,"addressTableLookupsLength"),kr.blob(i.length,"serializedAddressTableLookups")]),w=new Uint8Array(yn),k=a.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map((e=>e.toBytes())),recentBlockhash:yr().decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:r,addressTableLookupsLength:new Uint8Array(s),serializedAddressTableLookups:i},w);return w.slice(0,k)}serializeInstructions(){let e=0;const r=new Uint8Array(yn);for(const n of this.compiledInstructions){const i=Array();encodeLength(i,n.accountKeyIndexes.length);const s=Array();encodeLength(s,n.data.length);e+=kr.struct([kr.u8("programIdIndex"),kr.blob(i.length,"encodedAccountKeyIndexesLength"),kr.seq(kr.u8(),n.accountKeyIndexes.length,"accountKeyIndexes"),kr.blob(s.length,"encodedDataLength"),kr.blob(n.data.length,"data")]).encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(i),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(s),data:n.data},r,e)}return r.slice(0,e)}serializeAddressTableLookups(){let e=0;const r=new Uint8Array(yn);for(const n of this.addressTableLookups){const i=Array();encodeLength(i,n.writableIndexes.length);const s=Array();encodeLength(s,n.readonlyIndexes.length);e+=kr.struct([publicKey("accountKey"),kr.blob(i.length,"encodedWritableIndexesLength"),kr.seq(kr.u8(),n.writableIndexes.length,"writableIndexes"),kr.blob(s.length,"encodedReadonlyIndexesLength"),kr.seq(kr.u8(),n.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(i),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(s),readonlyIndexes:n.readonlyIndexes},r,e)}return r.slice(0,e)}static deserialize(e){let r=[...e];const n=guardedShift(r),i=n&bn;index_browser_esm_assert(n!==i,"Expected versioned message but received legacy message");index_browser_esm_assert(0===i,`Expected versioned message with version 0 but found version ${i}`);const s={numRequiredSignatures:guardedShift(r),numReadonlySignedAccounts:guardedShift(r),numReadonlyUnsignedAccounts:guardedShift(r)},a=[],w=decodeLength(r);for(let e=0;e<w;e++)a.push(new PublicKey(guardedSplice(r,0,gn)));const k=yr().encode(guardedSplice(r,0,gn)),I=decodeLength(r),we=[];for(let e=0;e<I;e++){const e=guardedShift(r),n=guardedSplice(r,0,decodeLength(r)),i=decodeLength(r),s=new Uint8Array(guardedSplice(r,0,i));we.push({programIdIndex:e,accountKeyIndexes:n,data:s})}const Ae=decodeLength(r),Ce=[];for(let e=0;e<Ae;e++){const e=new PublicKey(guardedSplice(r,0,gn)),n=guardedSplice(r,0,decodeLength(r)),i=guardedSplice(r,0,decodeLength(r));Ce.push({accountKey:e,writableIndexes:n,readonlyIndexes:i})}return new MessageV0({header:s,staticAccountKeys:a,recentBlockhash:k,compiledInstructions:we,addressTableLookups:Ce})}}const Cn={deserializeMessageVersion(e){const r=e[0],n=r&bn;return n===r?"legacy":n},deserialize:e=>{const r=Cn.deserializeMessageVersion(e);if("legacy"===r)return Message.from(e);if(0===r)return MessageV0.deserialize(e);throw new Error(`Transaction message version ${r} deserialization is not supported`)}};let Bn=function(e){return e[e.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",e[e.PROCESSED=1]="PROCESSED",e[e.TIMED_OUT=2]="TIMED_OUT",e[e.NONCE_INVALID=3]="NONCE_INVALID",e}({});const Mn=s.Buffer.alloc(kn).fill(0);class TransactionInstruction{constructor(e){this.keys=void 0,this.programId=void 0,this.data=s.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map((({pubkey:e,isSigner:r,isWritable:n})=>({pubkey:e.toJSON(),isSigner:r,isWritable:n}))),programId:this.programId.toJSON(),data:[...this.data]}}}class Transaction{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:r,nonceInfo:n}=e;this.minNonceContextSlot=r,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:r,lastValidBlockHeight:n}=e;this.recentBlockhash=r,this.lastValidBlockHeight=n}else{const{recentBlockhash:r,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=r}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map((e=>e.toJSON())),signers:this.signatures.map((({publicKey:e})=>e.toJSON()))}}add(...e){if(0===e.length)throw new Error("No instructions");return e.forEach((e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new TransactionInstruction(e))})),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,r,n;if(this.nonceInfo?(e=this.nonceInfo.nonce,r=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(e=this.recentBlockhash,r=this.instructions),!e)throw new Error("Transaction recentBlockhash required");if(r.length<1&&console.warn("No instructions provided"),this.feePayer)n=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");n=this.signatures[0].publicKey}for(let e=0;e<r.length;e++)if(void 0===r[e].programId)throw new Error(`Transaction instruction index ${e} has undefined program id`);const i=[],s=[];r.forEach((e=>{e.keys.forEach((e=>{s.push({...e})}));const r=e.programId.toString();i.includes(r)||i.push(r)})),i.forEach((e=>{s.push({pubkey:new PublicKey(e),isSigner:!1,isWritable:!1})}));const a=[];s.forEach((e=>{const r=e.pubkey.toString(),n=a.findIndex((e=>e.pubkey.toString()===r));n>-1?(a[n].isWritable=a[n].isWritable||e.isWritable,a[n].isSigner=a[n].isSigner||e.isSigner):a.push(e)})),a.sort((function(e,r){if(e.isSigner!==r.isSigner)return e.isSigner?-1:1;if(e.isWritable!==r.isWritable)return e.isWritable?-1:1;return e.pubkey.toBase58().localeCompare(r.pubkey.toBase58(),"en",{localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"})}));const w=a.findIndex((e=>e.pubkey.equals(n)));if(w>-1){const[e]=a.splice(w,1);e.isSigner=!0,e.isWritable=!0,a.unshift(e)}else a.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const e of this.signatures){const r=a.findIndex((r=>r.pubkey.equals(e.publicKey)));if(!(r>-1))throw new Error(`unknown signer: ${e.publicKey.toString()}`);a[r].isSigner||(a[r].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))}let k=0,I=0,we=0;const Ae=[],Ce=[];a.forEach((({pubkey:e,isSigner:r,isWritable:n})=>{r?(Ae.push(e.toString()),k+=1,n||(I+=1)):(Ce.push(e.toString()),n||(we+=1))}));const Be=Ae.concat(Ce),ze=r.map((e=>{const{data:r,programId:n}=e;return{programIdIndex:Be.indexOf(n.toString()),accounts:e.keys.map((e=>Be.indexOf(e.pubkey.toString()))),data:yr().encode(r)}}));return ze.forEach((e=>{index_browser_esm_assert(e.programIdIndex>=0),e.accounts.forEach((e=>index_browser_esm_assert(e>=0)))})),new Message({header:{numRequiredSignatures:k,numReadonlySignedAccounts:I,numReadonlyUnsignedAccounts:we},accountKeys:Be,recentBlockhash:e,instructions:ze})}_compile(){const e=this.compileMessage(),r=e.accountKeys.slice(0,e.header.numRequiredSignatures);if(this.signatures.length===r.length){if(this.signatures.every(((e,n)=>r[n].equals(e.publicKey))))return e}return this.signatures=r.map((e=>({signature:null,publicKey:e}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(0===e.length)throw new Error("No signers");const r=new Set;this.signatures=e.filter((e=>{const n=e.toString();return!r.has(n)&&(r.add(n),!0)})).map((e=>({signature:null,publicKey:e})))}sign(...e){if(0===e.length)throw new Error("No signers");const r=new Set,n=[];for(const i of e){const e=i.publicKey.toString();r.has(e)||(r.add(e),n.push(i))}this.signatures=n.map((e=>({signature:null,publicKey:e.publicKey})));const i=this._compile();this._partialSign(i,...n)}partialSign(...e){if(0===e.length)throw new Error("No signers");const r=new Set,n=[];for(const i of e){const e=i.publicKey.toString();r.has(e)||(r.add(e),n.push(i))}const i=this._compile();this._partialSign(i,...n)}_partialSign(e,...r){const n=e.serialize();r.forEach((e=>{const r=sign(n,e.secretKey);this._addSignature(e.publicKey,toBuffer(r))}))}addSignature(e,r){this._compile(),this._addSignature(e,r)}_addSignature(e,r){index_browser_esm_assert(64===r.length);const n=this.signatures.findIndex((r=>e.equals(r.publicKey)));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=s.Buffer.from(r)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,r){const n={};for(const{signature:i,publicKey:s}of this.signatures)null===i?r&&(n.missing||=[]).push(s):cn(i,e,s.toBytes())||(n.invalid||=[]).push(s);return n.invalid||n.missing?n:void 0}serialize(e){const{requireAllSignatures:r,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),i=this.serializeMessage();if(n){const e=this._getMessageSignednessErrors(i,r);if(e){let r="Signature verification failed.";throw e.invalid&&(r+=`\nInvalid signature for public key${1===e.invalid.length?"":"(s)"} [\`${e.invalid.map((e=>e.toBase58())).join("`, `")}\`].`),e.missing&&(r+=`\nMissing signature for public key${1===e.missing.length?"":"(s)"} [\`${e.missing.map((e=>e.toBase58())).join("`, `")}\`].`),new Error(r)}}return this._serialize(i)}_serialize(e){const{signatures:r}=this,n=[];encodeLength(n,r.length);const i=n.length+64*r.length+e.length,a=s.Buffer.alloc(i);return index_browser_esm_assert(r.length<256),s.Buffer.from(n).copy(a,0),r.forEach((({signature:e},r)=>{null!==e&&(index_browser_esm_assert(64===e.length,"signature has invalid length"),s.Buffer.from(e).copy(a,n.length+64*r))})),e.copy(a,n.length+64*r.length),index_browser_esm_assert(a.length<=yn,`Transaction too large: ${a.length} > ${yn}`),a}get keys(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].keys.map((e=>e.pubkey))}get programId(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].programId}get data(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].data}static from(e){let r=[...e];const n=decodeLength(r);let i=[];for(let e=0;e<n;e++){const e=guardedSplice(r,0,kn);i.push(yr().encode(s.Buffer.from(e)))}return Transaction.populate(Message.from(r),i)}static populate(e,r=[]){const n=new Transaction;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),r.forEach(((r,i)=>{const s={signature:r==yr().encode(Mn)?null:yr().decode(r),publicKey:e.accountKeys[i]};n.signatures.push(s)})),e.instructions.forEach((r=>{const i=r.accounts.map((r=>{const i=e.accountKeys[r];return{pubkey:i,isSigner:n.signatures.some((e=>e.publicKey.toString()===i.toString()))||e.isAccountSigner(r),isWritable:e.isAccountWritable(r)}}));n.instructions.push(new TransactionInstruction({keys:i,programId:e.accountKeys[r.programIdIndex],data:yr().decode(r.data)}))})),n._message=e,n._json=n.toJSON(),n}}class TransactionMessage{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,r){const{header:n,compiledInstructions:i,recentBlockhash:s}=e,{numRequiredSignatures:a,numReadonlySignedAccounts:w,numReadonlyUnsignedAccounts:k}=n,I=a-w;index_browser_esm_assert(I>0,"Message header is invalid");const we=e.staticAccountKeys.length-a-k;index_browser_esm_assert(we>=0,"Message header is invalid");const Ae=e.getAccountKeys(r),Ce=Ae.get(0);if(void 0===Ce)throw new Error("Failed to decompile message because no account keys were found");const Be=[];for(const e of i){const r=[];for(const i of e.accountKeyIndexes){const e=Ae.get(i);if(void 0===e)throw new Error(`Failed to find key for account key index ${i}`);let s;s=i<a?i<I:i<Ae.staticAccountKeys.length?i-a<we:i-Ae.staticAccountKeys.length<Ae.accountKeysFromLookups.writable.length,r.push({pubkey:e,isSigner:i<n.numRequiredSignatures,isWritable:s})}const i=Ae.get(e.programIdIndex);if(void 0===i)throw new Error(`Failed to find program id for program id index ${e.programIdIndex}`);Be.push(new TransactionInstruction({programId:i,data:toBuffer(e.data),keys:r}))}return new TransactionMessage({payerKey:Ce,instructions:Be,recentBlockhash:s})}compileToLegacyMessage(){return Message.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return MessageV0.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class VersionedTransaction{get version(){return this.message.version}constructor(e,r){if(this.signatures=void 0,this.message=void 0,void 0!==r)index_browser_esm_assert(r.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=r;else{const r=[];for(let n=0;n<e.header.numRequiredSignatures;n++)r.push(new Uint8Array(kn));this.signatures=r}this.message=e}serialize(){const e=this.message.serialize(),r=Array();encodeLength(r,this.signatures.length);const n=kr.struct([kr.blob(r.length,"encodedSignaturesLength"),kr.seq(signature(),this.signatures.length,"signatures"),kr.blob(e.length,"serializedMessage")]),i=new Uint8Array(2048),s=n.encode({encodedSignaturesLength:new Uint8Array(r),signatures:this.signatures,serializedMessage:e},i);return i.slice(0,s)}static deserialize(e){let r=[...e];const n=[],i=decodeLength(r);for(let e=0;e<i;e++)n.push(new Uint8Array(guardedSplice(r,0,kn)));const s=Cn.deserialize(new Uint8Array(r));return new VersionedTransaction(s,n)}sign(e){const r=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const i of e){const e=n.findIndex((e=>e.equals(i.publicKey)));index_browser_esm_assert(e>=0,`Cannot sign with non signer key ${i.publicKey.toBase58()}`),this.signatures[e]=sign(r,i.secretKey)}}addSignature(e,r){index_browser_esm_assert(64===r.byteLength,"Signature must be 64 bytes long");const n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex((r=>r.equals(e)));index_browser_esm_assert(n>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[n]=r}}const Wn=new PublicKey("SysvarC1ock11111111111111111111111111111111"),Hn=new PublicKey("SysvarEpochSchedu1e111111111111111111111111"),Zn=new PublicKey("Sysvar1nstructions1111111111111111111111111"),Qn=new PublicKey("SysvarRecentB1ockHashes11111111111111111111"),ei=new PublicKey("SysvarRent111111111111111111111111111111111"),ti=new PublicKey("SysvarRewards111111111111111111111111111111"),ri=new PublicKey("SysvarS1otHashes111111111111111111111111111"),ni=new PublicKey("SysvarS1otHistory11111111111111111111111111"),ii=new PublicKey("SysvarStakeHistory1111111111111111111111111");async function sendAndConfirmTransaction(e,r,n,i){const s=i&&{skipPreflight:i.skipPreflight,preflightCommitment:i.preflightCommitment||i.commitment,maxRetries:i.maxRetries,minContextSlot:i.minContextSlot},a=await e.sendTransaction(r,n,s);let w;if(null!=r.recentBlockhash&&null!=r.lastValidBlockHeight)w=(await e.confirmTransaction({abortSignal:i?.abortSignal,signature:a,blockhash:r.recentBlockhash,lastValidBlockHeight:r.lastValidBlockHeight},i&&i.commitment)).value;else if(null!=r.minNonceContextSlot&&null!=r.nonceInfo){const{nonceInstruction:n}=r.nonceInfo,s=n.keys[0].pubkey;w=(await e.confirmTransaction({abortSignal:i?.abortSignal,minContextSlot:r.minNonceContextSlot,nonceAccountPubkey:s,nonceValue:r.nonceInfo.nonce,signature:a},i&&i.commitment)).value}else null!=i?.abortSignal&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),w=(await e.confirmTransaction(a,i&&i.commitment)).value;if(w.err)throw new Error(`Transaction ${a} failed (${JSON.stringify(w)})`);return a}function sleep(e){return new Promise((r=>setTimeout(r,e)))}function encodeData(e,r){const n=e.layout.span>=0?e.layout.span:getAlloc(e,r),i=s.Buffer.alloc(n),a=Object.assign({instruction:e.index},r);return e.layout.encode(a,i),i}function decodeData$1(e,r){let n;try{n=e.layout.decode(r)}catch(e){throw new Error("invalid instruction; "+e)}if(n.instruction!==e.index)throw new Error(`invalid instruction; instruction index mismatch ${n.instruction} != ${e.index}`);return n}const oi=kr.nu64("lamportsPerSignature"),si=kr.struct([kr.u32("version"),kr.u32("state"),publicKey("authorizedPubkey"),publicKey("nonce"),kr.struct([oi],"feeCalculator")]),ai=si.span;class NonceAccount{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const r=si.decode(toBuffer(e),0);return new NonceAccount({authorizedPubkey:new PublicKey(r.authorizedPubkey),nonce:new PublicKey(r.nonce).toString(),feeCalculator:r.feeCalculator})}}const ci=(ui=8,e=>{const r=(0,kr.blob)(ui,e),{encode:n,decode:i}=(e=>({decode:e.decode.bind(e),encode:e.encode.bind(e)}))(r),a=r;return a.decode=(e,r)=>{const n=i(e,r);return(0,Ar.toBigIntLE)(s.Buffer.from(n))},a.encode=(e,r,i)=>{const s=(0,Ar.toBufferLE)(e,ui);return n(s,r,i)},a});var ui;class SystemInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=kr.u32("instruction").decode(e.data);let n;for(const[e,i]of Object.entries(di))if(i.index==r){n=e;break}if(!n)throw new Error("Instruction type incorrect; not a SystemInstruction");return n}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:r,space:n,programId:i}=decodeData$1(di.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:r,space:n,programId:new PublicKey(i)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:r}=decodeData$1(di.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:r}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:r,seed:n,programId:i}=decodeData$1(di.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:r,seed:n,programId:new PublicKey(i)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:r}=decodeData$1(di.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:r}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:r,seed:n,space:i,programId:s}=decodeData$1(di.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new PublicKey(r),seed:n,space:i,programId:new PublicKey(s)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:r}=decodeData$1(di.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new PublicKey(r)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:r,seed:n,programId:i}=decodeData$1(di.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new PublicKey(r),seed:n,programId:new PublicKey(i)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:r,seed:n,lamports:i,space:s,programId:a}=decodeData$1(di.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new PublicKey(r),seed:n,lamports:i,space:s,programId:new PublicKey(a)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:r}=decodeData$1(di.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new PublicKey(r)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),decodeData$1(di.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:r}=decodeData$1(di.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:r}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:r}=decodeData$1(di.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new PublicKey(r)}}static checkProgramId(e){if(!e.equals(SystemProgram.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,r){if(e.length<r)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${r}`)}}const di=Object.freeze({Create:{index:0,layout:kr.struct([kr.u32("instruction"),kr.ns64("lamports"),kr.ns64("space"),publicKey("programId")])},Assign:{index:1,layout:kr.struct([kr.u32("instruction"),publicKey("programId")])},Transfer:{index:2,layout:kr.struct([kr.u32("instruction"),ci("lamports")])},CreateWithSeed:{index:3,layout:kr.struct([kr.u32("instruction"),publicKey("base"),rustString("seed"),kr.ns64("lamports"),kr.ns64("space"),publicKey("programId")])},AdvanceNonceAccount:{index:4,layout:kr.struct([kr.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:kr.struct([kr.u32("instruction"),kr.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:kr.struct([kr.u32("instruction"),publicKey("authorized")])},AuthorizeNonceAccount:{index:7,layout:kr.struct([kr.u32("instruction"),publicKey("authorized")])},Allocate:{index:8,layout:kr.struct([kr.u32("instruction"),kr.ns64("space")])},AllocateWithSeed:{index:9,layout:kr.struct([kr.u32("instruction"),publicKey("base"),rustString("seed"),kr.ns64("space"),publicKey("programId")])},AssignWithSeed:{index:10,layout:kr.struct([kr.u32("instruction"),publicKey("base"),rustString("seed"),publicKey("programId")])},TransferWithSeed:{index:11,layout:kr.struct([kr.u32("instruction"),ci("lamports"),rustString("seed"),publicKey("programId")])},UpgradeNonceAccount:{index:12,layout:kr.struct([kr.u32("instruction")])}});class SystemProgram{constructor(){}static createAccount(e){const r=encodeData(di.Create,{lamports:e.lamports,space:e.space,programId:toBuffer(e.programId.toBuffer())});return new TransactionInstruction({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(e){let r,n;if("basePubkey"in e){r=encodeData(di.TransferWithSeed,{lamports:BigInt(e.lamports),seed:e.seed,programId:toBuffer(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{r=encodeData(di.Transfer,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new TransactionInstruction({keys:n,programId:this.programId,data:r})}static assign(e){let r,n;if("basePubkey"in e){r=encodeData(di.AssignWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,programId:toBuffer(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{r=encodeData(di.Assign,{programId:toBuffer(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:n,programId:this.programId,data:r})}static createAccountWithSeed(e){const r=encodeData(di.CreateWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:toBuffer(e.programId.toBuffer())});let n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&n.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new TransactionInstruction({keys:n,programId:this.programId,data:r})}static createNonceAccount(e){const r=new Transaction;"basePubkey"in e&&"seed"in e?r.add(SystemProgram.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:ai,programId:this.programId})):r.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:ai,programId:this.programId}));const n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return r.add(this.nonceInitialize(n)),r}static nonceInitialize(e){const r=encodeData(di.InitializeNonceAccount,{authorized:toBuffer(e.authorizedPubkey.toBuffer())}),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Qn,isSigner:!1,isWritable:!1},{pubkey:ei,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new TransactionInstruction(n)}static nonceAdvance(e){const r=encodeData(di.AdvanceNonceAccount),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Qn,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new TransactionInstruction(n)}static nonceWithdraw(e){const r=encodeData(di.WithdrawNonceAccount,{lamports:e.lamports});return new TransactionInstruction({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Qn,isSigner:!1,isWritable:!1},{pubkey:ei,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(e){const r=encodeData(di.AuthorizeNonceAccount,{authorized:toBuffer(e.newAuthorizedPubkey.toBuffer())});return new TransactionInstruction({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(e){let r,n;if("basePubkey"in e){r=encodeData(di.AllocateWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:toBuffer(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{r=encodeData(di.Allocate,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:n,programId:this.programId,data:r})}}SystemProgram.programId=new PublicKey("11111111111111111111111111111111");const li=yn-300;class Loader{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/Loader.chunkSize)+1+1)}static async load(e,r,n,i,a){{const s=await e.getMinimumBalanceForRentExemption(a.length),w=await e.getAccountInfo(n.publicKey,"confirmed");let k=null;if(null!==w){if(w.executable)return console.error("Program load failed, account is already executable"),!1;w.data.length!==a.length&&(k=k||new Transaction,k.add(SystemProgram.allocate({accountPubkey:n.publicKey,space:a.length}))),w.owner.equals(i)||(k=k||new Transaction,k.add(SystemProgram.assign({accountPubkey:n.publicKey,programId:i}))),w.lamports<s&&(k=k||new Transaction,k.add(SystemProgram.transfer({fromPubkey:r.publicKey,toPubkey:n.publicKey,lamports:s-w.lamports})))}else k=(new Transaction).add(SystemProgram.createAccount({fromPubkey:r.publicKey,newAccountPubkey:n.publicKey,lamports:s>0?s:1,space:a.length,programId:i}));null!==k&&await sendAndConfirmTransaction(e,k,[r,n],{commitment:"confirmed"})}const w=kr.struct([kr.u32("instruction"),kr.u32("offset"),kr.u32("bytesLength"),kr.u32("bytesLengthPadding"),kr.seq(kr.u8("byte"),kr.offset(kr.u32(),-8),"bytes")]),k=Loader.chunkSize;let I=0,we=a,Ae=[];for(;we.length>0;){const a=we.slice(0,k),Ce=s.Buffer.alloc(k+16);w.encode({instruction:0,offset:I,bytes:a,bytesLength:0,bytesLengthPadding:0},Ce);const Be=(new Transaction).add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0}],programId:i,data:Ce});if(Ae.push(sendAndConfirmTransaction(e,Be,[r,n],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")){const e=4;await sleep(1e3/e)}I+=k,we=we.slice(k)}await Promise.all(Ae);{const a=kr.struct([kr.u32("instruction")]),w=s.Buffer.alloc(a.span);a.encode({instruction:1},w);const k=(new Transaction).add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0},{pubkey:ei,isSigner:!1,isWritable:!1}],programId:i,data:w}),I="processed",we=await e.sendTransaction(k,[r,n],{preflightCommitment:I}),{context:Ae,value:Ce}=await e.confirmTransaction({signature:we,lastValidBlockHeight:k.lastValidBlockHeight,blockhash:k.recentBlockhash},I);if(Ce.err)throw new Error(`Transaction ${we} failed (${JSON.stringify(Ce)})`);for(;;){try{if(await e.getSlot({commitment:I})>Ae.slot)break}catch{}await new Promise((e=>setTimeout(e,Math.round(200))))}}return!0}}Loader.chunkSize=li;const hi=new PublicKey("BPFLoader2111111111111111111111111111111111");class BpfLoader{static getMinNumSignatures(e){return Loader.getMinNumSignatures(e)}static load(e,r,n,i,s){return Loader.load(e,r,n,s,i)}}function getDefaultExportFromCjs(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var fi=Object.prototype.toString,gi=Object.keys||function(e){var r=[];for(var n in e)r.push(n);return r};function stringify(e,r){var n,i,s,a,w,k,I;if(!0===e)return"true";if(!1===e)return"false";switch(typeof e){case"object":if(null===e)return null;if(e.toJSON&&"function"==typeof e.toJSON)return stringify(e.toJSON(),r);if("[object Array]"===(I=fi.call(e))){for(s="[",i=e.length-1,n=0;n<i;n++)s+=stringify(e[n],!0)+",";return i>-1&&(s+=stringify(e[n],!0)),s+"]"}if("[object Object]"===I){for(i=(a=gi(e).sort()).length,s="",n=0;n<i;)void 0!==(k=stringify(e[w=a[n]],!1))&&(s&&(s+=","),s+=JSON.stringify(w)+":"+k),n++;return"{"+s+"}"}return JSON.stringify(e);case"function":case"undefined":return r?null:void 0;case"string":return JSON.stringify(e);default:return isFinite(e)?e:null}}var pi=getDefaultExportFromCjs((function(e){var r=stringify(e,!1);if(void 0!==r)return""+r}));function trailingZeros(e){let r=0;for(;e>1;)e/=2,r++;return r}class EpochSchedule{constructor(e,r,n,i,s){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=r,this.warmup=n,this.firstNormalEpoch=i,this.firstNormalSlot=s}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const r=trailingZeros(function nextPowerOfTwo(e){return 0===e?1:(e--,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,e|=e>>16,1+(e|=e>>32))}(e+32+1))-trailingZeros(32)-1;return[r,e-(this.getSlotsInEpoch(r)-32)]}{const r=e-this.firstNormalSlot,n=Math.floor(r/this.slotsPerEpoch);return[this.firstNormalEpoch+n,r%this.slotsPerEpoch]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?32*(Math.pow(2,e)-1):(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+trailingZeros(32)):this.slotsPerEpoch}}class SendTransactionError extends Error{constructor(e,r){super(e),this.logs=void 0,this.logs=r}}const mi={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class SolanaJSONRPCError extends Error{constructor({code:e,message:r,data:n},i){super(null!=i?`${i}: ${r}`:r),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}var yi=globalThis.fetch;class RpcWebSocketClient extends Or.A{constructor(e,r,n){super((e=>{const n=(0,xr.A)(e,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...r});return this.underlyingSocket="socket"in n?n.socket:n,n}),e,r,n),this.underlyingSocket=void 0}call(...e){const r=this.underlyingSocket?.readyState;return 1===r?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}notify(...e){const r=this.underlyingSocket?.readyState;return 1===r?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}}class AddressLookupTableAccount{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const r=function decodeData(e,r){let n;try{n=e.layout.decode(r)}catch(e){throw new Error("invalid instruction; "+e)}if(n.typeIndex!==e.index)throw new Error(`invalid account data; account type mismatch ${n.typeIndex} != ${e.index}`);return n}(bi,e),n=e.length-56;index_browser_esm_assert(n>=0,"lookup table is invalid"),index_browser_esm_assert(n%32==0,"lookup table is invalid");const i=n/32,{addresses:s}=kr.struct([kr.seq(publicKey(),i,"addresses")]).decode(e.slice(56));return{deactivationSlot:r.deactivationSlot,lastExtendedSlot:r.lastExtendedSlot,lastExtendedSlotStartIndex:r.lastExtendedStartIndex,authority:0!==r.authority.length?new PublicKey(r.authority[0]):void 0,addresses:s.map((e=>new PublicKey(e)))}}}const bi={index:1,layout:kr.struct([kr.u32("typeIndex"),ci("deactivationSlot"),kr.nu64("lastExtendedSlot"),kr.u8("lastExtendedStartIndex"),kr.u8(),kr.seq(publicKey(),kr.offset(kr.u8(),-1),"authority")])},_i=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;const wi=(0,Ir.au)((0,Ir.KJ)(PublicKey),(0,Ir.Yj)(),(e=>new PublicKey(e))),Si=(0,Ir.PV)([(0,Ir.Yj)(),(0,Ir.eu)("base64")]),Ei=(0,Ir.au)((0,Ir.KJ)(s.Buffer),Si,(e=>s.Buffer.from(e[0],"base64"))),ki=3e4;function extractCommitmentFromConfig(e){let r,n;if("string"==typeof e)r=e;else if(e){const{commitment:i,...s}=e;r=i,n=s}return{commitment:r,config:n}}function createRpcResult(e){return(0,Ir.KC)([(0,Ir.NW)({jsonrpc:(0,Ir.eu)("2.0"),id:(0,Ir.Yj)(),result:e}),(0,Ir.NW)({jsonrpc:(0,Ir.eu)("2.0"),id:(0,Ir.Yj)(),error:(0,Ir.NW)({code:(0,Ir.L5)(),message:(0,Ir.Yj)(),data:(0,Ir.lq)((0,Ir.bz)())})})])}const Ai=createRpcResult((0,Ir.L5)());function jsonRpcResult(e){return(0,Ir.au)(createRpcResult(e),Ai,(r=>"error"in r?r:{...r,result:(0,Ir.vt)(r.result,e)}))}function jsonRpcResultAndContext(e){return jsonRpcResult((0,Ir.NW)({context:(0,Ir.NW)({slot:(0,Ir.ai)()}),value:e}))}function notificationResultAndContext(e){return(0,Ir.NW)({context:(0,Ir.NW)({slot:(0,Ir.ai)()}),value:e})}function versionedMessageFromResponse(e,r){return 0===e?new MessageV0({header:r.header,staticAccountKeys:r.accountKeys.map((e=>new PublicKey(e))),recentBlockhash:r.recentBlockhash,compiledInstructions:r.instructions.map((e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:yr().decode(e.data)}))),addressTableLookups:r.addressTableLookups}):new Message(r)}const Ii=(0,Ir.NW)({foundation:(0,Ir.ai)(),foundationTerm:(0,Ir.ai)(),initial:(0,Ir.ai)(),taper:(0,Ir.ai)(),terminal:(0,Ir.ai)()}),Ri=jsonRpcResult((0,Ir.YO)((0,Ir.me)((0,Ir.NW)({epoch:(0,Ir.ai)(),effectiveSlot:(0,Ir.ai)(),amount:(0,Ir.ai)(),postBalance:(0,Ir.ai)(),commission:(0,Ir.lq)((0,Ir.me)((0,Ir.ai)()))})))),vi=(0,Ir.YO)((0,Ir.NW)({slot:(0,Ir.ai)(),prioritizationFee:(0,Ir.ai)()})),Oi=(0,Ir.NW)({total:(0,Ir.ai)(),validator:(0,Ir.ai)(),foundation:(0,Ir.ai)(),epoch:(0,Ir.ai)()}),xi=(0,Ir.NW)({epoch:(0,Ir.ai)(),slotIndex:(0,Ir.ai)(),slotsInEpoch:(0,Ir.ai)(),absoluteSlot:(0,Ir.ai)(),blockHeight:(0,Ir.lq)((0,Ir.ai)()),transactionCount:(0,Ir.lq)((0,Ir.ai)())}),Ti=(0,Ir.NW)({slotsPerEpoch:(0,Ir.ai)(),leaderScheduleSlotOffset:(0,Ir.ai)(),warmup:(0,Ir.zM)(),firstNormalEpoch:(0,Ir.ai)(),firstNormalSlot:(0,Ir.ai)()}),Ni=(0,Ir.g1)((0,Ir.Yj)(),(0,Ir.YO)((0,Ir.ai)())),Pi=(0,Ir.me)((0,Ir.KC)([(0,Ir.NW)({}),(0,Ir.Yj)()])),Ci=(0,Ir.NW)({err:Pi}),Bi=(0,Ir.eu)("receivedSignature"),Li=(0,Ir.NW)({"solana-core":(0,Ir.Yj)(),"feature-set":(0,Ir.lq)((0,Ir.ai)())}),zi=jsonRpcResultAndContext((0,Ir.NW)({err:(0,Ir.me)((0,Ir.KC)([(0,Ir.NW)({}),(0,Ir.Yj)()])),logs:(0,Ir.me)((0,Ir.YO)((0,Ir.Yj)())),accounts:(0,Ir.lq)((0,Ir.me)((0,Ir.YO)((0,Ir.me)((0,Ir.NW)({executable:(0,Ir.zM)(),owner:(0,Ir.Yj)(),lamports:(0,Ir.ai)(),data:(0,Ir.YO)((0,Ir.Yj)()),rentEpoch:(0,Ir.lq)((0,Ir.ai)())}))))),unitsConsumed:(0,Ir.lq)((0,Ir.ai)()),returnData:(0,Ir.lq)((0,Ir.me)((0,Ir.NW)({programId:(0,Ir.Yj)(),data:(0,Ir.PV)([(0,Ir.Yj)(),(0,Ir.eu)("base64")])})))})),Di=jsonRpcResultAndContext((0,Ir.NW)({byIdentity:(0,Ir.g1)((0,Ir.Yj)(),(0,Ir.YO)((0,Ir.ai)())),range:(0,Ir.NW)({firstSlot:(0,Ir.ai)(),lastSlot:(0,Ir.ai)()})}));const Ki=jsonRpcResult(Ii),Ui=jsonRpcResult(Oi),Mi=jsonRpcResult(vi),Fi=jsonRpcResult(xi),Wi=jsonRpcResult(Ti),qi=jsonRpcResult(Ni),Vi=jsonRpcResult((0,Ir.ai)()),ji=jsonRpcResultAndContext((0,Ir.NW)({total:(0,Ir.ai)(),circulating:(0,Ir.ai)(),nonCirculating:(0,Ir.ai)(),nonCirculatingAccounts:(0,Ir.YO)(wi)})),Hi=(0,Ir.NW)({amount:(0,Ir.Yj)(),uiAmount:(0,Ir.me)((0,Ir.ai)()),decimals:(0,Ir.ai)(),uiAmountString:(0,Ir.lq)((0,Ir.Yj)())}),$i=jsonRpcResultAndContext((0,Ir.YO)((0,Ir.NW)({address:wi,amount:(0,Ir.Yj)(),uiAmount:(0,Ir.me)((0,Ir.ai)()),decimals:(0,Ir.ai)(),uiAmountString:(0,Ir.lq)((0,Ir.Yj)())}))),Yi=jsonRpcResultAndContext((0,Ir.YO)((0,Ir.NW)({pubkey:wi,account:(0,Ir.NW)({executable:(0,Ir.zM)(),owner:wi,lamports:(0,Ir.ai)(),data:Ei,rentEpoch:(0,Ir.ai)()})}))),Gi=(0,Ir.NW)({program:(0,Ir.Yj)(),parsed:(0,Ir.L5)(),space:(0,Ir.ai)()}),Ji=jsonRpcResultAndContext((0,Ir.YO)((0,Ir.NW)({pubkey:wi,account:(0,Ir.NW)({executable:(0,Ir.zM)(),owner:wi,lamports:(0,Ir.ai)(),data:Gi,rentEpoch:(0,Ir.ai)()})}))),Zi=jsonRpcResultAndContext((0,Ir.YO)((0,Ir.NW)({lamports:(0,Ir.ai)(),address:wi}))),Xi=(0,Ir.NW)({executable:(0,Ir.zM)(),owner:wi,lamports:(0,Ir.ai)(),data:Ei,rentEpoch:(0,Ir.ai)()}),Qi=(0,Ir.NW)({pubkey:wi,account:Xi}),eo=(0,Ir.au)((0,Ir.KC)([(0,Ir.KJ)(s.Buffer),Gi]),(0,Ir.KC)([Si,Gi]),(e=>Array.isArray(e)?(0,Ir.vt)(e,Ei):e)),to=(0,Ir.NW)({executable:(0,Ir.zM)(),owner:wi,lamports:(0,Ir.ai)(),data:eo,rentEpoch:(0,Ir.ai)()}),ro=(0,Ir.NW)({pubkey:wi,account:to}),no=(0,Ir.NW)({state:(0,Ir.KC)([(0,Ir.eu)("active"),(0,Ir.eu)("inactive"),(0,Ir.eu)("activating"),(0,Ir.eu)("deactivating")]),active:(0,Ir.ai)(),inactive:(0,Ir.ai)()}),io=jsonRpcResult((0,Ir.YO)((0,Ir.NW)({signature:(0,Ir.Yj)(),slot:(0,Ir.ai)(),err:Pi,memo:(0,Ir.me)((0,Ir.Yj)()),blockTime:(0,Ir.lq)((0,Ir.me)((0,Ir.ai)()))}))),oo=jsonRpcResult((0,Ir.YO)((0,Ir.NW)({signature:(0,Ir.Yj)(),slot:(0,Ir.ai)(),err:Pi,memo:(0,Ir.me)((0,Ir.Yj)()),blockTime:(0,Ir.lq)((0,Ir.me)((0,Ir.ai)()))}))),so=(0,Ir.NW)({subscription:(0,Ir.ai)(),result:notificationResultAndContext(Xi)}),ao=(0,Ir.NW)({pubkey:wi,account:Xi}),co=(0,Ir.NW)({subscription:(0,Ir.ai)(),result:notificationResultAndContext(ao)}),uo=(0,Ir.NW)({parent:(0,Ir.ai)(),slot:(0,Ir.ai)(),root:(0,Ir.ai)()}),lo=(0,Ir.NW)({subscription:(0,Ir.ai)(),result:uo}),ho=(0,Ir.KC)([(0,Ir.NW)({type:(0,Ir.KC)([(0,Ir.eu)("firstShredReceived"),(0,Ir.eu)("completed"),(0,Ir.eu)("optimisticConfirmation"),(0,Ir.eu)("root")]),slot:(0,Ir.ai)(),timestamp:(0,Ir.ai)()}),(0,Ir.NW)({type:(0,Ir.eu)("createdBank"),parent:(0,Ir.ai)(),slot:(0,Ir.ai)(),timestamp:(0,Ir.ai)()}),(0,Ir.NW)({type:(0,Ir.eu)("frozen"),slot:(0,Ir.ai)(),timestamp:(0,Ir.ai)(),stats:(0,Ir.NW)({numTransactionEntries:(0,Ir.ai)(),numSuccessfulTransactions:(0,Ir.ai)(),numFailedTransactions:(0,Ir.ai)(),maxTransactionsPerEntry:(0,Ir.ai)()})}),(0,Ir.NW)({type:(0,Ir.eu)("dead"),slot:(0,Ir.ai)(),timestamp:(0,Ir.ai)(),err:(0,Ir.Yj)()})]),fo=(0,Ir.NW)({subscription:(0,Ir.ai)(),result:ho}),go=(0,Ir.NW)({subscription:(0,Ir.ai)(),result:notificationResultAndContext((0,Ir.KC)([Ci,Bi]))}),po=(0,Ir.NW)({subscription:(0,Ir.ai)(),result:(0,Ir.ai)()}),mo=(0,Ir.NW)({pubkey:(0,Ir.Yj)(),gossip:(0,Ir.me)((0,Ir.Yj)()),tpu:(0,Ir.me)((0,Ir.Yj)()),rpc:(0,Ir.me)((0,Ir.Yj)()),version:(0,Ir.me)((0,Ir.Yj)())}),yo=(0,Ir.NW)({votePubkey:(0,Ir.Yj)(),nodePubkey:(0,Ir.Yj)(),activatedStake:(0,Ir.ai)(),epochVoteAccount:(0,Ir.zM)(),epochCredits:(0,Ir.YO)((0,Ir.PV)([(0,Ir.ai)(),(0,Ir.ai)(),(0,Ir.ai)()])),commission:(0,Ir.ai)(),lastVote:(0,Ir.ai)(),rootSlot:(0,Ir.me)((0,Ir.ai)())}),bo=jsonRpcResult((0,Ir.NW)({current:(0,Ir.YO)(yo),delinquent:(0,Ir.YO)(yo)})),_o=(0,Ir.KC)([(0,Ir.eu)("processed"),(0,Ir.eu)("confirmed"),(0,Ir.eu)("finalized")]),wo=(0,Ir.NW)({slot:(0,Ir.ai)(),confirmations:(0,Ir.me)((0,Ir.ai)()),err:Pi,confirmationStatus:(0,Ir.lq)(_o)}),So=jsonRpcResultAndContext((0,Ir.YO)((0,Ir.me)(wo))),Eo=jsonRpcResult((0,Ir.ai)()),ko=(0,Ir.NW)({accountKey:wi,writableIndexes:(0,Ir.YO)((0,Ir.ai)()),readonlyIndexes:(0,Ir.YO)((0,Ir.ai)())}),Ao=(0,Ir.NW)({signatures:(0,Ir.YO)((0,Ir.Yj)()),message:(0,Ir.NW)({accountKeys:(0,Ir.YO)((0,Ir.Yj)()),header:(0,Ir.NW)({numRequiredSignatures:(0,Ir.ai)(),numReadonlySignedAccounts:(0,Ir.ai)(),numReadonlyUnsignedAccounts:(0,Ir.ai)()}),instructions:(0,Ir.YO)((0,Ir.NW)({accounts:(0,Ir.YO)((0,Ir.ai)()),data:(0,Ir.Yj)(),programIdIndex:(0,Ir.ai)()})),recentBlockhash:(0,Ir.Yj)(),addressTableLookups:(0,Ir.lq)((0,Ir.YO)(ko))})}),Io=(0,Ir.NW)({pubkey:wi,signer:(0,Ir.zM)(),writable:(0,Ir.zM)(),source:(0,Ir.lq)((0,Ir.KC)([(0,Ir.eu)("transaction"),(0,Ir.eu)("lookupTable")]))}),Ro=(0,Ir.NW)({accountKeys:(0,Ir.YO)(Io),signatures:(0,Ir.YO)((0,Ir.Yj)())}),vo=(0,Ir.NW)({parsed:(0,Ir.L5)(),program:(0,Ir.Yj)(),programId:wi}),Oo=(0,Ir.NW)({accounts:(0,Ir.YO)(wi),data:(0,Ir.Yj)(),programId:wi}),xo=(0,Ir.KC)([Oo,vo]),To=(0,Ir.KC)([(0,Ir.NW)({parsed:(0,Ir.L5)(),program:(0,Ir.Yj)(),programId:(0,Ir.Yj)()}),(0,Ir.NW)({accounts:(0,Ir.YO)((0,Ir.Yj)()),data:(0,Ir.Yj)(),programId:(0,Ir.Yj)()})]),No=(0,Ir.au)(xo,To,(e=>"accounts"in e?(0,Ir.vt)(e,Oo):(0,Ir.vt)(e,vo))),Po=(0,Ir.NW)({signatures:(0,Ir.YO)((0,Ir.Yj)()),message:(0,Ir.NW)({accountKeys:(0,Ir.YO)(Io),instructions:(0,Ir.YO)(No),recentBlockhash:(0,Ir.Yj)(),addressTableLookups:(0,Ir.lq)((0,Ir.me)((0,Ir.YO)(ko)))})}),Co=(0,Ir.NW)({accountIndex:(0,Ir.ai)(),mint:(0,Ir.Yj)(),owner:(0,Ir.lq)((0,Ir.Yj)()),uiTokenAmount:Hi}),Bo=(0,Ir.NW)({writable:(0,Ir.YO)(wi),readonly:(0,Ir.YO)(wi)}),Lo=(0,Ir.NW)({err:Pi,fee:(0,Ir.ai)(),innerInstructions:(0,Ir.lq)((0,Ir.me)((0,Ir.YO)((0,Ir.NW)({index:(0,Ir.ai)(),instructions:(0,Ir.YO)((0,Ir.NW)({accounts:(0,Ir.YO)((0,Ir.ai)()),data:(0,Ir.Yj)(),programIdIndex:(0,Ir.ai)()}))})))),preBalances:(0,Ir.YO)((0,Ir.ai)()),postBalances:(0,Ir.YO)((0,Ir.ai)()),logMessages:(0,Ir.lq)((0,Ir.me)((0,Ir.YO)((0,Ir.Yj)()))),preTokenBalances:(0,Ir.lq)((0,Ir.me)((0,Ir.YO)(Co))),postTokenBalances:(0,Ir.lq)((0,Ir.me)((0,Ir.YO)(Co))),loadedAddresses:(0,Ir.lq)(Bo),computeUnitsConsumed:(0,Ir.lq)((0,Ir.ai)())}),zo=(0,Ir.NW)({err:Pi,fee:(0,Ir.ai)(),innerInstructions:(0,Ir.lq)((0,Ir.me)((0,Ir.YO)((0,Ir.NW)({index:(0,Ir.ai)(),instructions:(0,Ir.YO)(No)})))),preBalances:(0,Ir.YO)((0,Ir.ai)()),postBalances:(0,Ir.YO)((0,Ir.ai)()),logMessages:(0,Ir.lq)((0,Ir.me)((0,Ir.YO)((0,Ir.Yj)()))),preTokenBalances:(0,Ir.lq)((0,Ir.me)((0,Ir.YO)(Co))),postTokenBalances:(0,Ir.lq)((0,Ir.me)((0,Ir.YO)(Co))),loadedAddresses:(0,Ir.lq)(Bo),computeUnitsConsumed:(0,Ir.lq)((0,Ir.ai)())}),Do=(0,Ir.KC)([(0,Ir.eu)(0),(0,Ir.eu)("legacy")]),Ko=(0,Ir.NW)({pubkey:(0,Ir.Yj)(),lamports:(0,Ir.ai)(),postBalance:(0,Ir.me)((0,Ir.ai)()),rewardType:(0,Ir.me)((0,Ir.Yj)()),commission:(0,Ir.lq)((0,Ir.me)((0,Ir.ai)()))}),Uo=jsonRpcResult((0,Ir.me)((0,Ir.NW)({blockhash:(0,Ir.Yj)(),previousBlockhash:(0,Ir.Yj)(),parentSlot:(0,Ir.ai)(),transactions:(0,Ir.YO)((0,Ir.NW)({transaction:Ao,meta:(0,Ir.me)(Lo),version:(0,Ir.lq)(Do)})),rewards:(0,Ir.lq)((0,Ir.YO)(Ko)),blockTime:(0,Ir.me)((0,Ir.ai)()),blockHeight:(0,Ir.me)((0,Ir.ai)())}))),Mo=jsonRpcResult((0,Ir.me)((0,Ir.NW)({blockhash:(0,Ir.Yj)(),previousBlockhash:(0,Ir.Yj)(),parentSlot:(0,Ir.ai)(),rewards:(0,Ir.lq)((0,Ir.YO)(Ko)),blockTime:(0,Ir.me)((0,Ir.ai)()),blockHeight:(0,Ir.me)((0,Ir.ai)())}))),Fo=jsonRpcResult((0,Ir.me)((0,Ir.NW)({blockhash:(0,Ir.Yj)(),previousBlockhash:(0,Ir.Yj)(),parentSlot:(0,Ir.ai)(),transactions:(0,Ir.YO)((0,Ir.NW)({transaction:Ro,meta:(0,Ir.me)(Lo),version:(0,Ir.lq)(Do)})),rewards:(0,Ir.lq)((0,Ir.YO)(Ko)),blockTime:(0,Ir.me)((0,Ir.ai)()),blockHeight:(0,Ir.me)((0,Ir.ai)())}))),Wo=jsonRpcResult((0,Ir.me)((0,Ir.NW)({blockhash:(0,Ir.Yj)(),previousBlockhash:(0,Ir.Yj)(),parentSlot:(0,Ir.ai)(),transactions:(0,Ir.YO)((0,Ir.NW)({transaction:Po,meta:(0,Ir.me)(zo),version:(0,Ir.lq)(Do)})),rewards:(0,Ir.lq)((0,Ir.YO)(Ko)),blockTime:(0,Ir.me)((0,Ir.ai)()),blockHeight:(0,Ir.me)((0,Ir.ai)())}))),qo=jsonRpcResult((0,Ir.me)((0,Ir.NW)({blockhash:(0,Ir.Yj)(),previousBlockhash:(0,Ir.Yj)(),parentSlot:(0,Ir.ai)(),transactions:(0,Ir.YO)((0,Ir.NW)({transaction:Ro,meta:(0,Ir.me)(zo),version:(0,Ir.lq)(Do)})),rewards:(0,Ir.lq)((0,Ir.YO)(Ko)),blockTime:(0,Ir.me)((0,Ir.ai)()),blockHeight:(0,Ir.me)((0,Ir.ai)())}))),Vo=jsonRpcResult((0,Ir.me)((0,Ir.NW)({blockhash:(0,Ir.Yj)(),previousBlockhash:(0,Ir.Yj)(),parentSlot:(0,Ir.ai)(),rewards:(0,Ir.lq)((0,Ir.YO)(Ko)),blockTime:(0,Ir.me)((0,Ir.ai)()),blockHeight:(0,Ir.me)((0,Ir.ai)())}))),jo=jsonRpcResult((0,Ir.me)((0,Ir.NW)({blockhash:(0,Ir.Yj)(),previousBlockhash:(0,Ir.Yj)(),parentSlot:(0,Ir.ai)(),transactions:(0,Ir.YO)((0,Ir.NW)({transaction:Ao,meta:(0,Ir.me)(Lo)})),rewards:(0,Ir.lq)((0,Ir.YO)(Ko)),blockTime:(0,Ir.me)((0,Ir.ai)())}))),Ho=jsonRpcResult((0,Ir.me)((0,Ir.NW)({blockhash:(0,Ir.Yj)(),previousBlockhash:(0,Ir.Yj)(),parentSlot:(0,Ir.ai)(),signatures:(0,Ir.YO)((0,Ir.Yj)()),blockTime:(0,Ir.me)((0,Ir.ai)())}))),$o=jsonRpcResult((0,Ir.me)((0,Ir.NW)({slot:(0,Ir.ai)(),meta:(0,Ir.me)(Lo),blockTime:(0,Ir.lq)((0,Ir.me)((0,Ir.ai)())),transaction:Ao,version:(0,Ir.lq)(Do)}))),Yo=jsonRpcResult((0,Ir.me)((0,Ir.NW)({slot:(0,Ir.ai)(),transaction:Po,meta:(0,Ir.me)(zo),blockTime:(0,Ir.lq)((0,Ir.me)((0,Ir.ai)())),version:(0,Ir.lq)(Do)}))),Go=jsonRpcResultAndContext((0,Ir.NW)({blockhash:(0,Ir.Yj)(),feeCalculator:(0,Ir.NW)({lamportsPerSignature:(0,Ir.ai)()})})),Jo=jsonRpcResultAndContext((0,Ir.NW)({blockhash:(0,Ir.Yj)(),lastValidBlockHeight:(0,Ir.ai)()})),Zo=jsonRpcResultAndContext((0,Ir.zM)()),Xo=(0,Ir.NW)({slot:(0,Ir.ai)(),numTransactions:(0,Ir.ai)(),numSlots:(0,Ir.ai)(),samplePeriodSecs:(0,Ir.ai)()}),Qo=jsonRpcResult((0,Ir.YO)(Xo)),es=jsonRpcResultAndContext((0,Ir.me)((0,Ir.NW)({feeCalculator:(0,Ir.NW)({lamportsPerSignature:(0,Ir.ai)()})}))),ts=jsonRpcResult((0,Ir.Yj)()),rs=jsonRpcResult((0,Ir.Yj)()),ns=(0,Ir.NW)({err:Pi,logs:(0,Ir.YO)((0,Ir.Yj)()),signature:(0,Ir.Yj)()}),os=(0,Ir.NW)({result:notificationResultAndContext(ns),subscription:(0,Ir.ai)()}),ss={"solana-client":"js/0.0.0-development"};class Connection{constructor(e,r){let n,i,s,a,w,k;this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const e={};return async r=>{const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgs([],n,void 0,i),a=pi(s);return e[a]=e[a]??(async()=>{try{const e=await this._rpcRequest("getBlockHeight",s),r=(0,Ir.vt)(e,jsonRpcResult((0,Ir.ai)()));if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get block height information");return r.result}finally{delete e[a]}})(),await e[a]}})(),r&&"string"==typeof r?this._commitment=r:r&&(this._commitment=r.commitment,this._confirmTransactionInitialTimeout=r.confirmTransactionInitialTimeout,n=r.wsEndpoint,i=r.httpHeaders,s=r.fetch,a=r.fetchMiddleware,w=r.disableRetryOnRateLimit,k=r.httpAgent),this._rpcEndpoint=function assertEndpointUrl(e){if(!1===/^https?:/.test(e))throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return e}(e),this._rpcWsEndpoint=n||function makeWebsocketUrl(e){const r=e.match(_i);if(null==r)throw TypeError(`Failed to validate endpoint URL \`${e}\``);const[n,i,s,a]=r,w=e.startsWith("https:")?"wss:":"ws:",k=null==s?null:parseInt(s.slice(1),10);return`${w}//${i}${null==k?"":`:${k+1}`}${a}`}(e),this._rpcClient=function createRpcClient(e,r,n,i,s,a){const w=n||yi;let k;return null!=a&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments."),i&&(k=async(e,r)=>{const n=await new Promise(((n,s)=>{try{i(e,r,((e,r)=>n([e,r])))}catch(e){s(e)}}));return await w(...n)}),new(vr())((async(n,i)=>{const a={method:"POST",body:n,agent:void 0,headers:Object.assign({"Content-Type":"application/json"},r||{},ss)};try{let r,n=5,I=500;for(;r=k?await k(e,a):await w(e,a),429===r.status&&!0!==s&&(n-=1,0!==n);)console.error(`Server responded with ${r.status} ${r.statusText}.  Retrying after ${I}ms delay...`),await sleep(I),I*=2;const we=await r.text();r.ok?i(null,we):i(new Error(`${r.status} ${r.statusText}: ${we}`))}catch(e){e instanceof Error&&i(e)}}),{})}(e,i,s,a,w,k),this._rpcRequest=function createRpcRequest(e){return(r,n)=>new Promise(((i,s)=>{e.request(r,n,((e,r)=>{e?s(e):i(r)}))}))}(this._rpcClient),this._rpcBatchRequest=function createRpcBatchRequest(e){return r=>new Promise(((n,i)=>{0===r.length&&n([]);const s=r.map((r=>e.request(r.methodName,r.args)));e.request(s,((e,r)=>{e?i(e):n(r)}))}))}(this._rpcClient),this._rpcWebSocket=new RpcWebSocketClient(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgs([e.toBase58()],n,void 0,i),a=await this._rpcRequest("getBalance",s),w=(0,Ir.vt)(a,jsonRpcResultAndContext((0,Ir.ai)()));if("error"in w)throw new SolanaJSONRPCError(w.error,`failed to get balance for ${e.toBase58()}`);return w.result}async getBalance(e,r){return await this.getBalanceAndContext(e,r).then((e=>e.value)).catch((r=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+r)}))}async getBlockTime(e){const r=await this._rpcRequest("getBlockTime",[e]),n=(0,Ir.vt)(r,jsonRpcResult((0,Ir.me)((0,Ir.ai)())));if("error"in n)throw new SolanaJSONRPCError(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),r=(0,Ir.vt)(e,jsonRpcResult((0,Ir.ai)()));if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get minimum ledger slot");return r.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),r=(0,Ir.vt)(e,Vi);if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get first available block");return r.result}async getSupply(e){let r={};r="string"==typeof e?{commitment:e}:e?{...e,commitment:e&&e.commitment||this.commitment}:{commitment:this.commitment};const n=await this._rpcRequest("getSupply",[r]),i=(0,Ir.vt)(n,ji);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get supply");return i.result}async getTokenSupply(e,r){const n=this._buildArgs([e.toBase58()],r),i=await this._rpcRequest("getTokenSupply",n),s=(0,Ir.vt)(i,jsonRpcResultAndContext(Hi));if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get token supply");return s.result}async getTokenAccountBalance(e,r){const n=this._buildArgs([e.toBase58()],r),i=await this._rpcRequest("getTokenAccountBalance",n),s=(0,Ir.vt)(i,jsonRpcResultAndContext(Hi));if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get token account balance");return s.result}async getTokenAccountsByOwner(e,r,n){const{commitment:i,config:s}=extractCommitmentFromConfig(n);let a=[e.toBase58()];"mint"in r?a.push({mint:r.mint.toBase58()}):a.push({programId:r.programId.toBase58()});const w=this._buildArgs(a,i,"base64",s),k=await this._rpcRequest("getTokenAccountsByOwner",w),I=(0,Ir.vt)(k,Yi);if("error"in I)throw new SolanaJSONRPCError(I.error,`failed to get token accounts owned by account ${e.toBase58()}`);return I.result}async getParsedTokenAccountsByOwner(e,r,n){let i=[e.toBase58()];"mint"in r?i.push({mint:r.mint.toBase58()}):i.push({programId:r.programId.toBase58()});const s=this._buildArgs(i,n,"jsonParsed"),a=await this._rpcRequest("getTokenAccountsByOwner",s),w=(0,Ir.vt)(a,Ji);if("error"in w)throw new SolanaJSONRPCError(w.error,`failed to get token accounts owned by account ${e.toBase58()}`);return w.result}async getLargestAccounts(e){const r={...e,commitment:e&&e.commitment||this.commitment},n=r.filter||r.commitment?[r]:[],i=await this._rpcRequest("getLargestAccounts",n),s=(0,Ir.vt)(i,Zi);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get largest accounts");return s.result}async getTokenLargestAccounts(e,r){const n=this._buildArgs([e.toBase58()],r),i=await this._rpcRequest("getTokenLargestAccounts",n),s=(0,Ir.vt)(i,$i);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get token largest accounts");return s.result}async getAccountInfoAndContext(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgs([e.toBase58()],n,"base64",i),a=await this._rpcRequest("getAccountInfo",s),w=(0,Ir.vt)(a,jsonRpcResultAndContext((0,Ir.me)(Xi)));if("error"in w)throw new SolanaJSONRPCError(w.error,`failed to get info about account ${e.toBase58()}`);return w.result}async getParsedAccountInfo(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgs([e.toBase58()],n,"jsonParsed",i),a=await this._rpcRequest("getAccountInfo",s),w=(0,Ir.vt)(a,jsonRpcResultAndContext((0,Ir.me)(to)));if("error"in w)throw new SolanaJSONRPCError(w.error,`failed to get info about account ${e.toBase58()}`);return w.result}async getAccountInfo(e,r){try{return(await this.getAccountInfoAndContext(e,r)).value}catch(r){throw new Error("failed to get info about account "+e.toBase58()+": "+r)}}async getMultipleParsedAccounts(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=e.map((e=>e.toBase58())),a=this._buildArgs([s],n,"jsonParsed",i),w=await this._rpcRequest("getMultipleAccounts",a),k=(0,Ir.vt)(w,jsonRpcResultAndContext((0,Ir.YO)((0,Ir.me)(to))));if("error"in k)throw new SolanaJSONRPCError(k.error,`failed to get info for accounts ${s}`);return k.result}async getMultipleAccountsInfoAndContext(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=e.map((e=>e.toBase58())),a=this._buildArgs([s],n,"base64",i),w=await this._rpcRequest("getMultipleAccounts",a),k=(0,Ir.vt)(w,jsonRpcResultAndContext((0,Ir.YO)((0,Ir.me)(Xi))));if("error"in k)throw new SolanaJSONRPCError(k.error,`failed to get info for accounts ${s}`);return k.result}async getMultipleAccountsInfo(e,r){return(await this.getMultipleAccountsInfoAndContext(e,r)).value}async getStakeActivation(e,r,n){const{commitment:i,config:s}=extractCommitmentFromConfig(r),a=this._buildArgs([e.toBase58()],i,void 0,{...s,epoch:null!=n?n:s?.epoch}),w=await this._rpcRequest("getStakeActivation",a),k=(0,Ir.vt)(w,jsonRpcResult(no));if("error"in k)throw new SolanaJSONRPCError(k.error,`failed to get Stake Activation ${e.toBase58()}`);return k.result}async getProgramAccounts(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),{encoding:s,...a}=i||{},w=this._buildArgs([e.toBase58()],n,s||"base64",a),k=await this._rpcRequest("getProgramAccounts",w),I=(0,Ir.YO)(Qi),we=!0===a.withContext?(0,Ir.vt)(k,jsonRpcResultAndContext(I)):(0,Ir.vt)(k,jsonRpcResult(I));if("error"in we)throw new SolanaJSONRPCError(we.error,`failed to get accounts owned by program ${e.toBase58()}`);return we.result}async getParsedProgramAccounts(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgs([e.toBase58()],n,"jsonParsed",i),a=await this._rpcRequest("getProgramAccounts",s),w=(0,Ir.vt)(a,jsonRpcResult((0,Ir.YO)(ro)));if("error"in w)throw new SolanaJSONRPCError(w.error,`failed to get accounts owned by program ${e.toBase58()}`);return w.result}async confirmTransaction(e,r){let n,i;if("string"==typeof e)n=e;else{const r=e;if(r.abortSignal?.aborted)return Promise.reject(r.abortSignal.reason);n=r.signature}try{i=yr().decode(n)}catch(e){throw new Error("signature must be base58 encoded: "+n)}return index_browser_esm_assert(64===i.length,"signature has invalid length"),"string"==typeof e?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:r||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:r||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:r||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise(((r,n)=>{null!=e&&(e.aborted?n(e.reason):e.addEventListener("abort",(()=>{n(e.reason)})))}))}getTransactionConfirmationPromise({commitment:e,signature:r}){let n,i,s=!1;return{abortConfirmation:()=>{i&&(i(),i=void 0),null!=n&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:new Promise(((a,w)=>{try{n=this.onSignature(r,((e,r)=>{n=void 0;const i={context:r,value:e};a({__type:Bn.PROCESSED,response:i})}),e);const k=new Promise((e=>{null==n?e():i=this._onSubscriptionStateChange(n,(r=>{"subscribed"===r&&e()}))}));(async()=>{if(await k,s)return;const n=await this.getSignatureStatus(r);if(s)return;if(null==n)return;const{context:i,value:I}=n;if(null!=I)if(I?.err)w(I.err);else{switch(e){case"confirmed":case"single":case"singleGossip":if("processed"===I.confirmationStatus)return;break;case"finalized":case"max":case"root":if("processed"===I.confirmationStatus||"confirmed"===I.confirmationStatus)return}s=!0,a({__type:Bn.PROCESSED,response:{context:i,value:I}})}})()}catch(e){w(e)}}))}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:r,lastValidBlockHeight:n,signature:i}}){let s=!1;const a=new Promise((r=>{const checkBlockHeight=async()=>{try{return await this.getBlockHeight(e)}catch(e){return-1}};(async()=>{let e=await checkBlockHeight();if(!s){for(;e<=n;){if(await sleep(1e3),s)return;if(e=await checkBlockHeight(),s)return}r({__type:Bn.BLOCKHEIGHT_EXCEEDED})}})()})),{abortConfirmation:w,confirmationPromise:k}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),I=this.getCancellationPromise(r);let we;try{const e=await Promise.race([I,k,a]);if(e.__type!==Bn.PROCESSED)throw new TransactionExpiredBlockheightExceededError(i);we=e.response}finally{s=!0,w()}return we}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:r,minContextSlot:n,nonceAccountPubkey:i,nonceValue:s,signature:a}}){let w=!1;const k=new Promise((r=>{let a=s,k=null;const getCurrentNonceValue=async()=>{try{const{context:r,value:s}=await this.getNonceAndContext(i,{commitment:e,minContextSlot:n});return k=r.slot,s?.nonce}catch(e){return a}};(async()=>{if(a=await getCurrentNonceValue(),!w)for(;;){if(s!==a)return void r({__type:Bn.NONCE_INVALID,slotInWhichNonceDidAdvance:k});if(await sleep(2e3),w)return;if(a=await getCurrentNonceValue(),w)return}})()})),{abortConfirmation:I,confirmationPromise:we}=this.getTransactionConfirmationPromise({commitment:e,signature:a}),Ae=this.getCancellationPromise(r);let Ce;try{const r=await Promise.race([Ae,we,k]);if(r.__type===Bn.PROCESSED)Ce=r.response;else{let i;for(;;){const e=await this.getSignatureStatus(a);if(null==e)break;if(!(e.context.slot<(r.slotInWhichNonceDidAdvance??n))){i=e;break}await sleep(400)}if(!i?.value)throw new TransactionExpiredNonceInvalidError(a);{const r=e||"finalized",{confirmationStatus:n}=i.value;switch(r){case"processed":case"recent":if("processed"!==n&&"confirmed"!==n&&"finalized"!==n)throw new TransactionExpiredNonceInvalidError(a);break;case"confirmed":case"single":case"singleGossip":if("confirmed"!==n&&"finalized"!==n)throw new TransactionExpiredNonceInvalidError(a);break;case"finalized":case"max":case"root":if("finalized"!==n)throw new TransactionExpiredNonceInvalidError(a)}Ce={context:i.context,value:{err:i.value.err}}}}}finally{w=!0,I()}return Ce}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:r}){let n;const i=new Promise((r=>{let i=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":i=this._confirmTransactionInitialTimeout||3e4}n=setTimeout((()=>r({__type:Bn.TIMED_OUT,timeoutMs:i})),i)})),{abortConfirmation:s,confirmationPromise:a}=this.getTransactionConfirmationPromise({commitment:e,signature:r});let w;try{const e=await Promise.race([a,i]);if(e.__type!==Bn.PROCESSED)throw new TransactionExpiredTimeoutError(r,e.timeoutMs/1e3);w=e.response}finally{clearTimeout(n),s()}return w}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),r=(0,Ir.vt)(e,jsonRpcResult((0,Ir.YO)(mo)));if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get cluster nodes");return r.result}async getVoteAccounts(e){const r=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",r),i=(0,Ir.vt)(n,bo);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get vote accounts");return i.result}async getSlot(e){const{commitment:r,config:n}=extractCommitmentFromConfig(e),i=this._buildArgs([],r,void 0,n),s=await this._rpcRequest("getSlot",i),a=(0,Ir.vt)(s,jsonRpcResult((0,Ir.ai)()));if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to get slot");return a.result}async getSlotLeader(e){const{commitment:r,config:n}=extractCommitmentFromConfig(e),i=this._buildArgs([],r,void 0,n),s=await this._rpcRequest("getSlotLeader",i),a=(0,Ir.vt)(s,jsonRpcResult((0,Ir.Yj)()));if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to get slot leader");return a.result}async getSlotLeaders(e,r){const n=[e,r],i=await this._rpcRequest("getSlotLeaders",n),s=(0,Ir.vt)(i,jsonRpcResult((0,Ir.YO)(wi)));if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get slot leaders");return s.result}async getSignatureStatus(e,r){const{context:n,value:i}=await this.getSignatureStatuses([e],r);index_browser_esm_assert(1===i.length);return{context:n,value:i[0]}}async getSignatureStatuses(e,r){const n=[e];r&&n.push(r);const i=await this._rpcRequest("getSignatureStatuses",n),s=(0,Ir.vt)(i,So);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get signature status");return s.result}async getTransactionCount(e){const{commitment:r,config:n}=extractCommitmentFromConfig(e),i=this._buildArgs([],r,void 0,n),s=await this._rpcRequest("getTransactionCount",i),a=(0,Ir.vt)(s,jsonRpcResult((0,Ir.ai)()));if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to get transaction count");return a.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const r=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",r),i=(0,Ir.vt)(n,Ki);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get inflation");return i.result}async getInflationReward(e,r,n){const{commitment:i,config:s}=extractCommitmentFromConfig(n),a=this._buildArgs([e.map((e=>e.toBase58()))],i,void 0,{...s,epoch:null!=r?r:s?.epoch}),w=await this._rpcRequest("getInflationReward",a),k=(0,Ir.vt)(w,Ri);if("error"in k)throw new SolanaJSONRPCError(k.error,"failed to get inflation reward");return k.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),r=(0,Ir.vt)(e,Ui);if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get inflation rate");return r.result}async getEpochInfo(e){const{commitment:r,config:n}=extractCommitmentFromConfig(e),i=this._buildArgs([],r,void 0,n),s=await this._rpcRequest("getEpochInfo",i),a=(0,Ir.vt)(s,Fi);if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to get epoch info");return a.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),r=(0,Ir.vt)(e,Wi);if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get epoch schedule");const n=r.result;return new EpochSchedule(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),r=(0,Ir.vt)(e,qi);if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get leader schedule");return r.result}async getMinimumBalanceForRentExemption(e,r){const n=this._buildArgs([e],r),i=await this._rpcRequest("getMinimumBalanceForRentExemption",n),s=(0,Ir.vt)(i,Eo);return"error"in s?(console.warn("Unable to fetch minimum balance for rent exemption"),0):s.result}async getRecentBlockhashAndContext(e){const r=this._buildArgs([],e),n=await this._rpcRequest("getRecentBlockhash",r),i=(0,Ir.vt)(n,Go);if("error"in i)throw new SolanaJSONRPCError(i.error,"failed to get recent blockhash");return i.result}async getRecentPerformanceSamples(e){const r=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=(0,Ir.vt)(r,Qo);if("error"in n)throw new SolanaJSONRPCError(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,r){const n=this._buildArgs([e],r),i=await this._rpcRequest("getFeeCalculatorForBlockhash",n),s=(0,Ir.vt)(i,es);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get fee calculator");const{context:a,value:w}=s.result;return{context:a,value:null!==w?w.feeCalculator:null}}async getFeeForMessage(e,r){const n=toBuffer(e.serialize()).toString("base64"),i=this._buildArgs([n],r),s=await this._rpcRequest("getFeeForMessage",i),a=(0,Ir.vt)(s,jsonRpcResultAndContext((0,Ir.me)((0,Ir.ai)())));if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to get fee for message");if(null===a.result)throw new Error("invalid blockhash");return a.result}async getRecentPrioritizationFees(e){const r=e?.lockedWritableAccounts?.map((e=>e.toBase58())),n=r?.length?[r]:[],i=await this._rpcRequest("getRecentPrioritizationFees",n),s=(0,Ir.vt)(i,Mi);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get recent prioritization fees");return s.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhashAndContext(e){const{commitment:r,config:n}=extractCommitmentFromConfig(e),i=this._buildArgs([],r,void 0,n),s=await this._rpcRequest("getLatestBlockhash",i),a=(0,Ir.vt)(s,Jo);if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to get latest blockhash");return a.result}async isBlockhashValid(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgs([e],n,void 0,i),a=await this._rpcRequest("isBlockhashValid",s),w=(0,Ir.vt)(a,Zo);if("error"in w)throw new SolanaJSONRPCError(w.error,"failed to determine if the blockhash `"+e+"`is valid");return w.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),r=(0,Ir.vt)(e,jsonRpcResult(Li));if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get version");return r.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),r=(0,Ir.vt)(e,jsonRpcResult((0,Ir.Yj)()));if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get genesis hash");return r.result}async getBlock(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgsAtLeastConfirmed([e],n,void 0,i),a=await this._rpcRequest("getBlock",s);try{switch(i?.transactionDetails){case"accounts":{const e=(0,Ir.vt)(a,Fo);if("error"in e)throw e.error;return e.result}case"none":{const e=(0,Ir.vt)(a,Mo);if("error"in e)throw e.error;return e.result}default:{const e=(0,Ir.vt)(a,Uo);if("error"in e)throw e.error;const{result:r}=e;return r?{...r,transactions:r.transactions.map((({transaction:e,meta:r,version:n})=>({meta:r,transaction:{...e,message:versionedMessageFromResponse(n,e.message)},version:n})))}:null}}}catch(e){throw new SolanaJSONRPCError(e,"failed to get confirmed block")}}async getParsedBlock(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",i),a=await this._rpcRequest("getBlock",s);try{switch(i?.transactionDetails){case"accounts":{const e=(0,Ir.vt)(a,qo);if("error"in e)throw e.error;return e.result}case"none":{const e=(0,Ir.vt)(a,Vo);if("error"in e)throw e.error;return e.result}default:{const e=(0,Ir.vt)(a,Wo);if("error"in e)throw e.error;return e.result}}}catch(e){throw new SolanaJSONRPCError(e,"failed to get block")}}async getBlockProduction(e){let r,n;if("string"==typeof e)n=e;else if(e){const{commitment:i,...s}=e;n=i,r=s}const i=this._buildArgs([],n,"base64",r),s=await this._rpcRequest("getBlockProduction",i),a=(0,Ir.vt)(s,Di);if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to get block production information");return a.result}async getTransaction(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgsAtLeastConfirmed([e],n,void 0,i),a=await this._rpcRequest("getTransaction",s),w=(0,Ir.vt)(a,$o);if("error"in w)throw new SolanaJSONRPCError(w.error,"failed to get transaction");const k=w.result;return k?{...k,transaction:{...k.transaction,message:versionedMessageFromResponse(k.version,k.transaction.message)}}:k}async getParsedTransaction(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",i),a=await this._rpcRequest("getTransaction",s),w=(0,Ir.vt)(a,Yo);if("error"in w)throw new SolanaJSONRPCError(w.error,"failed to get transaction");return w.result}async getParsedTransactions(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=e.map((e=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",i)})));return(await this._rpcBatchRequest(s)).map((e=>{const r=(0,Ir.vt)(e,Yo);if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get transactions");return r.result}))}async getTransactions(e,r){const{commitment:n,config:i}=extractCommitmentFromConfig(r),s=e.map((e=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([e],n,void 0,i)})));return(await this._rpcBatchRequest(s)).map((e=>{const r=(0,Ir.vt)(e,$o);if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get transactions");const n=r.result;return n?{...n,transaction:{...n.transaction,message:versionedMessageFromResponse(n.version,n.transaction.message)}}:n}))}async getConfirmedBlock(e,r){const n=this._buildArgsAtLeastConfirmed([e],r),i=await this._rpcRequest("getConfirmedBlock",n),s=(0,Ir.vt)(i,jo);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get confirmed block");const a=s.result;if(!a)throw new Error("Confirmed block "+e+" not found");const w={...a,transactions:a.transactions.map((({transaction:e,meta:r})=>{const n=new Message(e.message);return{meta:r,transaction:{...e,message:n}}}))};return{...w,transactions:w.transactions.map((({transaction:e,meta:r})=>({meta:r,transaction:Transaction.populate(e.message,e.signatures)})))}}async getBlocks(e,r,n){const i=this._buildArgsAtLeastConfirmed(void 0!==r?[e,r]:[e],n),s=await this._rpcRequest("getBlocks",i),a=(0,Ir.vt)(s,jsonRpcResult((0,Ir.YO)((0,Ir.ai)())));if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to get blocks");return a.result}async getBlockSignatures(e,r){const n=this._buildArgsAtLeastConfirmed([e],r,void 0,{transactionDetails:"signatures",rewards:!1}),i=await this._rpcRequest("getBlock",n),s=(0,Ir.vt)(i,Ho);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get block");const a=s.result;if(!a)throw new Error("Block "+e+" not found");return a}async getConfirmedBlockSignatures(e,r){const n=this._buildArgsAtLeastConfirmed([e],r,void 0,{transactionDetails:"signatures",rewards:!1}),i=await this._rpcRequest("getConfirmedBlock",n),s=(0,Ir.vt)(i,Ho);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get confirmed block");const a=s.result;if(!a)throw new Error("Confirmed block "+e+" not found");return a}async getConfirmedTransaction(e,r){const n=this._buildArgsAtLeastConfirmed([e],r),i=await this._rpcRequest("getConfirmedTransaction",n),s=(0,Ir.vt)(i,$o);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get transaction");const a=s.result;if(!a)return a;const w=new Message(a.transaction.message),k=a.transaction.signatures;return{...a,transaction:Transaction.populate(w,k)}}async getParsedConfirmedTransaction(e,r){const n=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed"),i=await this._rpcRequest("getConfirmedTransaction",n),s=(0,Ir.vt)(i,Yo);if("error"in s)throw new SolanaJSONRPCError(s.error,"failed to get confirmed transaction");return s.result}async getParsedConfirmedTransactions(e,r){const n=e.map((e=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([e],r,"jsonParsed")})));return(await this._rpcBatchRequest(n)).map((e=>{const r=(0,Ir.vt)(e,Yo);if("error"in r)throw new SolanaJSONRPCError(r.error,"failed to get confirmed transactions");return r.result}))}async getConfirmedSignaturesForAddress(e,r,n){let i={},s=await this.getFirstAvailableBlock();for(;!("until"in i)&&!(--r<=0||r<s);)try{const e=await this.getConfirmedBlockSignatures(r,"finalized");e.signatures.length>0&&(i.until=e.signatures[e.signatures.length-1].toString())}catch(e){if(e instanceof Error&&e.message.includes("skipped"))continue;throw e}let a=await this.getSlot("finalized");for(;!("before"in i||++n>a);)try{const e=await this.getConfirmedBlockSignatures(n);e.signatures.length>0&&(i.before=e.signatures[e.signatures.length-1].toString())}catch(e){if(e instanceof Error&&e.message.includes("skipped"))continue;throw e}return(await this.getConfirmedSignaturesForAddress2(e,i)).map((e=>e.signature))}async getConfirmedSignaturesForAddress2(e,r,n){const i=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,r),s=await this._rpcRequest("getConfirmedSignaturesForAddress2",i),a=(0,Ir.vt)(s,io);if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to get confirmed signatures for address");return a.result}async getSignaturesForAddress(e,r,n){const i=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,r),s=await this._rpcRequest("getSignaturesForAddress",i),a=(0,Ir.vt)(s,oo);if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to get signatures for address");return a.result}async getAddressLookupTable(e,r){const{context:n,value:i}=await this.getAccountInfoAndContext(e,r);let s=null;return null!==i&&(s=new AddressLookupTableAccount({key:e,state:AddressLookupTableAccount.deserialize(i.data)})),{context:n,value:s}}async getNonceAndContext(e,r){const{context:n,value:i}=await this.getAccountInfoAndContext(e,r);let s=null;return null!==i&&(s=NonceAccount.fromAccountData(i.data)),{context:n,value:s}}async getNonce(e,r){return await this.getNonceAndContext(e,r).then((e=>e.value)).catch((r=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+r)}))}async requestAirdrop(e,r){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),r]),i=(0,Ir.vt)(n,ts);if("error"in i)throw new SolanaJSONRPCError(i.error,`airdrop to ${e.toBase58()} failed`);return i.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await sleep(100);const e=Date.now()-this._blockhashInfo.lastFetch>=ki;if(null!==this._blockhashInfo.latestBlockhash&&!e)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),r=this._blockhashInfo.latestBlockhash,n=r?r.blockhash:null;for(let e=0;e<50;e++){const e=await this.getLatestBlockhash("finalized");if(n!==e.blockhash)return this._blockhashInfo={latestBlockhash:e,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},e;await sleep(200)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:r,config:n}=extractCommitmentFromConfig(e),i=this._buildArgs([],r,"base64",n),s=await this._rpcRequest("getStakeMinimumDelegation",i),a=(0,Ir.vt)(s,jsonRpcResultAndContext((0,Ir.ai)()));if("error"in a)throw new SolanaJSONRPCError(a.error,"failed to get stake minimum delegation");return a.result}async simulateTransaction(e,r,n){if("message"in e){const i=e.serialize(),a=s.Buffer.from(i).toString("base64");if(Array.isArray(r)||void 0!==n)throw new Error("Invalid arguments");const w=r||{};w.encoding="base64","commitment"in w||(w.commitment=this.commitment);const k=[a,w],I=await this._rpcRequest("simulateTransaction",k),we=(0,Ir.vt)(I,zi);if("error"in we)throw new Error("failed to simulate transaction: "+we.error.message);return we.result}let i;if(e instanceof Transaction){let r=e;i=new Transaction,i.feePayer=r.feePayer,i.instructions=e.instructions,i.nonceInfo=r.nonceInfo,i.signatures=r.signatures}else i=Transaction.populate(e),i._message=i._json=void 0;if(void 0!==r&&!Array.isArray(r))throw new Error("Invalid arguments");const a=r;if(i.nonceInfo&&a)i.sign(...a);else{let e=this._disableBlockhashCaching;for(;;){const r=await this._blockhashWithExpiryBlockHeight(e);if(i.lastValidBlockHeight=r.lastValidBlockHeight,i.recentBlockhash=r.blockhash,!a)break;if(i.sign(...a),!i.signature)throw new Error("!signature");const n=i.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(n)&&!this._blockhashInfo.transactionSignatures.includes(n)){this._blockhashInfo.simulatedSignatures.push(n);break}e=!0}}const w=i._compile(),k=w.serialize(),I=i._serialize(k).toString("base64"),we={encoding:"base64",commitment:this.commitment};if(n){const e=(Array.isArray(n)?n:w.nonProgramIds()).map((e=>e.toBase58()));we.accounts={encoding:"base64",addresses:e}}a&&(we.sigVerify=!0);const Ae=[I,we],Ce=await this._rpcRequest("simulateTransaction",Ae),Be=(0,Ir.vt)(Ce,zi);if("error"in Be){let e;if("data"in Be.error&&(e=Be.error.data.logs,e&&Array.isArray(e))){const r="\n    ",n=r+e.join(r);console.error(Be.error.message,n)}throw new SendTransactionError("failed to simulate transaction: "+Be.error.message,e)}return Be.result}async sendTransaction(e,r,n){if("version"in e){if(r&&Array.isArray(r))throw new Error("Invalid arguments");const n=e.serialize();return await this.sendRawTransaction(n,r)}if(void 0===r||!Array.isArray(r))throw new Error("Invalid arguments");const i=r;if(e.nonceInfo)e.sign(...i);else{let r=this._disableBlockhashCaching;for(;;){const n=await this._blockhashWithExpiryBlockHeight(r);if(e.lastValidBlockHeight=n.lastValidBlockHeight,e.recentBlockhash=n.blockhash,e.sign(...i),!e.signature)throw new Error("!signature");const s=e.signature.toString("base64");if(!this._blockhashInfo.transactionSignatures.includes(s)){this._blockhashInfo.transactionSignatures.push(s);break}r=!0}}const s=e.serialize();return await this.sendRawTransaction(s,n)}async sendRawTransaction(e,r){const n=toBuffer(e).toString("base64");return await this.sendEncodedTransaction(n,r)}async sendEncodedTransaction(e,r){const n={encoding:"base64"},i=r&&r.skipPreflight,s=!0===i?"processed":r&&r.preflightCommitment||this.commitment;r&&null!=r.maxRetries&&(n.maxRetries=r.maxRetries),r&&null!=r.minContextSlot&&(n.minContextSlot=r.minContextSlot),i&&(n.skipPreflight=i),s&&(n.preflightCommitment=s);const a=[e,n],w=await this._rpcRequest("sendTransaction",a),k=(0,Ir.vt)(w,rs);if("error"in k){let e;throw"data"in k.error&&(e=k.error.data.logs),new SendTransactionError("failed to send transaction: "+k.error.message,e)}return k.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval((()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()}),5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),1e3!==e?(this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach((([e,r])=>{this._setSubscription(e,{...r,state:"pending"})}))):this._updateSubscriptions()}_setSubscription(e,r){const n=this._subscriptionsByHash[e]?.state;if(this._subscriptionsByHash[e]=r,n!==r.state){const n=this._subscriptionStateChangeCallbacksByHash[e];n&&n.forEach((e=>{try{e(r.state)}catch{}}))}}_onSubscriptionStateChange(e,r){const n=this._subscriptionHashByClientSubscriptionId[e];if(null==n)return()=>{};const i=this._subscriptionStateChangeCallbacksByHash[n]||=new Set;return i.add(r),()=>{i.delete(r),0===i.size&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(0===Object.keys(this._subscriptionsByHash).length)return void(this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout((()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(e){e instanceof Error&&console.log(`Error when closing socket connection: ${e.message}`)}}),500)));if(null!==this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected)return void this._rpcWebSocket.connect();const e=this._rpcWebSocketGeneration,isCurrentConnectionStillActive=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map((async e=>{const r=this._subscriptionsByHash[e];if(void 0!==r)switch(r.state){case"pending":case"unsubscribed":if(0===r.callbacks.size)return delete this._subscriptionsByHash[e],"unsubscribed"===r.state&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],void await this._updateSubscriptions();await(async()=>{const{args:n,method:i}=r;try{this._setSubscription(e,{...r,state:"subscribing"});const s=await this._rpcWebSocket.call(i,n);this._setSubscription(e,{...r,serverSubscriptionId:s,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[s]=r.callbacks,await this._updateSubscriptions()}catch(s){if(s instanceof Error&&console.error(`${i} error for argument`,n,s.message),!isCurrentConnectionStillActive())return;this._setSubscription(e,{...r,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":0===r.callbacks.size&&await(async()=>{const{serverSubscriptionId:n,unsubscribeMethod:i}=r;if(this._subscriptionsAutoDisposedByRpc.has(n))this._subscriptionsAutoDisposedByRpc.delete(n);else{this._setSubscription(e,{...r,state:"unsubscribing"}),this._setSubscription(e,{...r,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[n])}catch(n){if(n instanceof Error&&console.error(`${i} error:`,n.message),!isCurrentConnectionStillActive())return;return this._setSubscription(e,{...r,state:"subscribed"}),void await this._updateSubscriptions()}}this._setSubscription(e,{...r,state:"unsubscribed"}),await this._updateSubscriptions()})()}})))}_handleServerNotification(e,r){const n=this._subscriptionCallbacksByServerSubscriptionId[e];void 0!==n&&n.forEach((e=>{try{e(...r)}catch(e){console.error(e)}}))}_wsOnAccountNotification(e){const{result:r,subscription:n}=(0,Ir.vt)(e,so);this._handleServerNotification(n,[r.value,r.context])}_makeSubscription(e,r){const n=this._nextClientSubscriptionId++,i=pi([e.method,r]),s=this._subscriptionsByHash[i];return void 0===s?this._subscriptionsByHash[i]={...e,args:r,callbacks:new Set([e.callback]),state:"pending"}:s.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=i,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const r=this._subscriptionsByHash[i];index_browser_esm_assert(void 0!==r,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),r.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,r,n){const i=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64");return this._makeSubscription({callback:r,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},i)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:r,subscription:n}=(0,Ir.vt)(e,co);this._handleServerNotification(n,[{accountId:r.value.pubkey,accountInfo:r.value.account},r.context])}onProgramAccountChange(e,r,n,i){const s=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64",i?{filters:i}:void 0);return this._makeSubscription({callback:r,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},s)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,r,n){const i=this._buildArgs(["object"==typeof e?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:r,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},i)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:r,subscription:n}=(0,Ir.vt)(e,os);this._handleServerNotification(n,[r.value,r.context])}_wsOnSlotNotification(e){const{result:r,subscription:n}=(0,Ir.vt)(e,lo);this._handleServerNotification(n,[r])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:r,subscription:n}=(0,Ir.vt)(e,fo);this._handleServerNotification(n,[r])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,r){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${r}' events could not be found.`)}_buildArgs(e,r,n,i){const s=r||this._commitment;if(s||n||i){let r={};n&&(r.encoding=n),s&&(r.commitment=s),i&&(r=Object.assign(r,i)),e.push(r)}return e}_buildArgsAtLeastConfirmed(e,r,n,i){const s=r||this._commitment;if(s&&!["confirmed","finalized"].includes(s))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,r,n,i)}_wsOnSignatureNotification(e){const{result:r,subscription:n}=(0,Ir.vt)(e,go);"receivedSignature"!==r.value&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,"receivedSignature"===r.value?[{type:"received"},r.context]:[{type:"status",result:r.value},r.context])}onSignature(e,r,n){const i=this._buildArgs([e],n||this._commitment||"finalized"),s=this._makeSubscription({callback:(e,n)=>{if("status"===e.type){r(e.result,n);try{this.removeSignatureListener(s)}catch(e){}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return s}onSignatureWithOptions(e,r,n){const{commitment:i,...s}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},a=this._buildArgs([e],i,void 0,s),w=this._makeSubscription({callback:(e,n)=>{r(e,n);try{this.removeSignatureListener(w)}catch(e){}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},a);return w}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:r,subscription:n}=(0,Ir.vt)(e,po);this._handleServerNotification(n,[r])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Keypair{constructor(e){this._keypair=void 0,this._keypair=e??generateKeypair()}static generate(){return new Keypair(generateKeypair())}static fromSecretKey(e,r){if(64!==e.byteLength)throw new Error("bad secret key size");const n=e.slice(32,64);if(!r||!r.skipValidation){const r=e.slice(0,32),i=an(r);for(let e=0;e<32;e++)if(n[e]!==i[e])throw new Error("provided secretKey is invalid")}return new Keypair({publicKey:n,secretKey:e})}static fromSeed(e){const r=an(e),n=new Uint8Array(64);return n.set(e),n.set(r,32),new Keypair({publicKey:r,secretKey:n})}get publicKey(){return new PublicKey(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const as=Object.freeze({CreateLookupTable:{index:0,layout:kr.struct([kr.u32("instruction"),ci("recentSlot"),kr.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:kr.struct([kr.u32("instruction")])},ExtendLookupTable:{index:2,layout:kr.struct([kr.u32("instruction"),ci(),kr.seq(publicKey(),kr.offset(kr.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:kr.struct([kr.u32("instruction")])},CloseLookupTable:{index:4,layout:kr.struct([kr.u32("instruction")])}});class AddressLookupTableInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=kr.u32("instruction").decode(e.data);let n;for(const[e,i]of Object.entries(as))if(i.index==r){n=e;break}if(!n)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return n}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:r}=decodeData$1(as.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(r)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:r}=decodeData$1(as.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:r.map((e=>new PublicKey(e)))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(AddressLookupTableProgram.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,r){if(e.length<r)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${r}`)}}class AddressLookupTableProgram{constructor(){}static createLookupTable(e){const[r,n]=PublicKey.findProgramAddressSync([e.authority.toBuffer(),(0,Ar.toBufferLE)(BigInt(e.recentSlot),8)],this.programId),i=encodeData(as.CreateLookupTable,{recentSlot:BigInt(e.recentSlot),bumpSeed:n}),s=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}];return[new TransactionInstruction({programId:this.programId,keys:s,data:i}),r]}static freezeLookupTable(e){const r=encodeData(as.FreezeLookupTable),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:n,data:r})}static extendLookupTable(e){const r=encodeData(as.ExtendLookupTable,{addresses:e.addresses.map((e=>e.toBytes()))}),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&n.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}),new TransactionInstruction({programId:this.programId,keys:n,data:r})}static deactivateLookupTable(e){const r=encodeData(as.DeactivateLookupTable),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:n,data:r})}static closeLookupTable(e){const r=encodeData(as.CloseLookupTable),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new TransactionInstruction({programId:this.programId,keys:n,data:r})}}AddressLookupTableProgram.programId=new PublicKey("AddressLookupTab1e1111111111111111111111111");class ComputeBudgetInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=kr.u8("instruction").decode(e.data);let n;for(const[e,i]of Object.entries(cs))if(i.index==r){n=e;break}if(!n)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return n}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:r,additionalFee:n}=decodeData$1(cs.RequestUnits,e.data);return{units:r,additionalFee:n}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:r}=decodeData$1(cs.RequestHeapFrame,e.data);return{bytes:r}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:r}=decodeData$1(cs.SetComputeUnitLimit,e.data);return{units:r}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:r}=decodeData$1(cs.SetComputeUnitPrice,e.data);return{microLamports:r}}static checkProgramId(e){if(!e.equals(ComputeBudgetProgram.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const cs=Object.freeze({RequestUnits:{index:0,layout:kr.struct([kr.u8("instruction"),kr.u32("units"),kr.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:kr.struct([kr.u8("instruction"),kr.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:kr.struct([kr.u8("instruction"),kr.u32("units")])},SetComputeUnitPrice:{index:3,layout:kr.struct([kr.u8("instruction"),ci("microLamports")])}});class ComputeBudgetProgram{constructor(){}static requestUnits(e){const r=encodeData(cs.RequestUnits,e);return new TransactionInstruction({keys:[],programId:this.programId,data:r})}static requestHeapFrame(e){const r=encodeData(cs.RequestHeapFrame,e);return new TransactionInstruction({keys:[],programId:this.programId,data:r})}static setComputeUnitLimit(e){const r=encodeData(cs.SetComputeUnitLimit,e);return new TransactionInstruction({keys:[],programId:this.programId,data:r})}static setComputeUnitPrice(e){const r=encodeData(cs.SetComputeUnitPrice,{microLamports:BigInt(e.microLamports)});return new TransactionInstruction({keys:[],programId:this.programId,data:r})}}ComputeBudgetProgram.programId=new PublicKey("ComputeBudget111111111111111111111111111111");const us=kr.struct([kr.u8("numSignatures"),kr.u8("padding"),kr.u16("signatureOffset"),kr.u16("signatureInstructionIndex"),kr.u16("publicKeyOffset"),kr.u16("publicKeyInstructionIndex"),kr.u16("messageDataOffset"),kr.u16("messageDataSize"),kr.u16("messageInstructionIndex")]);class Ed25519Program{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:r,message:n,signature:i,instructionIndex:a}=e;index_browser_esm_assert(32===r.length,`Public Key must be 32 bytes but received ${r.length} bytes`),index_browser_esm_assert(64===i.length,`Signature must be 64 bytes but received ${i.length} bytes`);const w=us.span,k=w+r.length,I=k+i.length,we=s.Buffer.alloc(I+n.length),Ae=null==a?65535:a;return us.encode({numSignatures:1,padding:0,signatureOffset:k,signatureInstructionIndex:Ae,publicKeyOffset:w,publicKeyInstructionIndex:Ae,messageDataOffset:I,messageDataSize:n.length,messageInstructionIndex:Ae},we),we.fill(r,w),we.fill(i,k),we.fill(n,I),new TransactionInstruction({keys:[],programId:Ed25519Program.programId,data:we})}static createInstructionWithPrivateKey(e){const{privateKey:r,message:n,instructionIndex:i}=e;index_browser_esm_assert(64===r.length,`Private key must be 64 bytes but received ${r.length} bytes`);try{const e=Keypair.fromSecretKey(r),s=e.publicKey.toBytes(),a=sign(n,e.secretKey);return this.createInstructionWithPublicKey({publicKey:s,message:n,signature:a,instructionIndex:i})}catch(e){throw new Error(`Error creating instruction; ${e}`)}}}Ed25519Program.programId=new PublicKey("Ed25519SigVerify111111111111111111111111111");Qr.utils.isValidPrivateKey;const ds=Qr.getPublicKey,ls=kr.struct([kr.u8("numSignatures"),kr.u16("signatureOffset"),kr.u8("signatureInstructionIndex"),kr.u16("ethAddressOffset"),kr.u8("ethAddressInstructionIndex"),kr.u16("messageDataOffset"),kr.u16("messageDataSize"),kr.u8("messageInstructionIndex"),kr.blob(20,"ethAddress"),kr.blob(64,"signature"),kr.u8("recoveryId")]);class Secp256k1Program{constructor(){}static publicKeyToEthAddress(e){index_browser_esm_assert(64===e.length,`Public key must be 64 bytes but received ${e.length} bytes`);try{return s.Buffer.from(Fr(toBuffer(e))).slice(-20)}catch(e){throw new Error(`Error constructing Ethereum address: ${e}`)}}static createInstructionWithPublicKey(e){const{publicKey:r,message:n,signature:i,recoveryId:s,instructionIndex:a}=e;return Secp256k1Program.createInstructionWithEthAddress({ethAddress:Secp256k1Program.publicKeyToEthAddress(r),message:n,signature:i,recoveryId:s,instructionIndex:a})}static createInstructionWithEthAddress(e){const{ethAddress:r,message:n,signature:i,recoveryId:a,instructionIndex:w=0}=e;let k;k="string"==typeof r?r.startsWith("0x")?s.Buffer.from(r.substr(2),"hex"):s.Buffer.from(r,"hex"):r,index_browser_esm_assert(20===k.length,`Address must be 20 bytes but received ${k.length} bytes`);const I=12+k.length,we=I+i.length+1,Ae=s.Buffer.alloc(ls.span+n.length);return ls.encode({numSignatures:1,signatureOffset:I,signatureInstructionIndex:w,ethAddressOffset:12,ethAddressInstructionIndex:w,messageDataOffset:we,messageDataSize:n.length,messageInstructionIndex:w,signature:toBuffer(i),ethAddress:toBuffer(k),recoveryId:a},Ae),Ae.fill(toBuffer(n),ls.span),new TransactionInstruction({keys:[],programId:Secp256k1Program.programId,data:Ae})}static createInstructionWithPrivateKey(e){const{privateKey:r,message:n,instructionIndex:i}=e;index_browser_esm_assert(32===r.length,`Private key must be 32 bytes but received ${r.length} bytes`);try{const e=toBuffer(r),a=ds(e,!1).slice(1),w=s.Buffer.from(Fr(toBuffer(n))),[k,I]=((e,r)=>{const n=Qr.sign(e,r);return[n.toCompactRawBytes(),n.recovery]})(w,e);return this.createInstructionWithPublicKey({publicKey:a,message:n,signature:k,recoveryId:I,instructionIndex:i})}catch(e){throw new Error(`Error creating instruction; ${e}`)}}}var hs;Secp256k1Program.programId=new PublicKey("KeccakSecp256k11111111111111111111111111111");const fs=new PublicKey("StakeConfig11111111111111111111111111111111");class Authorized{constructor(e,r){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=r}}class Lockup{constructor(e,r,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=r,this.custodian=n}}hs=Lockup,Lockup.default=new hs(0,0,PublicKey.default);class StakeInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=kr.u32("instruction").decode(e.data);let n;for(const[e,i]of Object.entries(gs))if(i.index==r){n=e;break}if(!n)throw new Error("Instruction type incorrect; not a StakeInstruction");return n}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:r,lockup:n}=decodeData$1(gs.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new Authorized(new PublicKey(r.staker),new PublicKey(r.withdrawer)),lockup:new Lockup(n.unixTimestamp,n.epoch,new PublicKey(n.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),decodeData$1(gs.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:r,stakeAuthorizationType:n}=decodeData$1(gs.Authorize,e.data),i={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new PublicKey(r),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(i.custodianPubkey=e.keys[3].pubkey),i}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:r,stakeAuthorizationType:n,authoritySeed:i,authorityOwner:s}=decodeData$1(gs.AuthorizeWithSeed,e.data),a={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:i,authorityOwner:new PublicKey(s),newAuthorizedPubkey:new PublicKey(r),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(a.custodianPubkey=e.keys[3].pubkey),a}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:r}=decodeData$1(gs.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:r}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),decodeData$1(gs.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:r}=decodeData$1(gs.Withdraw,e.data),n={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:r};return e.keys.length>5&&(n.custodianPubkey=e.keys[5].pubkey),n}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),decodeData$1(gs.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(StakeProgram.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,r){if(e.length<r)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${r}`)}}const gs=Object.freeze({Initialize:{index:0,layout:kr.struct([kr.u32("instruction"),((e="authorized")=>kr.struct([publicKey("staker"),publicKey("withdrawer")],e))(),((e="lockup")=>kr.struct([kr.ns64("unixTimestamp"),kr.ns64("epoch"),publicKey("custodian")],e))()])},Authorize:{index:1,layout:kr.struct([kr.u32("instruction"),publicKey("newAuthorized"),kr.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:kr.struct([kr.u32("instruction")])},Split:{index:3,layout:kr.struct([kr.u32("instruction"),kr.ns64("lamports")])},Withdraw:{index:4,layout:kr.struct([kr.u32("instruction"),kr.ns64("lamports")])},Deactivate:{index:5,layout:kr.struct([kr.u32("instruction")])},Merge:{index:7,layout:kr.struct([kr.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:kr.struct([kr.u32("instruction"),publicKey("newAuthorized"),kr.u32("stakeAuthorizationType"),rustString("authoritySeed"),publicKey("authorityOwner")])}}),ps=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class StakeProgram{constructor(){}static initialize(e){const{stakePubkey:r,authorized:n,lockup:i}=e,s=i||Lockup.default,a=encodeData(gs.Initialize,{authorized:{staker:toBuffer(n.staker.toBuffer()),withdrawer:toBuffer(n.withdrawer.toBuffer())},lockup:{unixTimestamp:s.unixTimestamp,epoch:s.epoch,custodian:toBuffer(s.custodian.toBuffer())}}),w={keys:[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:ei,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new TransactionInstruction(w)}static createAccountWithSeed(e){const r=new Transaction;r.add(SystemProgram.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:i,lockup:s}=e;return r.add(this.initialize({stakePubkey:n,authorized:i,lockup:s}))}static createAccount(e){const r=new Transaction;r.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:i,lockup:s}=e;return r.add(this.initialize({stakePubkey:n,authorized:i,lockup:s}))}static delegate(e){const{stakePubkey:r,authorizedPubkey:n,votePubkey:i}=e,s=encodeData(gs.Delegate);return(new Transaction).add({keys:[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:ii,isSigner:!1,isWritable:!1},{pubkey:fs,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static authorize(e){const{stakePubkey:r,authorizedPubkey:n,newAuthorizedPubkey:i,stakeAuthorizationType:s,custodianPubkey:a}=e,w=encodeData(gs.Authorize,{newAuthorized:toBuffer(i.toBuffer()),stakeAuthorizationType:s.index}),k=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Wn,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return a&&k.push({pubkey:a,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:k,programId:this.programId,data:w})}static authorizeWithSeed(e){const{stakePubkey:r,authorityBase:n,authoritySeed:i,authorityOwner:s,newAuthorizedPubkey:a,stakeAuthorizationType:w,custodianPubkey:k}=e,I=encodeData(gs.AuthorizeWithSeed,{newAuthorized:toBuffer(a.toBuffer()),stakeAuthorizationType:w.index,authoritySeed:i,authorityOwner:toBuffer(s.toBuffer())}),we=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:Wn,isSigner:!1,isWritable:!1}];return k&&we.push({pubkey:k,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:we,programId:this.programId,data:I})}static splitInstruction(e){const{stakePubkey:r,authorizedPubkey:n,splitStakePubkey:i,lamports:s}=e,a=encodeData(gs.Split,{lamports:s});return new TransactionInstruction({keys:[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e,r){const n=new Transaction;return n.add(SystemProgram.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:r,space:this.space,programId:this.programId})),n.add(this.splitInstruction(e))}static splitWithSeed(e,r){const{stakePubkey:n,authorizedPubkey:i,splitStakePubkey:s,basePubkey:a,seed:w,lamports:k}=e,I=new Transaction;return I.add(SystemProgram.allocate({accountPubkey:s,basePubkey:a,seed:w,space:this.space,programId:this.programId})),r&&r>0&&I.add(SystemProgram.transfer({fromPubkey:e.authorizedPubkey,toPubkey:s,lamports:r})),I.add(this.splitInstruction({stakePubkey:n,authorizedPubkey:i,splitStakePubkey:s,lamports:k}))}static merge(e){const{stakePubkey:r,sourceStakePubKey:n,authorizedPubkey:i}=e,s=encodeData(gs.Merge);return(new Transaction).add({keys:[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:ii,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static withdraw(e){const{stakePubkey:r,authorizedPubkey:n,toPubkey:i,lamports:s,custodianPubkey:a}=e,w=encodeData(gs.Withdraw,{lamports:s}),k=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:ii,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return a&&k.push({pubkey:a,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:k,programId:this.programId,data:w})}static deactivate(e){const{stakePubkey:r,authorizedPubkey:n}=e,i=encodeData(gs.Deactivate);return(new Transaction).add({keys:[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}}StakeProgram.programId=new PublicKey("Stake11111111111111111111111111111111111111"),StakeProgram.space=200;class VoteInit{constructor(e,r,n,i){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=r,this.authorizedWithdrawer=n,this.commission=i}}class VoteInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=kr.u32("instruction").decode(e.data);let n;for(const[e,i]of Object.entries(ms))if(i.index==r){n=e;break}if(!n)throw new Error("Instruction type incorrect; not a VoteInstruction");return n}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:r}=decodeData$1(ms.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new VoteInit(new PublicKey(r.nodePubkey),new PublicKey(r.authorizedVoter),new PublicKey(r.authorizedWithdrawer),r.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:r,voteAuthorizationType:n}=decodeData$1(ms.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new PublicKey(r),voteAuthorizationType:{index:n}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorized:i,voteAuthorizationType:s}}=decodeData$1(ms.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new PublicKey(r),currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:new PublicKey(i),voteAuthorizationType:{index:s},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:r}=decodeData$1(ms.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:r,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(VoteProgram.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,r){if(e.length<r)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${r}`)}}const ms=Object.freeze({InitializeAccount:{index:0,layout:kr.struct([kr.u32("instruction"),((e="voteInit")=>kr.struct([publicKey("nodePubkey"),publicKey("authorizedVoter"),publicKey("authorizedWithdrawer"),kr.u8("commission")],e))()])},Authorize:{index:1,layout:kr.struct([kr.u32("instruction"),publicKey("newAuthorized"),kr.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:kr.struct([kr.u32("instruction"),kr.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:kr.struct([kr.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:kr.struct([kr.u32("instruction"),((e="voteAuthorizeWithSeedArgs")=>kr.struct([kr.u32("voteAuthorizationType"),publicKey("currentAuthorityDerivedKeyOwnerPubkey"),rustString("currentAuthorityDerivedKeySeed"),publicKey("newAuthorized")],e))()])}}),ys=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class VoteProgram{constructor(){}static initializeAccount(e){const{votePubkey:r,nodePubkey:n,voteInit:i}=e,s=encodeData(ms.InitializeAccount,{voteInit:{nodePubkey:toBuffer(i.nodePubkey.toBuffer()),authorizedVoter:toBuffer(i.authorizedVoter.toBuffer()),authorizedWithdrawer:toBuffer(i.authorizedWithdrawer.toBuffer()),commission:i.commission}}),a={keys:[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:ei,isSigner:!1,isWritable:!1},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s};return new TransactionInstruction(a)}static createAccount(e){const r=new Transaction;return r.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),r.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:r,authorizedPubkey:n,newAuthorizedPubkey:i,voteAuthorizationType:s}=e,a=encodeData(ms.Authorize,{newAuthorized:toBuffer(i.toBuffer()),voteAuthorizationType:s.index}),w=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:w,programId:this.programId,data:a})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:r,currentAuthorityDerivedKeyOwnerPubkey:n,currentAuthorityDerivedKeySeed:i,newAuthorizedPubkey:s,voteAuthorizationType:a,votePubkey:w}=e,k=encodeData(ms.AuthorizeWithSeed,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:toBuffer(n.toBuffer()),currentAuthorityDerivedKeySeed:i,newAuthorized:toBuffer(s.toBuffer()),voteAuthorizationType:a.index}}),I=[{pubkey:w,isSigner:!1,isWritable:!0},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:I,programId:this.programId,data:k})}static withdraw(e){const{votePubkey:r,authorizedWithdrawerPubkey:n,lamports:i,toPubkey:s}=e,a=encodeData(ms.Withdraw,{lamports:i}),w=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:w,programId:this.programId,data:a})}static safeWithdraw(e,r,n){if(e.lamports>r-n)throw new Error("Withdraw will leave vote account with insufficient funds.");return VoteProgram.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:r,authorizedWithdrawerPubkey:n,nodePubkey:i}=e,s=encodeData(ms.UpdateValidatorIdentity),a=[{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:a,programId:this.programId,data:s})}}VoteProgram.programId=new PublicKey("Vote111111111111111111111111111111111111111"),VoteProgram.space=3762;const bs=new PublicKey("Va1idator1nfo111111111111111111111111111111"),_s=(0,Ir.NW)({name:(0,Ir.Yj)(),website:(0,Ir.lq)((0,Ir.Yj)()),details:(0,Ir.lq)((0,Ir.Yj)()),keybaseUsername:(0,Ir.lq)((0,Ir.Yj)())});class ValidatorInfo{constructor(e,r){this.key=void 0,this.info=void 0,this.key=e,this.info=r}static fromConfigData(e){let r=[...e];if(2!==decodeLength(r))return null;const n=[];for(let e=0;e<2;e++){const e=new PublicKey(guardedSplice(r,0,gn)),i=1===guardedShift(r);n.push({publicKey:e,isSigner:i})}if(n[0].publicKey.equals(bs)&&n[1].isSigner){const e=rustString().decode(s.Buffer.from(r)),i=JSON.parse(e);return(0,Ir.vA)(i,_s),new ValidatorInfo(n[1].publicKey,i)}return null}}const ws=new PublicKey("Vote111111111111111111111111111111111111111"),Ss=kr.struct([publicKey("nodePubkey"),publicKey("authorizedWithdrawer"),kr.u8("commission"),kr.nu64(),kr.seq(kr.struct([kr.nu64("slot"),kr.u32("confirmationCount")]),kr.offset(kr.u32(),-8),"votes"),kr.u8("rootSlotValid"),kr.nu64("rootSlot"),kr.nu64(),kr.seq(kr.struct([kr.nu64("epoch"),publicKey("authorizedVoter")]),kr.offset(kr.u32(),-8),"authorizedVoters"),kr.struct([kr.seq(kr.struct([publicKey("authorizedPubkey"),kr.nu64("epochOfLastAuthorizedSwitch"),kr.nu64("targetEpoch")]),32,"buf"),kr.nu64("idx"),kr.u8("isEmpty")],"priorVoters"),kr.nu64(),kr.seq(kr.struct([kr.nu64("epoch"),kr.nu64("credits"),kr.nu64("prevCredits")]),kr.offset(kr.u32(),-8),"epochCredits"),kr.struct([kr.nu64("slot"),kr.nu64("timestamp")],"lastTimestamp")]);class VoteAccount{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const r=Ss.decode(toBuffer(e),4);let n=r.rootSlot;return r.rootSlotValid||(n=null),new VoteAccount({nodePubkey:new PublicKey(r.nodePubkey),authorizedWithdrawer:new PublicKey(r.authorizedWithdrawer),commission:r.commission,votes:r.votes,rootSlot:n,authorizedVoters:r.authorizedVoters.map(parseAuthorizedVoter),priorVoters:getPriorVoters(r.priorVoters),epochCredits:r.epochCredits,lastTimestamp:r.lastTimestamp})}}function parseAuthorizedVoter({authorizedVoter:e,epoch:r}){return{epoch:r,authorizedVoter:new PublicKey(e)}}function parsePriorVoters({authorizedPubkey:e,epochOfLastAuthorizedSwitch:r,targetEpoch:n}){return{authorizedPubkey:new PublicKey(e),epochOfLastAuthorizedSwitch:r,targetEpoch:n}}function getPriorVoters({buf:e,idx:r,isEmpty:n}){return n?[]:[...e.slice(r+1).map(parsePriorVoters),...e.slice(0,r).map(parsePriorVoters)]}const Es={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function clusterApiUrl(e,r){const n=!1===r?"http":"https";if(!e)return Es[n].devnet;const i=Es[n][e];if(!i)throw new Error(`Unknown ${n} cluster: ${e}`);return i}async function sendAndConfirmRawTransaction(e,r,n,i){let s,a;n&&Object.prototype.hasOwnProperty.call(n,"lastValidBlockHeight")||n&&Object.prototype.hasOwnProperty.call(n,"nonceValue")?(s=n,a=i):a=n;const w=a&&{skipPreflight:a.skipPreflight,preflightCommitment:a.preflightCommitment||a.commitment,minContextSlot:a.minContextSlot},k=await e.sendRawTransaction(r,w),I=a&&a.commitment,we=s?e.confirmTransaction(s,I):e.confirmTransaction(k,I),Ae=(await we).value;if(Ae.err)throw new Error(`Raw transaction ${k} failed (${JSON.stringify(Ae)})`);return k}const ks=1e9},69026:(e,r,n)=>{var i=n(901048).Buffer;const s=n(828985),a=n(712628);class CommonClient extends s.EventEmitter{address;rpc_id;queue;options;autoconnect;ready;reconnect;reconnect_timer_id;reconnect_interval;max_reconnects;rest_options;current_reconnects;generate_request_id;socket;webSocketFactory;dataPack;constructor(e,r="ws://localhost:8080",{autoconnect:n=!0,reconnect:i=!0,reconnect_interval:s=1e3,max_reconnects:w=5,...k}={},I,we){super(),this.webSocketFactory=e,this.queue={},this.rpc_id=0,this.address=r,this.autoconnect=n,this.ready=!1,this.reconnect=i,this.reconnect_timer_id=void 0,this.reconnect_interval=s,this.max_reconnects=w,this.rest_options=k,this.current_reconnects=0,this.generate_request_id=I||(()=>++this.rpc_id),this.dataPack=we||new a.DefaultDataPack,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(e,r,n,i){return i||"object"!=typeof n||(i=n,n=null),new Promise(((s,a)=>{if(!this.ready)return a(new Error("socket not ready"));const w=this.generate_request_id(e,r),k={jsonrpc:"2.0",method:e,params:r||void 0,id:w};this.socket.send(this.dataPack.encode(k),i,(e=>{if(e)return a(e);this.queue[w]={promise:[s,a]},n&&(this.queue[w].timeout=setTimeout((()=>{delete this.queue[w],a(new Error("reply timeout"))}),n))}))}))}async login(e){const r=await this.call("rpc.login",e);if(!r)throw new Error("authentication failed");return r}async listMethods(){return await this.call("__listMethods")}notify(e,r){return new Promise(((n,i)=>{if(!this.ready)return i(new Error("socket not ready"));const s={jsonrpc:"2.0",method:e,params:r};this.socket.send(this.dataPack.encode(s),(e=>{if(e)return i(e);n()}))}))}async subscribe(e){"string"==typeof e&&(e=[e]);const r=await this.call("rpc.on",e);if("string"==typeof e&&"ok"!==r[e])throw new Error("Failed subscribing to an event '"+e+"' with: "+r[e]);return r}async unsubscribe(e){"string"==typeof e&&(e=[e]);const r=await this.call("rpc.off",e);if("string"==typeof e&&"ok"!==r[e])throw new Error("Failed unsubscribing from an event with: "+r);return r}close(e,r){this.socket.close(e||1e3,r)}setAutoReconnect(e){this.reconnect=e}setReconnectInterval(e){this.reconnect_interval=e}setMaxReconnects(e){this.max_reconnects=e}_connect(e,r){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(e,r),this.socket.addEventListener("open",(()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0})),this.socket.addEventListener("message",(({data:e})=>{e instanceof ArrayBuffer&&(e=i.from(e).toString());try{e=this.dataPack.decode(e)}catch(e){return}if(e.notification&&this.listeners(e.notification).length){if(!Object.keys(e.params).length)return this.emit(e.notification);const r=[e.notification];if(e.params.constructor===Object)r.push(e.params);else for(let n=0;n<e.params.length;n++)r.push(e.params[n]);return Promise.resolve().then((()=>{this.emit.apply(this,r)}))}if(!this.queue[e.id])return e.method?Promise.resolve().then((()=>{this.emit(e.method,e?.params)})):void 0;"error"in e=="result"in e&&this.queue[e.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[e.id].timeout&&clearTimeout(this.queue[e.id].timeout),e.error?this.queue[e.id].promise[1](e.error):this.queue[e.id].promise[0](e.result),delete this.queue[e.id]})),this.socket.addEventListener("error",(e=>this.emit("error",e))),this.socket.addEventListener("close",(({code:n,reason:i})=>{this.ready&&setTimeout((()=>this.emit("close",n,i)),0),this.ready=!1,this.socket=void 0,1e3!==n&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||0===this.max_reconnects)&&(this.reconnect_timer_id=setTimeout((()=>this._connect(e,r)),this.reconnect_interval)))}))}}r.A=CommonClient},131392:(e,r,n)=>{const i=n(828985);class WebSocketBrowserImpl extends i.EventEmitter{socket;constructor(e,r,n){super(),this.socket=new window.WebSocket(e,n),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=e=>this.emit("message",e.data),this.socket.onerror=e=>this.emit("error",e),this.socket.onclose=e=>{this.emit("close",e.code,e.reason)}}send(e,r,n){const i=n||r;try{this.socket.send(e),i()}catch(e){i(e)}}close(e,r){this.socket.close(e,r)}addEventListener(e,r,n){this.socket.addEventListener(e,r,n)}}r.A=function default_1(e,r){return new WebSocketBrowserImpl(e,r)}},712628:(e,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.createError=r.DefaultDataPack=void 0;const n=new Map([[-32e3,"Event not provided"],[-32600,"Invalid Request"],[-32601,"Method not found"],[-32602,"Invalid params"],[-32603,"Internal error"],[-32604,"Params not found"],[-32605,"Method forbidden"],[-32606,"Event forbidden"],[-32700,"Parse error"]]);r.DefaultDataPack=class DefaultDataPack{encode(e){return JSON.stringify(e)}decode(e){return JSON.parse(e)}},r.createError=function createError(e,r){const i={code:e,message:n.get(e)||"Internal Server Error"};return r&&(i.data=r),i}},457477:(e,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.encodeDecode=void 0;r.encodeDecode=e=>({decode:e.decode.bind(e),encode:e.encode.bind(e)})},86103:(e,r,n)=>{var i=n(901048).Buffer;Object.defineProperty(r,"__esModule",{value:!0}),r.u256be=r.u256=r.u192be=r.u192=r.u128be=r.u128=r.u64be=r.u64=r.bigIntBE=r.bigInt=void 0;const s=n(878918),a=n(856115),w=n(457477);r.bigInt=e=>r=>{const n=(0,s.blob)(e,r),{encode:k,decode:I}=(0,w.encodeDecode)(n),we=n;return we.decode=(e,r)=>{const n=I(e,r);return(0,a.toBigIntLE)(i.from(n))},we.encode=(r,n,i)=>{const s=(0,a.toBufferLE)(r,e);return k(s,n,i)},we};r.bigIntBE=e=>r=>{const n=(0,s.blob)(e,r),{encode:k,decode:I}=(0,w.encodeDecode)(n),we=n;return we.decode=(e,r)=>{const n=I(e,r);return(0,a.toBigIntBE)(i.from(n))},we.encode=(r,n,i)=>{const s=(0,a.toBufferBE)(r,e);return k(s,n,i)},we},r.u64=(0,r.bigInt)(8),r.u64be=(0,r.bigIntBE)(8),r.u128=(0,r.bigInt)(16),r.u128be=(0,r.bigIntBE)(16),r.u192=(0,r.bigInt)(24),r.u192be=(0,r.bigIntBE)(24),r.u256=(0,r.bigInt)(32),r.u256be=(0,r.bigIntBE)(32)},409609:function(e,r,n){var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0}),r.decimal=r.WAD=void 0;const s=i(n(755553)),a=n(457477),w=n(86103);r.WAD=new s.default("1e+18");r.decimal=e=>{const n=(0,w.u128)(e),{encode:i,decode:k}=(0,a.encodeDecode)(n),I=n;return I.decode=(e,n)=>{const i=k(e,n).toString();return new s.default(i).div(r.WAD)},I.encode=(e,n,s)=>{const a=BigInt(e.times(r.WAD).integerValue().toString());return i(a,n,s)},I}},432510:function(e,r,n){var i=this&&this.__createBinding||(Object.create?function(e,r,n,i){void 0===i&&(i=n),Object.defineProperty(e,i,{enumerable:!0,get:function(){return r[n]}})}:function(e,r,n,i){void 0===i&&(i=n),e[i]=r[n]}),s=this&&this.__exportStar||function(e,r){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(r,n)||i(r,e,n)};Object.defineProperty(r,"__esModule",{value:!0}),s(n(457477),r),s(n(86103),r),s(n(409609),r),s(n(760507),r),s(n(922547),r)},760507:(e,r,n)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.bool=void 0;const i=n(878918),s=n(457477);r.bool=e=>{const r=(0,i.u8)(e),{encode:n,decode:a}=(0,s.encodeDecode)(r),w=r;return w.decode=(e,r)=>!!a(e,r),w.encode=(e,r,i)=>{const s=Number(e);return n(s,r,i)},w}},922547:(e,r,n)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.publicKey=void 0;const i=n(878918),s=n(629862),a=n(457477);r.publicKey=e=>{const r=(0,i.blob)(32,e),{encode:n,decode:w}=(0,a.encodeDecode)(r),k=r;return k.decode=(e,r)=>{const n=w(e,r);return new s.PublicKey(n)},k.encode=(e,r,i)=>{const s=e.toBuffer();return n(s,r,i)},k}},268117:(e,r,n)=>{var i=n(132595);function assertByteArrayHasEnoughBytesForCodec(e,r,n,s=0){const a=n.length-s;if(a<r)throw new i.SolanaError(i.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,{bytesLength:a,codecDescription:e,expected:r})}function assertByteArrayOffsetIsNotOutOfRange(e,r,n){if(r<0||r>n)throw new i.SolanaError(i.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,{bytesLength:n,codecDescription:e,offset:r})}var padBytes=(e,r)=>{if(e.length>=r)return e;const n=new Uint8Array(r).fill(0);return n.set(e),n},fixBytes=(e,r)=>padBytes(e.length<=r?e:e.slice(0,r),r);function getEncodedSize(e,r){return"fixedSize"in r?r.fixedSize:r.getSizeFromValue(e)}function createEncoder(e){return Object.freeze({...e,encode:r=>{const n=new Uint8Array(getEncodedSize(r,e));return e.write(r,n,0),n}})}function createDecoder(e){return Object.freeze({...e,decode:(r,n=0)=>e.read(r,n)[0]})}function createCodec(e){return Object.freeze({...e,decode:(r,n=0)=>e.read(r,n)[0],encode:r=>{const n=new Uint8Array(getEncodedSize(r,e));return e.write(r,n,0),n}})}function isFixedSize(e){return"fixedSize"in e&&"number"==typeof e.fixedSize}function assertIsFixedSize(e){if(!isFixedSize(e))throw new i.SolanaError(i.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH)}function isVariableSize(e){return!isFixedSize(e)}function combineCodec(e,r){if(isFixedSize(e)!==isFixedSize(r))throw new i.SolanaError(i.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);if(isFixedSize(e)&&isFixedSize(r)&&e.fixedSize!==r.fixedSize)throw new i.SolanaError(i.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,{decoderFixedSize:r.fixedSize,encoderFixedSize:e.fixedSize});if(!isFixedSize(e)&&!isFixedSize(r)&&e.maxSize!==r.maxSize)throw new i.SolanaError(i.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,{decoderMaxSize:r.maxSize,encoderMaxSize:e.maxSize});return{...r,...e,decode:r.decode,encode:e.encode,read:r.read,write:e.write}}function fixEncoder(e,r){return createEncoder({fixedSize:r,write:(n,i,s)=>{const a=e.encode(n),w=a.length>r?a.slice(0,r):a;return i.set(w,s),s+r}})}function fixDecoder(e,r){return createDecoder({fixedSize:r,read:(n,i)=>{assertByteArrayHasEnoughBytesForCodec("fixCodec",r,n,i),(i>0||n.length>r)&&(n=n.slice(i,i+r)),isFixedSize(e)&&(n=fixBytes(n,e.fixedSize));const[s]=e.read(n,0);return[s,i+r]}})}function mapEncoder(e,r){return createEncoder({...isVariableSize(e)?{...e,getSizeFromValue:n=>e.getSizeFromValue(r(n))}:e,write:(n,i,s)=>e.write(r(n),i,s)})}function mapDecoder(e,r){return createDecoder({...e,read:(n,i)=>{const[s,a]=e.read(n,i);return[r(s,n,i),a]}})}function offsetEncoder(e,r){return createEncoder({...e,write:(n,i,s)=>{const wrapBytes=e=>modulo(e,i.length),a=r.preOffset?r.preOffset({bytes:i,preOffset:s,wrapBytes}):s;assertByteArrayOffsetIsNotOutOfRange("offsetEncoder",a,i.length);const w=e.write(n,i,a),k=r.postOffset?r.postOffset({bytes:i,newPreOffset:a,postOffset:w,preOffset:s,wrapBytes}):w;return assertByteArrayOffsetIsNotOutOfRange("offsetEncoder",k,i.length),k}})}function offsetDecoder(e,r){return createDecoder({...e,read:(n,i)=>{const wrapBytes=e=>modulo(e,n.length),s=r.preOffset?r.preOffset({bytes:n,preOffset:i,wrapBytes}):i;assertByteArrayOffsetIsNotOutOfRange("offsetDecoder",s,n.length);const[a,w]=e.read(n,s),k=r.postOffset?r.postOffset({bytes:n,newPreOffset:s,postOffset:w,preOffset:i,wrapBytes}):w;return assertByteArrayOffsetIsNotOutOfRange("offsetDecoder",k,n.length),[a,k]}})}function modulo(e,r){return 0===r?0:(e%r+r)%r}function resizeEncoder(e,r){if(isFixedSize(e)){const n=r(e.fixedSize);if(n<0)throw new i.SolanaError(i.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,{bytesLength:n,codecDescription:"resizeEncoder"});return createEncoder({...e,fixedSize:n})}return createEncoder({...e,getSizeFromValue:n=>{const s=r(e.getSizeFromValue(n));if(s<0)throw new i.SolanaError(i.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,{bytesLength:s,codecDescription:"resizeEncoder"});return s}})}function resizeDecoder(e,r){if(isFixedSize(e)){const n=r(e.fixedSize);if(n<0)throw new i.SolanaError(i.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,{bytesLength:n,codecDescription:"resizeDecoder"});return createDecoder({...e,fixedSize:n})}return e}function padLeftEncoder(e,r){return offsetEncoder(resizeEncoder(e,(e=>e+r)),{preOffset:({preOffset:e})=>e+r})}function padRightEncoder(e,r){return offsetEncoder(resizeEncoder(e,(e=>e+r)),{postOffset:({postOffset:e})=>e+r})}function padLeftDecoder(e,r){return offsetDecoder(resizeDecoder(e,(e=>e+r)),{preOffset:({preOffset:e})=>e+r})}function padRightDecoder(e,r){return offsetDecoder(resizeDecoder(e,(e=>e+r)),{postOffset:({postOffset:e})=>e+r})}function reverseEncoder(e){return assertIsFixedSize(e),createEncoder({...e,write:(r,n,i)=>{const s=e.write(r,n,i),a=n.slice(i,i+e.fixedSize).reverse();return n.set(a,i),s}})}function reverseDecoder(e){return assertIsFixedSize(e),createDecoder({...e,read:(r,n)=>{const i=n+e.fixedSize;if(0===n&&r.length===i)return e.read(r.reverse(),n);const s=r.slice();return s.set(r.slice(n,i).reverse(),n),e.read(s,n)}})}r.assertByteArrayHasEnoughBytesForCodec=assertByteArrayHasEnoughBytesForCodec,r.assertByteArrayIsNotEmptyForCodec=function assertByteArrayIsNotEmptyForCodec(e,r,n=0){if(r.length-n<=0)throw new i.SolanaError(i.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,{codecDescription:e})},r.assertByteArrayOffsetIsNotOutOfRange=assertByteArrayOffsetIsNotOutOfRange,r.assertIsFixedSize=assertIsFixedSize,r.assertIsVariableSize=function assertIsVariableSize(e){if(!isVariableSize(e))throw new i.SolanaError(i.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH)},r.combineCodec=combineCodec,r.createCodec=createCodec,r.createDecoder=createDecoder,r.createEncoder=createEncoder,r.fixBytes=fixBytes,r.fixCodec=function fixCodec(e,r){return combineCodec(fixEncoder(e,r),fixDecoder(e,r))},r.fixDecoder=fixDecoder,r.fixEncoder=fixEncoder,r.getEncodedSize=getEncodedSize,r.isFixedSize=isFixedSize,r.isVariableSize=isVariableSize,r.mapCodec=function mapCodec(e,r,n){return createCodec({...mapEncoder(e,r),read:n?mapDecoder(e,n).read:e.read})},r.mapDecoder=mapDecoder,r.mapEncoder=mapEncoder,r.mergeBytes=e=>{const r=e.filter((e=>e.length));if(0===r.length)return e.length?e[0]:new Uint8Array;if(1===r.length)return r[0];const n=r.reduce(((e,r)=>e+r.length),0),i=new Uint8Array(n);let s=0;return r.forEach((e=>{i.set(e,s),s+=e.length})),i},r.offsetCodec=function offsetCodec(e,r){return combineCodec(offsetEncoder(e,r),offsetDecoder(e,r))},r.offsetDecoder=offsetDecoder,r.offsetEncoder=offsetEncoder,r.padBytes=padBytes,r.padLeftCodec=function padLeftCodec(e,r){return combineCodec(padLeftEncoder(e,r),padLeftDecoder(e,r))},r.padLeftDecoder=padLeftDecoder,r.padLeftEncoder=padLeftEncoder,r.padRightCodec=function padRightCodec(e,r){return combineCodec(padRightEncoder(e,r),padRightDecoder(e,r))},r.padRightDecoder=padRightDecoder,r.padRightEncoder=padRightEncoder,r.resizeCodec=function resizeCodec(e,r){return combineCodec(resizeEncoder(e,r),resizeDecoder(e,r))},r.resizeDecoder=resizeDecoder,r.resizeEncoder=resizeEncoder,r.reverseCodec=function reverseCodec(e){return combineCodec(reverseEncoder(e),reverseDecoder(e))},r.reverseDecoder=reverseDecoder,r.reverseEncoder=reverseEncoder},78067:(e,r,n)=>{var i=n(268117),s=n(701536),a=n(132595);function assertValidNumberOfItemsForCodec(e,r,n){if(r!==n)throw new a.SolanaError(a.SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,{actual:n,codecDescription:e,expected:r})}function sumCodecSizes(e){return e.reduce(((e,r)=>null===e||null===r?null:e+r),0)}function getFixedSize(e){return i.isFixedSize(e)?e.fixedSize:null}function getMaxSize(e){return i.isFixedSize(e)?e.fixedSize:e.maxSize??null}function getArrayEncoder(e,r={}){const n=r.size??s.getU32Encoder(),a=computeArrayLikeCodecSize(n,getFixedSize(e)),w=computeArrayLikeCodecSize(n,getMaxSize(e))??void 0;return i.createEncoder({...null!==a?{fixedSize:a}:{getSizeFromValue:r=>("object"==typeof n?i.getEncodedSize(r.length,n):0)+[...r].reduce(((r,n)=>r+i.getEncodedSize(n,e)),0),maxSize:w},write:(r,i,s)=>("number"==typeof n&&assertValidNumberOfItemsForCodec("array",n,r.length),"object"==typeof n&&(s=n.write(r.length,i,s)),r.forEach((r=>{s=e.write(r,i,s)})),s)})}function getArrayDecoder(e,r={}){const n=r.size??s.getU32Decoder(),a=getFixedSize(e),w=computeArrayLikeCodecSize(n,a),k=computeArrayLikeCodecSize(n,getMaxSize(e))??void 0;return i.createDecoder({...null!==w?{fixedSize:w}:{maxSize:k},read:(r,i)=>{const s=[];if("object"==typeof n&&0===r.slice(i).length)return[s,i];if("remainder"===n){for(;i<r.length;){const[n,a]=e.read(r,i);i=a,s.push(n)}return[s,i]}const[a,w]="number"==typeof n?[n,i]:n.read(r,i);i=w;for(let n=0;n<a;n+=1){const[n,a]=e.read(r,i);i=a,s.push(n)}return[s,i]}})}function computeArrayLikeCodecSize(e,r){return"number"!=typeof e?null:0===e?0:null===r?null:r*e}function getBitArrayEncoder(e,r={}){const n=("boolean"==typeof r?{backward:r}:r).backward??!1;return i.createEncoder({fixedSize:e,write(r,i,s){const a=[];for(let i=0;i<e;i+=1){let e=0;for(let s=0;s<8;s+=1){e|=Number(r[8*i+s]??0)<<(n?s:7-s)}n?a.unshift(e):a.push(e)}return i.set(a,s),e}})}function getBitArrayDecoder(e,r={}){const n=("boolean"==typeof r?{backward:r}:r).backward??!1;return i.createDecoder({fixedSize:e,read(r,s){i.assertByteArrayHasEnoughBytesForCodec("bitArray",e,r,s);const a=[];let w=r.slice(s,s+e);return w=n?w.reverse():w,w.forEach((e=>{for(let r=0;r<8;r+=1)n?(a.push(Boolean(1&e)),e>>=1):(a.push(Boolean(128&e)),e<<=1)})),[a,s+e]}})}function getBooleanEncoder(e={}){const r=e.size??s.getU8Encoder();return i.assertIsFixedSize(r),i.mapEncoder(r,(e=>e?1:0))}function getBooleanDecoder(e={}){const r=e.size??s.getU8Decoder();return i.assertIsFixedSize(r),i.mapDecoder(r,(e=>1===Number(e)))}function getBytesEncoder(e={}){const r=e.size??"variable",n=i.createEncoder({getSizeFromValue:e=>e.length,write:(e,r,n)=>(r.set(e,n),n+e.length)});return"variable"===r?n:"number"==typeof r?i.fixEncoder(n,r):i.createEncoder({getSizeFromValue:e=>i.getEncodedSize(e.length,r)+e.length,write:(e,i,s)=>(s=r.write(e.length,i,s),n.write(e,i,s))})}function getBytesDecoder(e={}){const r=e.size??"variable",n=i.createDecoder({read:(e,r)=>{const n=e.slice(r);return[n,r+n.length]}});return"variable"===r?n:"number"==typeof r?i.fixDecoder(n,r):i.createDecoder({read:(e,s)=>{i.assertByteArrayIsNotEmptyForCodec("bytes",e,s);const[a,w]=r.read(e,s),k=Number(a);s=w;const I=e.slice(s,s+k);i.assertByteArrayHasEnoughBytesForCodec("bytes",k,I);const[we,Ae]=n.read(I,0);return[we,s+=Ae]}})}function getDataEnumEncoder(e,r={}){const n=r.size??s.getU8Encoder(),a=getDataEnumFixedSize(e,n);return i.createEncoder({...null!==a?{fixedSize:a}:{getSizeFromValue:r=>{const s=getVariantDiscriminator(e,r),a=e[s][1];return i.getEncodedSize(s,n)+i.getEncodedSize(r,a)},maxSize:getDataEnumMaxSize(e,n)},write:(r,i,s)=>{const a=getVariantDiscriminator(e,r);s=n.write(a,i,s);return e[a][1].write(r,i,s)}})}function getDataEnumDecoder(e,r={}){const n=r.size??s.getU8Decoder(),w=getDataEnumFixedSize(e,n);return i.createDecoder({...null!==w?{fixedSize:w}:{maxSize:getDataEnumMaxSize(e,n)},read:(r,s)=>{i.assertByteArrayIsNotEmptyForCodec("dataEnum",r,s);const[w,k]=n.read(r,s);s=k;const I=e[Number(w)]??null;if(!I)throw new a.SolanaError(a.SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,{discriminator:w,maxRange:e.length-1,minRange:0});const[we,Ae]=I[1].read(r,s);return s=Ae,[{__kind:I[0],...we??{}},s]}})}function getDataEnumFixedSize(e,r){if(0===e.length)return i.isFixedSize(r)?r.fixedSize:null;if(!i.isFixedSize(e[0][1]))return null;const n=e[0][1].fixedSize;return e.every((e=>i.isFixedSize(e[1])&&e[1].fixedSize===n))&&i.isFixedSize(r)?r.fixedSize+n:null}function getDataEnumMaxSize(e,r){const n=function maxCodecSizes(e){return e.reduce(((e,r)=>null===e||null===r?null:Math.max(e,r)),0)}(e.map((([,e])=>getMaxSize(e))));return sumCodecSizes([getMaxSize(r),n])??void 0}function getVariantDiscriminator(e,r){const n=e.findIndex((([e])=>r.__kind===e));if(n<0)throw new a.SolanaError(a.SOLANA_ERROR__CODECS__INVALID_DATA_ENUM_VARIANT,{value:r.__kind,variants:e.map((([e])=>e))});return n}function getTupleEncoder(e){const r=sumCodecSizes(e.map(getFixedSize)),n=sumCodecSizes(e.map(getMaxSize))??void 0;return i.createEncoder({...null===r?{getSizeFromValue:r=>e.map(((e,n)=>i.getEncodedSize(r[n],e))).reduce(((e,r)=>e+r),0),maxSize:n}:{fixedSize:r},write:(r,n,i)=>(assertValidNumberOfItemsForCodec("tuple",e.length,r.length),e.forEach(((e,s)=>{i=e.write(r[s],n,i)})),i)})}function getTupleDecoder(e){const r=sumCodecSizes(e.map(getFixedSize)),n=sumCodecSizes(e.map(getMaxSize))??void 0;return i.createDecoder({...null===r?{maxSize:n}:{fixedSize:r},read:(r,n)=>{const i=[];return e.forEach((e=>{const[s,a]=e.read(r,n);i.push(s),n=a})),[i,n]}})}function getMapEncoder(e,r,n={}){return i.mapEncoder(getArrayEncoder(getTupleEncoder([e,r]),n),(e=>[...e.entries()]))}function getMapDecoder(e,r,n={}){return i.mapDecoder(getArrayDecoder(getTupleDecoder([e,r]),n),(e=>new Map(e)))}function getNullableEncoder(e,r={}){const n=r.prefix??s.getU8Encoder(),a=r.fixed??!1,w=i.isFixedSize(e)&&i.isFixedSize(n)&&0===e.fixedSize;if(a||w){i.assertIsFixedSize(e),i.assertIsFixedSize(n);const r=n.fixedSize+e.fixedSize;return i.createEncoder({fixedSize:r,write:(i,s,a)=>{const w=n.write(Number(null!==i),s,a);return null!==i&&e.write(i,s,w),a+r}})}return i.createEncoder({getSizeFromValue:r=>i.getEncodedSize(Number(null!==r),n)+(null!==r?i.getEncodedSize(r,e):0),maxSize:sumCodecSizes([n,e].map(getMaxSize))??void 0,write:(r,i,s)=>(s=n.write(Number(null!==r),i,s),null!==r&&(s=e.write(r,i,s)),s)})}function getNullableDecoder(e,r={}){const n=r.prefix??s.getU8Decoder(),a=r.fixed??!1;let w=null;const k=i.isFixedSize(e)&&i.isFixedSize(n)&&0===e.fixedSize;return(a||k)&&(i.assertIsFixedSize(e),i.assertIsFixedSize(n),w=n.fixedSize+e.fixedSize),i.createDecoder({...null===w?{maxSize:sumCodecSizes([n,e].map(getMaxSize))??void 0}:{fixedSize:w},read:(r,i)=>{if(r.length-i<=0)return[null,i];const[s,a]=n.read(r,i);if(0===s)return[null,null!==w?i+w:a];const[k,I]=e.read(r,a);return[k,null!==w?i+w:I]}})}function getScalarEnumEncoder(e,r={}){const n=r.size??s.getU8Encoder(),{minRange:w,maxRange:k,allStringInputs:I,enumKeys:we,enumValues:Ae}=getScalarEnumStats(e);return i.mapEncoder(n,(e=>{const r="number"==typeof e&&(e<w||e>k),n="string"==typeof e&&!I.includes(e);if(r||n)throw new a.SolanaError(a.SOLANA_ERROR__CODECS__INVALID_SCALAR_ENUM_VARIANT,{maxRange:k,minRange:w,value:e,variants:I});if("number"==typeof e)return e;const i=Ae.indexOf(e);return i>=0?i:we.indexOf(e)}))}function getScalarEnumDecoder(e,r={}){const n=r.size??s.getU8Decoder(),{minRange:w,maxRange:k,enumKeys:I}=getScalarEnumStats(e);return i.mapDecoder(n,(r=>{const n=Number(r);if(n<w||n>k)throw new a.SolanaError(a.SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,{discriminator:n,maxRange:k,minRange:w});return e[I[n]]}))}function getScalarEnumStats(e){const r=Object.values(e).filter((e=>"number"==typeof e)),n=Object.fromEntries(Object.entries(e).slice(r.length)),i=Object.keys(n),s=Object.values(n),a=s.length-1;return{allStringInputs:[...new Set([...i,...s.filter((e=>"string"==typeof e))])],enumKeys:i,enumValues:s,maxRange:a,minRange:0}}function getSetEncoder(e,r={}){return i.mapEncoder(getArrayEncoder(e,r),(e=>[...e]))}function getSetDecoder(e,r={}){return i.mapDecoder(getArrayDecoder(e,r),(e=>new Set(e)))}function getStructEncoder(e){const r=e.map((([,e])=>e)),n=sumCodecSizes(r.map(getFixedSize)),s=sumCodecSizes(r.map(getMaxSize))??void 0;return i.createEncoder({...null===n?{getSizeFromValue:r=>e.map((([e,n])=>i.getEncodedSize(r[e],n))).reduce(((e,r)=>e+r),0),maxSize:s}:{fixedSize:n},write:(r,n,i)=>(e.forEach((([e,s])=>{i=s.write(r[e],n,i)})),i)})}function getStructDecoder(e){const r=e.map((([,e])=>e)),n=sumCodecSizes(r.map(getFixedSize)),s=sumCodecSizes(r.map(getMaxSize))??void 0;return i.createDecoder({...null===n?{maxSize:s}:{fixedSize:n},read:(r,n)=>{const i={};return e.forEach((([e,s])=>{const[a,w]=s.read(r,n);n=w,i[e]=a})),[i,n]}})}function getUnitEncoder(){return i.createEncoder({fixedSize:0,write:(e,r,n)=>n})}function getUnitDecoder(){return i.createDecoder({fixedSize:0,read:(e,r)=>[void 0,r]})}r.assertValidNumberOfItemsForCodec=assertValidNumberOfItemsForCodec,r.getArrayCodec=function getArrayCodec(e,r={}){return i.combineCodec(getArrayEncoder(e,r),getArrayDecoder(e,r))},r.getArrayDecoder=getArrayDecoder,r.getArrayEncoder=getArrayEncoder,r.getBitArrayCodec=function getBitArrayCodec(e,r={}){return i.combineCodec(getBitArrayEncoder(e,r),getBitArrayDecoder(e,r))},r.getBitArrayDecoder=getBitArrayDecoder,r.getBitArrayEncoder=getBitArrayEncoder,r.getBooleanCodec=function getBooleanCodec(e={}){return i.combineCodec(getBooleanEncoder(e),getBooleanDecoder(e))},r.getBooleanDecoder=getBooleanDecoder,r.getBooleanEncoder=getBooleanEncoder,r.getBytesCodec=function getBytesCodec(e={}){return i.combineCodec(getBytesEncoder(e),getBytesDecoder(e))},r.getBytesDecoder=getBytesDecoder,r.getBytesEncoder=getBytesEncoder,r.getDataEnumCodec=function getDataEnumCodec(e,r={}){return i.combineCodec(getDataEnumEncoder(e,r),getDataEnumDecoder(e,r))},r.getDataEnumDecoder=getDataEnumDecoder,r.getDataEnumEncoder=getDataEnumEncoder,r.getMapCodec=function getMapCodec(e,r,n={}){return i.combineCodec(getMapEncoder(e,r,n),getMapDecoder(e,r,n))},r.getMapDecoder=getMapDecoder,r.getMapEncoder=getMapEncoder,r.getNullableCodec=function getNullableCodec(e,r={}){const n=r;return i.combineCodec(getNullableEncoder(e,n),getNullableDecoder(e,n))},r.getNullableDecoder=getNullableDecoder,r.getNullableEncoder=getNullableEncoder,r.getScalarEnumCodec=function getScalarEnumCodec(e,r={}){return i.combineCodec(getScalarEnumEncoder(e,r),getScalarEnumDecoder(e,r))},r.getScalarEnumDecoder=getScalarEnumDecoder,r.getScalarEnumEncoder=getScalarEnumEncoder,r.getSetCodec=function getSetCodec(e,r={}){return i.combineCodec(getSetEncoder(e,r),getSetDecoder(e,r))},r.getSetDecoder=getSetDecoder,r.getSetEncoder=getSetEncoder,r.getStructCodec=function getStructCodec(e){return i.combineCodec(getStructEncoder(e),getStructDecoder(e))},r.getStructDecoder=getStructDecoder,r.getStructEncoder=getStructEncoder,r.getTupleCodec=function getTupleCodec(e){return i.combineCodec(getTupleEncoder(e),getTupleDecoder(e))},r.getTupleDecoder=getTupleDecoder,r.getTupleEncoder=getTupleEncoder,r.getUnitCodec=function getUnitCodec(){return i.combineCodec(getUnitEncoder(),getUnitDecoder())},r.getUnitDecoder=getUnitDecoder,r.getUnitEncoder=getUnitEncoder},701536:(e,r,n)=>{var i=n(132595),s=n(268117);function assertNumberIsBetweenForCodec(e,r,n,s){if(s<r||s>n)throw new i.SolanaError(i.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,{codecDescription:e,max:n,min:r,value:s})}var a=(e=>(e[e.LITTLE=0]="LITTLE",e[e.BIG=1]="BIG",e))(a||{});function isLittleEndian(e){return 1!==e?.endian}function numberEncoderFactory(e){return s.createEncoder({fixedSize:e.size,write(r,n,i){e.range&&assertNumberIsBetweenForCodec(e.name,e.range[0],e.range[1],r);const s=new ArrayBuffer(e.size);return e.set(new DataView(s),r,isLittleEndian(e.config)),n.set(new Uint8Array(s),i),i+e.size}})}function numberDecoderFactory(e){return s.createDecoder({fixedSize:e.size,read(r,n=0){s.assertByteArrayIsNotEmptyForCodec(e.name,r,n),s.assertByteArrayHasEnoughBytesForCodec(e.name,e.size,r,n);const i=new DataView(function toArrayBuffer(e,r,n){const i=e.byteOffset+(r??0),s=n??e.byteLength;return e.buffer.slice(i,i+s)}(r,n,e.size));return[e.get(i,isLittleEndian(e.config)),n+e.size]}})}var getF32Encoder=(e={})=>numberEncoderFactory({config:e,name:"f32",set:(e,r,n)=>e.setFloat32(0,r,n),size:4}),getF32Decoder=(e={})=>numberDecoderFactory({config:e,get:(e,r)=>e.getFloat32(0,r),name:"f32",size:4}),getF64Encoder=(e={})=>numberEncoderFactory({config:e,name:"f64",set:(e,r,n)=>e.setFloat64(0,r,n),size:8}),getF64Decoder=(e={})=>numberDecoderFactory({config:e,get:(e,r)=>e.getFloat64(0,r),name:"f64",size:8}),getI128Encoder=(e={})=>numberEncoderFactory({config:e,name:"i128",range:[-BigInt("0x7fffffffffffffffffffffffffffffff")-1n,BigInt("0x7fffffffffffffffffffffffffffffff")],set:(e,r,n)=>{const i=n?8:0,s=n?0:8;e.setBigInt64(i,BigInt(r)>>64n,n),e.setBigUint64(s,0xffffffffffffffffn&BigInt(r),n)},size:16}),getI128Decoder=(e={})=>numberDecoderFactory({config:e,get:(e,r)=>{const n=r?8:0,i=r?0:8;return(e.getBigInt64(n,r)<<64n)+e.getBigUint64(i,r)},name:"i128",size:16}),getI16Encoder=(e={})=>numberEncoderFactory({config:e,name:"i16",range:[-Number("0x7fff")-1,Number("0x7fff")],set:(e,r,n)=>e.setInt16(0,r,n),size:2}),getI16Decoder=(e={})=>numberDecoderFactory({config:e,get:(e,r)=>e.getInt16(0,r),name:"i16",size:2}),getI32Encoder=(e={})=>numberEncoderFactory({config:e,name:"i32",range:[-Number("0x7fffffff")-1,Number("0x7fffffff")],set:(e,r,n)=>e.setInt32(0,r,n),size:4}),getI32Decoder=(e={})=>numberDecoderFactory({config:e,get:(e,r)=>e.getInt32(0,r),name:"i32",size:4}),getI64Encoder=(e={})=>numberEncoderFactory({config:e,name:"i64",range:[-BigInt("0x7fffffffffffffff")-1n,BigInt("0x7fffffffffffffff")],set:(e,r,n)=>e.setBigInt64(0,BigInt(r),n),size:8}),getI64Decoder=(e={})=>numberDecoderFactory({config:e,get:(e,r)=>e.getBigInt64(0,r),name:"i64",size:8}),getI8Encoder=()=>numberEncoderFactory({name:"i8",range:[-Number("0x7f")-1,Number("0x7f")],set:(e,r)=>e.setInt8(0,r),size:1}),getI8Decoder=()=>numberDecoderFactory({get:e=>e.getInt8(0),name:"i8",size:1}),getShortU16Encoder=()=>s.createEncoder({getSizeFromValue:e=>e<=127?1:e<=16383?2:3,maxSize:3,write:(e,r,n)=>{assertNumberIsBetweenForCodec("shortU16",0,65535,e);const i=[0];for(let r=0;;r+=1){const n=e>>7*r;if(0===n)break;const s=127&n;i[r]=s,r>0&&(i[r-1]|=128)}return r.set(i,n),n+i.length}}),getShortU16Decoder=()=>s.createDecoder({maxSize:3,read:(e,r)=>{let n=0,i=0;for(;++i;){const s=i-1,a=e[r+s];if(n|=(127&a)<<7*s,!(128&a))break}return[n,r+i]}}),getU128Encoder=(e={})=>numberEncoderFactory({config:e,name:"u128",range:[0n,BigInt("0xffffffffffffffffffffffffffffffff")],set:(e,r,n)=>{const i=n?8:0,s=n?0:8;e.setBigUint64(i,BigInt(r)>>64n,n),e.setBigUint64(s,0xffffffffffffffffn&BigInt(r),n)},size:16}),getU128Decoder=(e={})=>numberDecoderFactory({config:e,get:(e,r)=>{const n=r?8:0,i=r?0:8;return(e.getBigUint64(n,r)<<64n)+e.getBigUint64(i,r)},name:"u128",size:16}),getU16Encoder=(e={})=>numberEncoderFactory({config:e,name:"u16",range:[0,Number("0xffff")],set:(e,r,n)=>e.setUint16(0,r,n),size:2}),getU16Decoder=(e={})=>numberDecoderFactory({config:e,get:(e,r)=>e.getUint16(0,r),name:"u16",size:2}),getU32Encoder=(e={})=>numberEncoderFactory({config:e,name:"u32",range:[0,Number("0xffffffff")],set:(e,r,n)=>e.setUint32(0,r,n),size:4}),getU32Decoder=(e={})=>numberDecoderFactory({config:e,get:(e,r)=>e.getUint32(0,r),name:"u32",size:4}),getU64Encoder=(e={})=>numberEncoderFactory({config:e,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(e,r,n)=>e.setBigUint64(0,BigInt(r),n),size:8}),getU64Decoder=(e={})=>numberDecoderFactory({config:e,get:(e,r)=>e.getBigUint64(0,r),name:"u64",size:8}),getU8Encoder=()=>numberEncoderFactory({name:"u8",range:[0,Number("0xff")],set:(e,r)=>e.setUint8(0,r),size:1}),getU8Decoder=()=>numberDecoderFactory({get:e=>e.getUint8(0),name:"u8",size:1});r.Endian=a,r.assertNumberIsBetweenForCodec=assertNumberIsBetweenForCodec,r.getF32Codec=(e={})=>s.combineCodec(getF32Encoder(e),getF32Decoder(e)),r.getF32Decoder=getF32Decoder,r.getF32Encoder=getF32Encoder,r.getF64Codec=(e={})=>s.combineCodec(getF64Encoder(e),getF64Decoder(e)),r.getF64Decoder=getF64Decoder,r.getF64Encoder=getF64Encoder,r.getI128Codec=(e={})=>s.combineCodec(getI128Encoder(e),getI128Decoder(e)),r.getI128Decoder=getI128Decoder,r.getI128Encoder=getI128Encoder,r.getI16Codec=(e={})=>s.combineCodec(getI16Encoder(e),getI16Decoder(e)),r.getI16Decoder=getI16Decoder,r.getI16Encoder=getI16Encoder,r.getI32Codec=(e={})=>s.combineCodec(getI32Encoder(e),getI32Decoder(e)),r.getI32Decoder=getI32Decoder,r.getI32Encoder=getI32Encoder,r.getI64Codec=(e={})=>s.combineCodec(getI64Encoder(e),getI64Decoder(e)),r.getI64Decoder=getI64Decoder,r.getI64Encoder=getI64Encoder,r.getI8Codec=()=>s.combineCodec(getI8Encoder(),getI8Decoder()),r.getI8Decoder=getI8Decoder,r.getI8Encoder=getI8Encoder,r.getShortU16Codec=()=>s.combineCodec(getShortU16Encoder(),getShortU16Decoder()),r.getShortU16Decoder=getShortU16Decoder,r.getShortU16Encoder=getShortU16Encoder,r.getU128Codec=(e={})=>s.combineCodec(getU128Encoder(e),getU128Decoder(e)),r.getU128Decoder=getU128Decoder,r.getU128Encoder=getU128Encoder,r.getU16Codec=(e={})=>s.combineCodec(getU16Encoder(e),getU16Decoder(e)),r.getU16Decoder=getU16Decoder,r.getU16Encoder=getU16Encoder,r.getU32Codec=(e={})=>s.combineCodec(getU32Encoder(e),getU32Decoder(e)),r.getU32Decoder=getU32Decoder,r.getU32Encoder=getU32Encoder,r.getU64Codec=(e={})=>s.combineCodec(getU64Encoder(e),getU64Decoder(e)),r.getU64Decoder=getU64Decoder,r.getU64Encoder=getU64Encoder,r.getU8Codec=()=>s.combineCodec(getU8Encoder(),getU8Decoder()),r.getU8Decoder=getU8Decoder,r.getU8Encoder=getU8Encoder},98700:(e,r,n)=>{var i=n(132595),s=n(268117),a=n(701536);function assertValidBaseString(e,r,n=r){if(!r.match(new RegExp(`^[${e}]*$`)))throw new i.SolanaError(i.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,{alphabet:e,base:e.length,value:n})}var getBaseXEncoder=e=>s.createEncoder({getSizeFromValue:r=>{const[n,i]=partitionLeadingZeroes(r,e[0]);if(!i)return r.length;const s=getBigIntFromBaseX(i,e);return n.length+Math.ceil(s.toString(16).length/2)},write(r,n,i){if(assertValidBaseString(e,r),""===r)return i;const[s,a]=partitionLeadingZeroes(r,e[0]);if(!a)return n.set(new Uint8Array(s.length).fill(0),i),i+s.length;let w=getBigIntFromBaseX(a,e);const k=[];for(;w>0n;)k.unshift(Number(w%256n)),w/=256n;const I=[...Array(s.length).fill(0),...k];return n.set(I,i),i+I.length}}),getBaseXDecoder=e=>s.createDecoder({read(r,n){const i=0===n?r:r.slice(n);if(0===i.length)return["",0];let s=i.findIndex((e=>0!==e));s=-1===s?i.length:s;const a=e[0].repeat(s);if(s===i.length)return[a,r.length];const w=function getBaseXFromBigInt(e,r){const n=BigInt(r.length),i=[];for(;e>0n;)i.unshift(r[Number(e%n)]),e/=n;return i.join("")}(i.slice(s).reduce(((e,r)=>256n*e+BigInt(r)),0n),e);return[a+w,r.length]}}),getBaseXCodec=e=>s.combineCodec(getBaseXEncoder(e),getBaseXDecoder(e));function partitionLeadingZeroes(e,r){const[n,i]=e.split(new RegExp(`((?!${r}).*)`));return[n,i]}function getBigIntFromBaseX(e,r){const n=BigInt(r.length);let i=0n;for(const s of e)i*=n,i+=BigInt(r.indexOf(s));return i}var w="0123456789",getBase16Encoder=()=>s.createEncoder({getSizeFromValue:e=>Math.ceil(e.length/2),write(e,r,n){const i=e.toLowerCase();assertValidBaseString("0123456789abcdef",i,e);const s=i.match(/.{1,2}/g),a=s?s.map((e=>parseInt(e,16))):[];return r.set(a,n),a.length+n}}),getBase16Decoder=()=>s.createDecoder({read:(e,r)=>[e.slice(r).reduce(((e,r)=>e+r.toString(16).padStart(2,"0")),""),e.length]}),k="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",getBaseXResliceEncoder=(e,r)=>s.createEncoder({getSizeFromValue:e=>Math.floor(e.length*r/8),write(n,i,s){if(assertValidBaseString(e,n),""===n)return s;const a=reslice([...n].map((r=>e.indexOf(r))),r,8,!1);return i.set(a,s),a.length+s}}),getBaseXResliceDecoder=(e,r)=>s.createDecoder({read(n,i=0){const s=0===i?n:n.slice(i);if(0===s.length)return["",n.length];return[reslice([...s],8,r,!0).map((r=>e[r])).join(""),n.length]}});function reslice(e,r,n,i){const s=[];let a=0,w=0;const k=(1<<n)-1;for(const i of e)for(a=a<<r|i,w+=r;w>=n;)w-=n,s.push(a>>w&k);return i&&w>0&&s.push(a<<n-w&k),s}var I="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",getBase64Encoder=()=>s.createEncoder({getSizeFromValue:e=>{try{return atob(e).length}catch(r){throw new i.SolanaError(i.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,{alphabet:I,base:64,value:e})}},write(e,r,n){try{const i=atob(e).split("").map((e=>e.charCodeAt(0)));return r.set(i,n),i.length+n}catch(r){throw new i.SolanaError(i.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,{alphabet:I,base:64,value:e})}}}),getBase64Decoder=()=>s.createDecoder({read(e,r=0){const n=e.slice(r);return[btoa(String.fromCharCode(...n)),e.length]}}),removeNullCharacters=e=>e.replace(/\u0000/g,""),we=globalThis.TextDecoder,Ae=globalThis.TextEncoder,getUtf8Encoder=()=>{let e;return s.createEncoder({getSizeFromValue:r=>(e||=new Ae).encode(r).length,write:(r,n,i)=>{const s=(e||=new Ae).encode(r);return n.set(s,i),i+s.length}})},getUtf8Decoder=()=>{let e;return s.createDecoder({read(r,n){const i=(e||=new we).decode(r.slice(n));return[removeNullCharacters(i),r.length]}})};function getStringEncoder(e={}){const r=e.size??a.getU32Encoder(),n=e.encoding??getUtf8Encoder();return"variable"===r?n:"number"==typeof r?s.fixEncoder(n,r):s.createEncoder({getSizeFromValue:e=>{const i=s.getEncodedSize(e,n);return s.getEncodedSize(i,r)+i},write:(e,i,a)=>{const w=s.getEncodedSize(e,n);return a=r.write(w,i,a),n.write(e,i,a)}})}function getStringDecoder(e={}){const r=e.size??a.getU32Decoder(),n=e.encoding??getUtf8Decoder();return"variable"===r?n:"number"==typeof r?s.fixDecoder(n,r):s.createDecoder({read:(e,i=0)=>{s.assertByteArrayIsNotEmptyForCodec("string",e,i);const[a,w]=r.read(e,i),k=Number(a);i=w;const I=e.slice(i,i+k);s.assertByteArrayHasEnoughBytesForCodec("string",k,I);const[we,Ae]=n.read(I,0);return[we,i+=Ae]}})}r.assertValidBaseString=assertValidBaseString,r.getBase10Codec=()=>getBaseXCodec(w),r.getBase10Decoder=()=>getBaseXDecoder(w),r.getBase10Encoder=()=>getBaseXEncoder(w),r.getBase16Codec=()=>s.combineCodec(getBase16Encoder(),getBase16Decoder()),r.getBase16Decoder=getBase16Decoder,r.getBase16Encoder=getBase16Encoder,r.getBase58Codec=()=>getBaseXCodec(k),r.getBase58Decoder=()=>getBaseXDecoder(k),r.getBase58Encoder=()=>getBaseXEncoder(k),r.getBase64Codec=()=>s.combineCodec(getBase64Encoder(),getBase64Decoder()),r.getBase64Decoder=getBase64Decoder,r.getBase64Encoder=getBase64Encoder,r.getBaseXCodec=getBaseXCodec,r.getBaseXDecoder=getBaseXDecoder,r.getBaseXEncoder=getBaseXEncoder,r.getBaseXResliceCodec=(e,r)=>s.combineCodec(getBaseXResliceEncoder(e,r),getBaseXResliceDecoder(e,r)),r.getBaseXResliceDecoder=getBaseXResliceDecoder,r.getBaseXResliceEncoder=getBaseXResliceEncoder,r.getStringCodec=function getStringCodec(e={}){return s.combineCodec(getStringEncoder(e),getStringDecoder(e))},r.getStringDecoder=getStringDecoder,r.getStringEncoder=getStringEncoder,r.getUtf8Codec=()=>s.combineCodec(getUtf8Encoder(),getUtf8Decoder()),r.getUtf8Decoder=getUtf8Decoder,r.getUtf8Encoder=getUtf8Encoder,r.padNullCharacters=(e,r)=>e.padEnd(r,"\0"),r.removeNullCharacters=removeNullCharacters},822319:(e,r,n)=>{var i=n(268117),s=n(78067),a=n(701536),w=n(98700),k=n(414014);Object.keys(i).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(r,e)||Object.defineProperty(r,e,{enumerable:!0,get:function(){return i[e]}})})),Object.keys(s).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(r,e)||Object.defineProperty(r,e,{enumerable:!0,get:function(){return s[e]}})})),Object.keys(a).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(r,e)||Object.defineProperty(r,e,{enumerable:!0,get:function(){return a[e]}})})),Object.keys(w).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(r,e)||Object.defineProperty(r,e,{enumerable:!0,get:function(){return w[e]}})})),Object.keys(k).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(r,e)||Object.defineProperty(r,e,{enumerable:!0,get:function(){return k[e]}})}))},132595:(e,r)=>{var n=(()=>!1)(),i=-32700,s=-32603,a=-32602,w=-32601,k=-32600,I=-32016,we=-32015,Ae=-32014,Ce=-32013,Be=-32012,ze=-32011,qe=-32010,$e=-32009,Ye=-32008,Je=-32007,et=-32006,rt=-32005,it=-32004,ot=-32003,ht=-32002,ft=-32001,pt=28e5,yt=2800001,_t=2800002,St=2800003,kt=2800004,Dt=2800005,Mt=2800006,qt=2800007,Gt=2800008,Qt=2800009,er=2800010,tr=323e4,rr=32300001,nr=3230002,ir=3230003,or=3230004,sr=361e4,ar=3610001,cr=3610002,ur=3610003,dr=3610004,lr=3610005,hr=3610006,fr=3704e3,gr=3704001,pr=3704002,mr=3704003,yr=4128e3,br=4128001,_r=4128002,wr=4615e3,Sr=4615001,Er=4615002,kr=4615003,Ar=4615004,Ir=4615005,Rr=4615006,vr=4615007,Or=4615008,xr=4615009,Tr=4615010,Nr=4615011,Pr=4615012,Cr=4615013,Br=4615014,Lr=4615015,zr=4615016,Dr=4615017,Kr=4615018,Ur=4615019,Mr=4615020,Fr=4615021,Wr=4615022,qr=4615023,Vr=4615024,jr=4615025,Hr=4615026,$r=4615027,Yr=4615028,Gr=4615029,Jr=4615030,Zr=4615031,Xr=4615032,Qr=4615033,sn=4615034,an=4615035,cn=4615036,un=4615037,dn=4615038,ln=4615039,gn=4615040,pn=4615041,mn=4615042,yn=4615043,bn=4615044,kn=4615045,In=4615046,Cn=4615047,Bn=4615048,Mn=4615049,Wn=4615050,Hn=4615051,Zn=4615052,Qn=4615053,ei=4615054,ti=5508e3,ri=5508001,ni=5508002,ii=5508003,oi=5508004,si=5508005,ai=5508006,ci=5508007,ui=5508008,di=5508009,li=5508010,hi=5663e3,fi=5663001,gi=5663002,pi=5663003,mi=5663004,yi=5663005,bi=5663006,_i=5663007,wi=5663008,Si=5663009,Ei=5663010,ki=5663011,Ai=5663012,Ii=5663013,Ri=5663014,vi=705e4,Oi=7050001,xi=7050002,Ti=7050003,Ni=7050004,Pi=7050005,Ci=7050006,Bi=7050007,Li=7050008,zi=7050009,Di=7050010,Ki=7050011,Ui=7050012,Mi=7050013,Fi=7050014,Wi=7050015,qi=7050016,Vi=7050017,ji=7050018,Hi=7050019,$i=7050020,Yi=7050021,Gi=7050022,Ji=7050023,Zi=7050024,Xi=7050025,Qi=7050026,eo=7050027,to=7050028,ro=7050029,no=7050030,io=7050031,oo=7050032,so=7050033,ao=7050034,co=7050035,uo=7050036,lo=8078e3,ho=8078001,fo=8078002,go=8078003,po=8078004,mo=8078005,yo=8078006,bo=8078007,_o=8078008,wo=8078009,So=8078010,Eo=8078011,ko=8078012,Ao=8078013,Io=8078014,Ro=81e5,vo=8100001,Oo=8100002,xo=819e4,To=8190001,No=8190002,Po=8190003,Co=8190004,Bo=99e5,Lo=9900001,zo=9900002,Do=9900003,Ko={[tr]:"Account not found at address: $address",[or]:"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",[ir]:"Expected decoded account at address: $address",[nr]:"Failed to decode account data at address: $address",[rr]:"Accounts not found at addresses: $addresses",[Qt]:"Unable to find a viable program address bump seed.",[_t]:"$putativeAddress is not a base58-encoded address.",[pt]:"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",[St]:"The `CryptoKey` must be an `Ed25519` public key.",[Gt]:"Invalid seeds; point must fall off the Ed25519 curve.",[kt]:"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",[Mt]:"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",[qt]:"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",[Dt]:"Expected program derived address bump to be in the range [0, 255], got: $bump.",[er]:"Program address cannot end with PDA marker.",[yt]:"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",4:"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",1:"The network has progressed past the last block for which this transaction could have been committed.",[lo]:"Codec [$codecDescription] cannot decode empty byte arrays.",[mo]:"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",[yo]:"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",[po]:"Encoder and decoder must either both be fixed-size or variable-size.",[_o]:"Enum discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",[fo]:"Expected a fixed-size codec, got a variable-size one.",[Ao]:"Codec [$codecDescription] expected a positive byte length, got $bytesLength.",[go]:"Expected a variable-size codec, got a fixed-size one.",[ho]:"Codec [$codecDescription] expected $expected bytes, got $bytesLength.",[wo]:"Invalid data enum variant. Expected one of [$variants], got $value.",[bo]:"Expected [$codecDescription] to have $expected items, got $actual.",[So]:"Invalid scalar enum variant. Expected one of [$variants] or a number between $minRange and $maxRange, got $value.",[ko]:"Invalid value $value for base $base with alphabet $alphabet.",[Eo]:"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",[Io]:"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",[xr]:"instruction requires an uninitialized account",[qr]:"instruction tries to borrow reference for an account which is already borrowed",[Vr]:"instruction left account with an outstanding borrowed reference",[Fr]:"program other than the account's owner changed the size of the account data",[Ir]:"account data too small for instruction",[Wr]:"instruction expected an executable account",[In]:"An account does not have enough lamports to be rent-exempt",[Bn]:"Program arithmetic overflowed",[kn]:"Failed to serialize or deserialize account data: $encodedData",[ei]:"Builtin programs must consume compute units",[Xr]:"Cross-program invocation call depth too deep",[dn]:"Computational budget exceeded",[Hr]:"custom program error: #$code",[Dr]:"instruction contains duplicate accounts",[jr]:"instruction modifications of multiply-passed account differ",[Jr]:"executable accounts must be rent exempt",[Yr]:"instruction changed executable accounts data",[Gr]:"instruction changed the balance of an executable account",[Kr]:"instruction changed executable bit of an account",[Br]:"instruction modified data of an account it does not own",[Cr]:"instruction spent from the balance of an account it does not own",[Sr]:"generic instruction error",[Wn]:"Provided owner is not allowed",[yn]:"Account is immutable",[bn]:"Incorrect authority provided",[vr]:"incorrect program id for instruction",[Rr]:"insufficient funds for instruction",[Ar]:"invalid account data for instruction",[Cn]:"Invalid account owner",[Er]:"invalid program argument",[$r]:"program returned invalid error code",[kr]:"invalid instruction data",[un]:"Failed to reallocate account data",[cn]:"Provided seeds do not result in a valid address",[Hn]:"Accounts data allocations exceeded the maximum allowed per transaction",[Zn]:"Max accounts exceeded",[Qn]:"Max instruction trace length exceeded",[an]:"Length of the seed is too long for address generation",[Qr]:"An account required by the instruction is missing",[Or]:"missing required signature for instruction",[Pr]:"instruction illegally modified the program id of an account",[Mr]:"insufficient account keys for instruction",[ln]:"Cross-program invocation with unauthorized signer or writable account",[gn]:"Failed to create program execution environment",[mn]:"Program failed to compile",[pn]:"Program failed to complete",[zr]:"instruction modified data of a read-only account",[Lr]:"instruction changed the balance of a read-only account",[sn]:"Cross-program invocation reentrancy not allowed for this instruction",[Ur]:"instruction modified rent epoch of an account",[Nr]:"sum of account balances before and after instruction do not match",[Tr]:"instruction requires an initialized account",[wr]:"",[Zr]:"Unsupported program id",[Mn]:"Unsupported sysvar",[yr]:"The instruction does not have any accounts.",[br]:"The instruction does not have any data.",[_r]:"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",5:"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",2:"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",[zo]:"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Do]:"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Lo]:"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Bo]:"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[s]:"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",[a]:"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",[k]:"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",[w]:"JSON-RPC error: The method does not exist / is not available ($__serverMessage)",[i]:"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",[Be]:"$__serverMessage",[ft]:"$__serverMessage",[it]:"$__serverMessage",[Ae]:"$__serverMessage",[qe]:"$__serverMessage",[$e]:"$__serverMessage",[I]:"Minimum context slot has not been reached",[rt]:"Node is unhealthy; behind by $numSlotsBehind slots",[Ye]:"No snapshot",[ht]:"Transaction simulation failed",[Je]:"$__serverMessage",[ze]:"Transaction history is not available from this node",[et]:"$__serverMessage",[Ce]:"Transaction signature length mismatch",[ot]:"Transaction signature verification failure",[we]:"$__serverMessage",[fr]:"Key pair bytes must be of length 64, got $byteLength.",[gr]:"Expected private key bytes with length 32. Actual length: $actualLength.",[pr]:"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",[mr]:"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",6:"Lamports value must be in the range [0, 2e64-1]",7:"`$value` cannot be parsed as a `BigInt`",8:"`$value` cannot be parsed as a `Number`",3:"No nonce account could be found at address `$nonceAccountAddress`",[xo]:"Either the notification name must end in 'Notifications' or the API must supply a subscription creator function for the notification '$notificationName' to map between the notification name and the subscribe/unsubscribe method names.",[To]:"Failed to obtain a subscription id from the server",[No]:"WebSocket was closed before payload could be added to the send buffer",[Po]:"WebSocket connection closed",[Co]:"WebSocket failed to connect",[Ro]:"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",[Oo]:"HTTP error ($statusCode): $message",[vo]:"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",[ti]:"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",[ri]:"The provided value does not implement the `KeyPairSigner` interface",[ii]:"The provided value does not implement the `MessageModifyingSigner` interface",[oi]:"The provided value does not implement the `MessagePartialSigner` interface",[ni]:"The provided value does not implement any of the `MessageSigner` interfaces",[ai]:"The provided value does not implement the `TransactionModifyingSigner` interface",[ci]:"The provided value does not implement the `TransactionPartialSigner` interface",[ui]:"The provided value does not implement the `TransactionSendingSigner` interface",[si]:"The provided value does not implement any of the `TransactionSigner` interfaces",[di]:"More than one `TransactionSendingSigner` was identified.",[li]:"No `TransactionSendingSigner` was identified. Please provide a valid `ITransactionWithSingleSendingSigner` transaction.",[ar]:"No digest implementation could be found.",[sr]:"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",[cr]:"This runtime does not support the generation of Ed25519 key pairs.\n\nInstall and import `@solana/webcrypto-ed25519-polyfill` before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",[ur]:"No signature verification implementation could be found.",[dr]:"No key generation implementation could be found.",[lr]:"No signing implementation could be found.",[hr]:"No key export implementation could be found.",9:"Timestamp value must be in the range [-8.64e15, 8.64e15]. `$value` given",[qi]:"Transaction processing left an account with an outstanding borrowed reference",[Oi]:"Account in use",[xi]:"Account loaded twice",[Ti]:"Attempt to debit an account but found no record of a prior credit.",[Ji]:"Transaction loads an address table account that doesn't exist",[Bi]:"This transaction has already been processed",[Li]:"Blockhash not found",[zi]:"Loader call chain is too deep",[Wi]:"Transactions are currently disabled due to cluster maintenance",[no]:"Transaction contains a duplicate instruction ($index) that is not allowed",[Pi]:"Insufficient funds for fee",[io]:"Transaction results in an account ($accountIndex) with insufficient funds for rent",[Ci]:"This account may not be used to pay transaction fees",[Ki]:"Transaction contains an invalid account reference",[Xi]:"Transaction loads an address table account with invalid data",[Qi]:"Transaction address table lookup uses an invalid index",[Zi]:"Transaction loads an address table account with an invalid owner",[so]:"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",[Mi]:"This program may not be used for executing instructions",[eo]:"Transaction leaves an account with a lower balance than rent-exempt minimum",[Hi]:"Transaction loads a writable account that cannot be written",[oo]:"Transaction exceeded max loaded accounts data size cap",[Di]:"Transaction requires a fee but has no signature present",[Ni]:"Attempt to load a program that does not exist",[co]:"Execution of the program referenced by account at index $accountIndex is temporarily restricted.",[ao]:"ResanitizationNeeded",[Fi]:"Transaction failed to sanitize accounts offsets correctly",[Ui]:"Transaction did not pass signature verification",[Gi]:"Transaction locked too many accounts",[uo]:"Sum of account balances before and after transaction do not match",[vi]:"The transaction failed with the error `$errorName`",[ji]:"Transaction version is unsupported",[Yi]:"Transaction would exceed account data limit within the block",[ro]:"Transaction would exceed total account data limit",[$i]:"Transaction would exceed max account limit within the block",[Vi]:"Transaction would exceed max Block Cost Limit",[to]:"Transaction would exceed max Vote Cost Limit",[Ei]:"Transaction is missing an address at index: $index.",[gi]:"Transaction does not have a blockhash lifetime",[pi]:"Transaction is not a durable nonce transaction",[yi]:"Contents of these address lookup tables unknown: $lookupTableAddresses",[bi]:"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",[wi]:"No fee payer set in CompiledTransaction",[_i]:"Could not find program address at index $index",[ki]:"Transaction is missing a fee payer.",[Ai]:"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",[Ri]:"Transaction first instruction is not advance nonce account instruction.",[Ii]:"Transaction with no instructions cannot be durable nonce transaction.",[hi]:"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",[fi]:"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",[Si]:"Transaction is missing signatures for addresses: $addresses.",[mi]:"Transaction version must be in the range [0, 127]. `$actualVersion` given"};function encodeValue(e){return Array.isArray(e)?"%5B"+e.map((e=>"string"==typeof e?encodeURIComponent(`"${e.replace(/"/g,'\\"')}"`):encodeValue(e))).join("%2C%20")+"%5D":"bigint"==typeof e?`${e}n`:encodeURIComponent(String(null!=e&&null===Object.getPrototypeOf(e)?{...e}:e))}function encodeObjectContextEntry([e,r]){return`${e}=${encodeValue(r)}`}function getErrorMessage(e,r={}){if(n)return function getHumanReadableErrorMessage(e,r={}){return Ko[e].replace(/(?<!\\)\$(\w+)/g,((e,n)=>n in r?`${r[n]}`:e))}(e,r);{let n=`Solana error #${e}; Decode this error by running \`npx @solana/errors decode ${e}`;return Object.keys(r).length&&(n+=` $"${function encodeContextObject(e){return Object.entries(e).map(encodeObjectContextEntry).join("&")}(r)}"`),`${n}\``}}var Uo=class extends Error{context;constructor(...[e,r]){let n,i;if(r){const{cause:e,...s}=r;e&&(i={cause:e}),Object.keys(s).length>0&&(n=s)}super(getErrorMessage(e,n),i),this.context={__code:e,...n},this.name="SolanaError"}};function safeCaptureStackTrace(...e){"captureStackTrace"in Error&&"function"==typeof Error.captureStackTrace&&Error.captureStackTrace(...e)}function getSolanaErrorFromRpcError({errorCodeBaseOffset:e,getErrorContext:r,orderedErrorNames:n,rpcEnumError:i},s){let a,w;"string"==typeof i?a=i:(a=Object.keys(i)[0],w=i[a]);const k=e+n.indexOf(a),I=r(k,a,w),we=new Uo(k,I);return safeCaptureStackTrace(we,s),we}var Mo=["GenericError","InvalidArgument","InvalidInstructionData","InvalidAccountData","AccountDataTooSmall","InsufficientFunds","IncorrectProgramId","MissingRequiredSignature","AccountAlreadyInitialized","UninitializedAccount","UnbalancedInstruction","ModifiedProgramId","ExternalAccountLamportSpend","ExternalAccountDataModified","ReadonlyLamportChange","ReadonlyDataModified","DuplicateAccountIndex","ExecutableModified","RentEpochModified","NotEnoughAccountKeys","AccountDataSizeChanged","AccountNotExecutable","AccountBorrowFailed","AccountBorrowOutstanding","DuplicateAccountOutOfSync","Custom","InvalidError","ExecutableDataModified","ExecutableLamportChange","ExecutableAccountNotRentExempt","UnsupportedProgramId","CallDepth","MissingAccount","ReentrancyNotAllowed","MaxSeedLengthExceeded","InvalidSeeds","InvalidRealloc","ComputationalBudgetExceeded","PrivilegeEscalation","ProgramEnvironmentSetupFailure","ProgramFailedToComplete","ProgramFailedToCompile","Immutable","IncorrectAuthority","BorshIoError","AccountNotRentExempt","InvalidAccountOwner","ArithmeticOverflow","UnsupportedSysvar","IllegalOwner","MaxAccountsDataAllocationsExceeded","MaxAccountsExceeded","MaxInstructionTraceLengthExceeded","BuiltinProgramsMustConsumeComputeUnits"];function getSolanaErrorFromInstructionError(e,r){return getSolanaErrorFromRpcError({errorCodeBaseOffset:4615001,getErrorContext:(r,n,i)=>r===wr?{errorName:n,index:e,...void 0!==i?{instructionErrorContext:i}:null}:r===Hr?{code:i,index:e}:r===kn?{encodedData:i,index:e}:{index:e},orderedErrorNames:Mo,rpcEnumError:r},getSolanaErrorFromInstructionError)}var Fo=["AccountInUse","AccountLoadedTwice","AccountNotFound","ProgramAccountNotFound","InsufficientFundsForFee","InvalidAccountForFee","AlreadyProcessed","BlockhashNotFound","CallChainTooDeep","MissingSignatureForFee","InvalidAccountIndex","SignatureFailure","InvalidProgramForExecution","SanitizeFailure","ClusterMaintenance","AccountBorrowOutstanding","WouldExceedMaxBlockCostLimit","UnsupportedVersion","InvalidWritableAccount","WouldExceedMaxAccountCostLimit","WouldExceedAccountDataBlockLimit","TooManyAccountLocks","AddressLookupTableNotFound","InvalidAddressLookupTableOwner","InvalidAddressLookupTableData","InvalidAddressLookupTableIndex","InvalidRentPayingAccount","WouldExceedMaxVoteCostLimit","WouldExceedAccountDataTotalLimit","DuplicateInstruction","InsufficientFundsForRent","MaxLoadedAccountsDataSizeExceeded","InvalidLoadedAccountsDataSizeLimit","ResanitizationNeeded","ProgramExecutionTemporarilyRestricted","UnbalancedTransaction"];function getSolanaErrorFromTransactionError(e){return"object"==typeof e&&"InstructionError"in e?getSolanaErrorFromInstructionError(...e.InstructionError):getSolanaErrorFromRpcError({errorCodeBaseOffset:7050001,getErrorContext:(e,r,n)=>e===vi?{errorName:r,...void 0!==n?{transactionErrorContext:n}:null}:e===no?{index:n}:e===io||e===co?{accountIndex:n.account_index}:void 0,orderedErrorNames:Fo,rpcEnumError:e},getSolanaErrorFromTransactionError)}r.SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND=tr,r.SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED=or,r.SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT=ir,r.SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT=nr,r.SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND=rr,r.SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED=Qt,r.SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS=_t,r.SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH=pt,r.SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY=St,r.SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE=Gt,r.SOLANA_ERROR__ADDRESSES__MALFORMED_PDA=kt,r.SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED=Mt,r.SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED=qt,r.SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE=Dt,r.SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER=er,r.SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE=yt,r.SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE=4,r.SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED=1,r.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY=lo,r.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH=mo,r.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH=yo,r.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH=po,r.SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE=_o,r.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH=fo,r.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH=Ao,r.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH=go,r.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH=ho,r.SOLANA_ERROR__CODECS__INVALID_DATA_ENUM_VARIANT=wo,r.SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS=bo,r.SOLANA_ERROR__CODECS__INVALID_SCALAR_ENUM_VARIANT=So,r.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE=ko,r.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE=Eo,r.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE=Io,r.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED=xr,r.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED=qr,r.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING=Vr,r.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED=Fr,r.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL=Ir,r.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE=Wr,r.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT=In,r.SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW=Bn,r.SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR=kn,r.SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS=ei,r.SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH=Xr,r.SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED=dn,r.SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM=Hr,r.SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX=Dr,r.SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC=jr,r.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT=Jr,r.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED=Yr,r.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE=Gr,r.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED=Kr,r.SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED=Br,r.SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND=Cr,r.SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR=Sr,r.SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER=Wn,r.SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE=yn,r.SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY=bn,r.SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID=vr,r.SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS=Rr,r.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA=Ar,r.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER=Cn,r.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT=Er,r.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR=$r,r.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA=kr,r.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC=un,r.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS=cn,r.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED=Hn,r.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED=Zn,r.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED=Qn,r.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED=an,r.SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT=Qr,r.SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE=Or,r.SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID=Pr,r.SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS=Mr,r.SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION=ln,r.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE=gn,r.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE=mn,r.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE=pn,r.SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED=zr,r.SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE=Lr,r.SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED=sn,r.SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED=Ur,r.SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION=Nr,r.SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT=Tr,r.SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN=wr,r.SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID=Zr,r.SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR=Mn,r.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS=yr,r.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA=br,r.SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH=_r,r.SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH=5,r.SOLANA_ERROR__INVALID_NONCE=2,r.SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING=zo,r.SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE=Do,r.SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE=Lo,r.SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING=Bo,r.SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR=s,r.SOLANA_ERROR__JSON_RPC__INVALID_PARAMS=a,r.SOLANA_ERROR__JSON_RPC__INVALID_REQUEST=k,r.SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND=w,r.SOLANA_ERROR__JSON_RPC__PARSE_ERROR=i,r.SOLANA_ERROR__JSON_RPC__SCAN_ERROR=Be,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP=ft,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE=it,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET=Ae,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX=qe,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED=$e,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED=I,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY=rt,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT=Ye,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE=ht,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED=Je,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE=ze,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE=et,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH=Ce,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE=ot,r.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION=we,r.SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH=fr,r.SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH=gr,r.SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH=pr,r.SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE=mr,r.SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE=6,r.SOLANA_ERROR__MALFORMED_BIGINT_STRING=7,r.SOLANA_ERROR__MALFORMED_NUMBER_STRING=8,r.SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND=3,r.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST=xo,r.SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID=To,r.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED=No,r.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED=Po,r.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT=Co,r.SOLANA_ERROR__RPC__INTEGER_OVERFLOW=Ro,r.SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR=Oo,r.SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN=vo,r.SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS=ti,r.SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER=ri,r.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER=ii,r.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER=oi,r.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER=ni,r.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER=ai,r.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER=ci,r.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER=ui,r.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER=si,r.SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS=di,r.SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING=li,r.SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED=ar,r.SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT=sr,r.SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED=cr,r.SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED=ur,r.SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED=dr,r.SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED=lr,r.SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED=hr,r.SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE=9,r.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING=qi,r.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE=Oi,r.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE=xi,r.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND=Ti,r.SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND=Ji,r.SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED=Bi,r.SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND=Li,r.SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP=zi,r.SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE=Wi,r.SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION=no,r.SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE=Pi,r.SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT=io,r.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE=Ci,r.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX=Ki,r.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA=Xi,r.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX=Qi,r.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER=Zi,r.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT=so,r.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION=Mi,r.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT=eo,r.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT=Hi,r.SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED=oo,r.SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE=Di,r.SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND=Ni,r.SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED=co,r.SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED=ao,r.SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE=Fi,r.SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE=Ui,r.SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS=Gi,r.SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION=uo,r.SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN=vi,r.SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION=ji,r.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT=Yi,r.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT=ro,r.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT=$i,r.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT=Vi,r.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT=to,r.SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING=Ei,r.SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME=gi,r.SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME=pi,r.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING=yi,r.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE=bi,r.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING=wi,r.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND=_i,r.SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING=ki,r.SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING=Ai,r.SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE=Ri,r.SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING=Ii,r.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES=hi,r.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE=fi,r.SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING=Si,r.SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE=mi,r.SolanaError=Uo,r.getSolanaErrorFromInstructionError=getSolanaErrorFromInstructionError,r.getSolanaErrorFromJsonRpcError=function getSolanaErrorFromJsonRpcError({code:e,data:r,message:n}){let I;if(e===ht){const{err:e,...n}=r,i=e?{cause:getSolanaErrorFromTransactionError(e)}:null;I=new Uo(ht,{...n,...i})}else{let Ce;switch(e){case s:case a:case k:case w:case i:case Be:case ft:case it:case Ae:case qe:case $e:case Je:case et:case we:Ce={__serverMessage:n};break;default:"object"!=typeof r||Array.isArray(r)||(Ce=r)}I=new Uo(e,Ce)}return safeCaptureStackTrace(I,getSolanaErrorFromJsonRpcError),I},r.getSolanaErrorFromTransactionError=getSolanaErrorFromTransactionError,r.isSolanaError=function isSolanaError(e,r){return!!(e instanceof Error&&"SolanaError"===e.name)&&(void 0===r||e.context.__code===r)},r.safeCaptureStackTrace=safeCaptureStackTrace},414014:(e,r,n)=>{var i=n(268117),s=n(701536),some=e=>({__option:"Some",value:e}),none=()=>({__option:"None"}),isOption=e=>!!(e&&"object"==typeof e&&"__option"in e&&("Some"===e.__option&&"value"in e||"None"===e.__option)),isSome=e=>"Some"===e.__option;var wrapNullable=e=>null!==e?some(e):none();function getOptionEncoder(e,r={}){const n=r.prefix??s.getU8Encoder(),a=r.fixed??!1,w=i.isFixedSize(e)&&i.isFixedSize(n)&&0===e.fixedSize;if(a||w){i.assertIsFixedSize(e),i.assertIsFixedSize(n);const r=n.fixedSize+e.fixedSize;return i.createEncoder({fixedSize:r,write:(i,s,a)=>{const w=isOption(i)?i:wrapNullable(i),k=n.write(Number(isSome(w)),s,a);return isSome(w)&&e.write(w.value,s,k),a+r}})}return i.createEncoder({getSizeFromValue:r=>{const s=isOption(r)?r:wrapNullable(r);return i.getEncodedSize(Number(isSome(s)),n)+(isSome(s)?i.getEncodedSize(s.value,e):0)},maxSize:sumCodecSizes([n,e].map(getMaxSize))??void 0,write:(r,i,s)=>{const a=isOption(r)?r:wrapNullable(r);return s=n.write(Number(isSome(a)),i,s),isSome(a)&&(s=e.write(a.value,i,s)),s}})}function getOptionDecoder(e,r={}){const n=r.prefix??s.getU8Decoder(),a=r.fixed??!1;let w=null;const k=i.isFixedSize(e)&&i.isFixedSize(n)&&0===e.fixedSize;return(a||k)&&(i.assertIsFixedSize(e),i.assertIsFixedSize(n),w=n.fixedSize+e.fixedSize),i.createDecoder({...null===w?{maxSize:sumCodecSizes([n,e].map(getMaxSize))??void 0}:{fixedSize:w},read:(r,i)=>{if(r.length-i<=0)return[none(),i];const[s,a]=n.read(r,i);if(0===s)return[none(),null!==w?i+w:a];const[k,I]=e.read(r,a);return[some(k),null!==w?i+w:I]}})}function sumCodecSizes(e){return e.reduce(((e,r)=>null===e||null===r?null:e+r),0)}function getMaxSize(e){return i.isFixedSize(e)?e.fixedSize:e.maxSize??null}r.getOptionCodec=function getOptionCodec(e,r={}){return i.combineCodec(getOptionEncoder(e,r),getOptionDecoder(e,r))},r.getOptionDecoder=getOptionDecoder,r.getOptionEncoder=getOptionEncoder,r.isNone=e=>"None"===e.__option,r.isOption=isOption,r.isSome=isSome,r.none=none,r.some=some,r.unwrapOption=function unwrapOption(e,r){return isSome(e)?e.value:r?r():null},r.unwrapOptionRecursively=function unwrapOptionRecursively(e,r){if(!e||ArrayBuffer.isView(e))return e;const next=e=>r?unwrapOptionRecursively(e,r):unwrapOptionRecursively(e);return isOption(e)?isSome(e)?next(e.value):r?r():null:Array.isArray(e)?e.map(next):"object"==typeof e?Object.fromEntries(Object.entries(e).map((([e,r])=>[e,next(r)]))):e},r.wrapNullable=wrapNullable},595055:(e,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.TlvInvalidAccountDataError=r.TlvError=void 0;class TlvError extends Error{constructor(e){super(e)}}r.TlvError=TlvError;r.TlvInvalidAccountDataError=class TlvInvalidAccountDataError extends TlvError{constructor(){super(...arguments),this.name="TlvInvalidAccountDataError"}}},258858:function(e,r,n){var i=this&&this.__createBinding||(Object.create?function(e,r,n,i){void 0===i&&(i=n);var s=Object.getOwnPropertyDescriptor(r,n);s&&!("get"in s?!r.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return r[n]}}),Object.defineProperty(e,i,s)}:function(e,r,n,i){void 0===i&&(i=n),e[i]=r[n]}),s=this&&this.__exportStar||function(e,r){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(r,n)||i(r,e,n)};Object.defineProperty(r,"__esModule",{value:!0}),s(n(788715),r),s(n(696975),r),s(n(595055),r)},788715:(e,r,n)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.splDiscriminate=void 0;const i=n(483040);r.splDiscriminate=(e,r=8)=>(0,i.createHash)("sha256").update(e).digest().subarray(0,r)},696975:(e,r,n)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.TlvState=void 0;const i=n(595055);r.TlvState=class TlvState{constructor(e,r=2,n=2,i=0){this.tlvData=e.subarray(i),this.discriminatorSize=r,this.lengthSize=n}get data(){return this.tlvData}readEntryLength(e,r,n){switch(e){case 1:return n(this.tlvData.readUInt8(r));case 2:return n(this.tlvData.readUInt16LE(r));case 4:return n(this.tlvData.readUInt32LE(r));case 8:return n(this.tlvData.readBigUInt64LE(r))}}firstBytes(e){const r=this.bytesRepeating(e,1);return r.length>0?r[0]:null}bytesRepeating(e,r=0){const n=[];let s=0;for(;s<this.tlvData.length;){if(s+this.discriminatorSize+this.lengthSize>this.tlvData.length)throw new i.TlvInvalidAccountDataError;const a=this.tlvData.subarray(s,s+this.discriminatorSize);s+=this.discriminatorSize;const w=this.readEntryLength(this.lengthSize,s,Number);if(s+=this.lengthSize,s+w>this.tlvData.length)throw new i.TlvInvalidAccountDataError;if(a.equals(e)&&n.push(this.tlvData.subarray(s,s+w)),r>0&&n.length>=r)break;s+=w}return n}discriminators(){const e=[];let r=0;for(;r<this.tlvData.length;){if(r+this.discriminatorSize+this.lengthSize>this.tlvData.length)throw new i.TlvInvalidAccountDataError;const n=this.tlvData.subarray(r,r+this.discriminatorSize);e.push(n),r+=this.discriminatorSize;const s=this.readEntryLength(this.lengthSize,r,Number);if(r+=this.lengthSize,r+s>this.tlvData.length)throw new i.TlvInvalidAccountDataError;r+=s}return e}}},264142:(e,r,n)=>{n.d(r,{EK:()=>a,x5:()=>s});var i=n(398532);const s=new i.J3("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),a=(new i.J3("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),new i.J3("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"));new i.J3("So11111111111111111111111111111111111111112"),new i.J3("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP")},375236:(e,r,n)=>{n.d(r,{JK:()=>TokenInvalidInstructionProgramError,LQ:()=>TokenInvalidInstructionDataError,lu:()=>TokenOwnerOffCurveError,p7:()=>TokenInvalidInstructionTypeError,rO:()=>TokenInvalidInstructionKeysError});class TokenError extends Error{constructor(e){super(e)}}class TokenOwnerOffCurveError extends TokenError{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}}class TokenInvalidInstructionProgramError extends TokenError{constructor(){super(...arguments),this.name="TokenInvalidInstructionProgramError"}}class TokenInvalidInstructionKeysError extends TokenError{constructor(){super(...arguments),this.name="TokenInvalidInstructionKeysError"}}class TokenInvalidInstructionDataError extends TokenError{constructor(){super(...arguments),this.name="TokenInvalidInstructionDataError"}}class TokenInvalidInstructionTypeError extends TokenError{constructor(){super(...arguments),this.name="TokenInvalidInstructionTypeError"}}},25047:(e,r,n)=>{n.d(r,{JA:()=>createAssociatedTokenAccountInstruction});var i=n(398532),s=n(264142),a=n(901048).Buffer;function createAssociatedTokenAccountInstruction(e,r,n,i,w=s.x5,k=s.EK){return buildAssociatedTokenAccountInstruction(e,r,n,i,a.alloc(0),w,k)}function buildAssociatedTokenAccountInstruction(e,r,n,a,w,k=s.x5,I=s.EK){const we=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:i.yq.programId,isSigner:!1,isWritable:!1},{pubkey:k,isSigner:!1,isWritable:!1}];return new i.fH({keys:we,programId:I,data:w})}},340758:(e,r,n)=>{n.d(r,{pK:()=>decodeInstruction});var i=n(878918),s=n(264142),a=n(375236),w=n(692363),k=(n(398532),n(749064));n(901048).Buffer;const I=(0,i.struct)([(0,i.u8)("instruction"),(0,w._l)("amount")]);function decodeAmountToUiAmountInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==I.span)throw new a.LQ;const{keys:{mint:n},data:i}=function decodeAmountToUiAmountInstructionUnchecked({programId:e,keys:[r],data:n}){return{programId:e,keys:{mint:r},data:I.decode(n)}}(e);if(i.instruction!==k._.AmountToUiAmount)throw new a.p7;if(!n)throw new a.rO;return{programId:r,keys:{mint:n},data:i}}n(901048).Buffer;const we=(0,i.struct)([(0,i.u8)("instruction"),(0,w._l)("amount")]);function decodeApproveInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==we.span)throw new a.LQ;const{keys:{account:n,delegate:i,owner:w,multiSigners:I},data:Ae}=function decodeApproveInstructionUnchecked({programId:e,keys:[r,n,i,...s],data:a}){return{programId:e,keys:{account:r,delegate:n,owner:i,multiSigners:s},data:we.decode(a)}}(e);if(Ae.instruction!==k._.Approve)throw new a.p7;if(!n||!i||!w)throw new a.rO;return{programId:r,keys:{account:n,delegate:i,owner:w,multiSigners:I},data:Ae}}n(901048).Buffer;const Ae=(0,i.struct)([(0,i.u8)("instruction"),(0,w._l)("amount"),(0,i.u8)("decimals")]);function decodeApproveCheckedInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==Ae.span)throw new a.LQ;const{keys:{account:n,mint:i,delegate:w,owner:I,multiSigners:we},data:Ce}=function decodeApproveCheckedInstructionUnchecked({programId:e,keys:[r,n,i,s,...a],data:w}){return{programId:e,keys:{account:r,mint:n,delegate:i,owner:s,multiSigners:a},data:Ae.decode(w)}}(e);if(Ce.instruction!==k._.ApproveChecked)throw new a.p7;if(!(n&&i&&w&&I))throw new a.rO;return{programId:r,keys:{account:n,mint:i,delegate:w,owner:I,multiSigners:we},data:Ce}}n(901048).Buffer;const Ce=(0,i.struct)([(0,i.u8)("instruction"),(0,w._l)("amount")]);function decodeBurnInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==Ce.span)throw new a.LQ;const{keys:{account:n,mint:i,owner:w,multiSigners:I},data:we}=function decodeBurnInstructionUnchecked({programId:e,keys:[r,n,i,...s],data:a}){return{programId:e,keys:{account:r,mint:n,owner:i,multiSigners:s},data:Ce.decode(a)}}(e);if(we.instruction!==k._.Burn)throw new a.p7;if(!n||!i||!w)throw new a.rO;return{programId:r,keys:{account:n,mint:i,owner:w,multiSigners:I},data:we}}n(901048).Buffer;const Be=(0,i.struct)([(0,i.u8)("instruction"),(0,w._l)("amount"),(0,i.u8)("decimals")]);function decodeBurnCheckedInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==Be.span)throw new a.LQ;const{keys:{account:n,mint:i,owner:w,multiSigners:I},data:we}=function decodeBurnCheckedInstructionUnchecked({programId:e,keys:[r,n,i,...s],data:a}){return{programId:e,keys:{account:r,mint:n,owner:i,multiSigners:s},data:Be.decode(a)}}(e);if(we.instruction!==k._.BurnChecked)throw new a.p7;if(!n||!i||!w)throw new a.rO;return{programId:r,keys:{account:n,mint:i,owner:w,multiSigners:I},data:we}}n(901048).Buffer;const ze=(0,i.struct)([(0,i.u8)("instruction")]);function decodeCloseAccountInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==ze.span)throw new a.LQ;const{keys:{account:n,destination:i,authority:w,multiSigners:I},data:we}=function decodeCloseAccountInstructionUnchecked({programId:e,keys:[r,n,i,...s],data:a}){return{programId:e,keys:{account:r,destination:n,authority:i,multiSigners:s},data:ze.decode(a)}}(e);if(we.instruction!==k._.CloseAccount)throw new a.p7;if(!n||!i||!w)throw new a.rO;return{programId:r,keys:{account:n,destination:i,authority:w,multiSigners:I},data:we}}n(901048).Buffer;const qe=(0,i.struct)([(0,i.u8)("instruction")]);function decodeFreezeAccountInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==qe.span)throw new a.LQ;const{keys:{account:n,mint:i,authority:w,multiSigners:I},data:we}=function decodeFreezeAccountInstructionUnchecked({programId:e,keys:[r,n,i,...s],data:a}){return{programId:e,keys:{account:r,mint:n,authority:i,multiSigners:s},data:qe.decode(a)}}(e);if(we.instruction!==k._.FreezeAccount)throw new a.p7;if(!n||!i||!w)throw new a.rO;return{programId:r,keys:{account:n,mint:i,authority:w,multiSigners:I},data:we}}n(901048).Buffer;const $e=(0,i.struct)([(0,i.u8)("instruction")]);function decodeInitializeAccountInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==$e.span)throw new a.LQ;const{keys:{account:n,mint:i,owner:w,rent:I},data:we}=function decodeInitializeAccountInstructionUnchecked({programId:e,keys:[r,n,i,s],data:a}){return{programId:e,keys:{account:r,mint:n,owner:i,rent:s},data:$e.decode(a)}}(e);if(we.instruction!==k._.InitializeAccount)throw new a.p7;if(!(n&&i&&w&&I))throw new a.rO;return{programId:r,keys:{account:n,mint:i,owner:w,rent:I},data:we}}n(901048).Buffer;const Ye=(0,i.struct)([(0,i.u8)("instruction"),(0,w.jE)("owner")]);function decodeInitializeAccount2Instruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==Ye.span)throw new a.LQ;const{keys:{account:n,mint:i,rent:w},data:I}=function decodeInitializeAccount2InstructionUnchecked({programId:e,keys:[r,n,i],data:s}){return{programId:e,keys:{account:r,mint:n,rent:i},data:Ye.decode(s)}}(e);if(I.instruction!==k._.InitializeAccount2)throw new a.p7;if(!n||!i||!w)throw new a.rO;return{programId:r,keys:{account:n,mint:i,rent:w},data:I}}n(901048).Buffer;const Je=(0,i.struct)([(0,i.u8)("instruction"),(0,w.jE)("owner")]);function decodeInitializeAccount3Instruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==Je.span)throw new a.LQ;const{keys:{account:n,mint:i},data:w}=function decodeInitializeAccount3InstructionUnchecked({programId:e,keys:[r,n],data:i}){return{programId:e,keys:{account:r,mint:n},data:Je.decode(i)}}(e);if(w.instruction!==k._.InitializeAccount3)throw new a.p7;if(!n||!i)throw new a.rO;return{programId:r,keys:{account:n,mint:i},data:w}}n(901048).Buffer;const et=(0,i.struct)([(0,i.u8)("instruction"),(0,i.u8)("decimals"),(0,w.jE)("mintAuthority"),(0,i.u8)("freezeAuthorityOption"),(0,w.jE)("freezeAuthority")]);function decodeInitializeMintInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==et.span)throw new a.LQ;const{keys:{mint:n,rent:i},data:w}=function decodeInitializeMintInstructionUnchecked({programId:e,keys:[r,n],data:i}){const{instruction:s,decimals:a,mintAuthority:w,freezeAuthorityOption:k,freezeAuthority:I}=et.decode(i);return{programId:e,keys:{mint:r,rent:n},data:{instruction:s,decimals:a,mintAuthority:w,freezeAuthority:k?I:null}}}(e);if(w.instruction!==k._.InitializeMint)throw new a.p7;if(!n||!i)throw new a.rO;return{programId:r,keys:{mint:n,rent:i},data:w}}n(901048).Buffer;const rt=(0,i.struct)([(0,i.u8)("instruction"),(0,i.u8)("decimals"),(0,w.jE)("mintAuthority"),(0,i.u8)("freezeAuthorityOption"),(0,w.jE)("freezeAuthority")]);function decodeInitializeMint2Instruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==rt.span)throw new a.LQ;const{keys:{mint:n},data:i}=function decodeInitializeMint2InstructionUnchecked({programId:e,keys:[r],data:n}){const{instruction:i,decimals:s,mintAuthority:a,freezeAuthorityOption:w,freezeAuthority:k}=rt.decode(n);return{programId:e,keys:{mint:r},data:{instruction:i,decimals:s,mintAuthority:a,freezeAuthority:w?k:null}}}(e);if(i.instruction!==k._.InitializeMint2)throw new a.p7;if(!n)throw new a.rO;return{programId:r,keys:{mint:n},data:i}}n(901048).Buffer;const it=(0,i.struct)([(0,i.u8)("instruction"),(0,i.u8)("m")]);function decodeInitializeMultisigInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==it.span)throw new a.LQ;const{keys:{account:n,rent:i,signers:w},data:I}=function decodeInitializeMultisigInstructionUnchecked({programId:e,keys:[r,n,...i],data:s}){return{programId:e,keys:{account:r,rent:n,signers:i},data:it.decode(s)}}(e);if(I.instruction!==k._.InitializeMultisig)throw new a.p7;if(!n||!i||!w.length)throw new a.rO;return{programId:r,keys:{account:n,rent:i,signers:w},data:I}}n(901048).Buffer;const ot=(0,i.struct)([(0,i.u8)("instruction"),(0,w._l)("amount")]);function decodeMintToInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==ot.span)throw new a.LQ;const{keys:{mint:n,destination:i,authority:w,multiSigners:I},data:we}=function decodeMintToInstructionUnchecked({programId:e,keys:[r,n,i,...s],data:a}){return{programId:e,keys:{mint:r,destination:n,authority:i,multiSigners:s},data:ot.decode(a)}}(e);if(we.instruction!==k._.MintTo)throw new a.p7;if(!n||!i||!w)throw new a.rO;return{programId:r,keys:{mint:n,destination:i,authority:w,multiSigners:I},data:we}}n(901048).Buffer;const ht=(0,i.struct)([(0,i.u8)("instruction"),(0,w._l)("amount"),(0,i.u8)("decimals")]);function decodeMintToCheckedInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==ht.span)throw new a.LQ;const{keys:{mint:n,destination:i,authority:w,multiSigners:I},data:we}=function decodeMintToCheckedInstructionUnchecked({programId:e,keys:[r,n,i,...s],data:a}){return{programId:e,keys:{mint:r,destination:n,authority:i,multiSigners:s},data:ht.decode(a)}}(e);if(we.instruction!==k._.MintToChecked)throw new a.p7;if(!n||!i||!w)throw new a.rO;return{programId:r,keys:{mint:n,destination:i,authority:w,multiSigners:I},data:we}}n(901048).Buffer;const ft=(0,i.struct)([(0,i.u8)("instruction")]);function decodeRevokeInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==ft.span)throw new a.LQ;const{keys:{account:n,owner:i,multiSigners:w},data:I}=function decodeRevokeInstructionUnchecked({programId:e,keys:[r,n,...i],data:s}){return{programId:e,keys:{account:r,owner:n,multiSigners:i},data:ft.decode(s)}}(e);if(I.instruction!==k._.Revoke)throw new a.p7;if(!n||!i)throw new a.rO;return{programId:r,keys:{account:n,owner:i,multiSigners:w},data:I}}var pt;n(901048).Buffer;!function(e){e[e.MintTokens=0]="MintTokens",e[e.FreezeAccount=1]="FreezeAccount",e[e.AccountOwner=2]="AccountOwner",e[e.CloseAccount=3]="CloseAccount",e[e.TransferFeeConfig=4]="TransferFeeConfig",e[e.WithheldWithdraw=5]="WithheldWithdraw",e[e.CloseMint=6]="CloseMint",e[e.InterestRate=7]="InterestRate",e[e.PermanentDelegate=8]="PermanentDelegate",e[e.ConfidentialTransferMint=9]="ConfidentialTransferMint",e[e.TransferHookProgramId=10]="TransferHookProgramId",e[e.ConfidentialTransferFeeConfig=11]="ConfidentialTransferFeeConfig",e[e.MetadataPointer=12]="MetadataPointer"}(pt||(pt={}));const yt=(0,i.struct)([(0,i.u8)("instruction"),(0,i.u8)("authorityType"),(0,i.u8)("newAuthorityOption"),(0,w.jE)("newAuthority")]);function decodeSetAuthorityInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==yt.span)throw new a.LQ;const{keys:{account:n,currentAuthority:i,multiSigners:w},data:I}=function decodeSetAuthorityInstructionUnchecked({programId:e,keys:[r,n,...i],data:s}){const{instruction:a,authorityType:w,newAuthorityOption:k,newAuthority:I}=yt.decode(s);return{programId:e,keys:{account:r,currentAuthority:n,multiSigners:i},data:{instruction:a,authorityType:w,newAuthority:k?I:null}}}(e);if(I.instruction!==k._.SetAuthority)throw new a.p7;if(!n||!i)throw new a.rO;return{programId:r,keys:{account:n,currentAuthority:i,multiSigners:w},data:I}}n(901048).Buffer;const _t=(0,i.struct)([(0,i.u8)("instruction")]);function decodeSyncNativeInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==_t.span)throw new a.LQ;const{keys:{account:n},data:i}=function decodeSyncNativeInstructionUnchecked({programId:e,keys:[r],data:n}){return{programId:e,keys:{account:r},data:_t.decode(n)}}(e);if(i.instruction!==k._.SyncNative)throw new a.p7;if(!n)throw new a.rO;return{programId:r,keys:{account:n},data:i}}n(901048).Buffer;const St=(0,i.struct)([(0,i.u8)("instruction")]);function decodeThawAccountInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;if(e.data.length!==St.span)throw new a.LQ;const{keys:{account:n,mint:i,authority:w,multiSigners:I},data:we}=function decodeThawAccountInstructionUnchecked({programId:e,keys:[r,n,i,...s],data:a}){return{programId:e,keys:{account:r,mint:n,authority:i,multiSigners:s},data:St.decode(a)}}(e);if(we.instruction!==k._.ThawAccount)throw new a.p7;if(!n||!i||!w)throw new a.rO;return{programId:r,keys:{account:n,mint:i,authority:w,multiSigners:I},data:we}}var kt=n(353594),Dt=n(302407);n(901048).Buffer;function decodeUiAmountToAmountInstruction(e,r=s.x5){if(!e.programId.equals(r))throw new a.JK;const n=(0,i.struct)([(0,i.u8)("instruction"),(0,i.blob)(e.data.length-1,"amount")]);if(e.data.length!==n.span)throw new a.LQ;const{keys:{mint:w},data:I}=function decodeUiAmountToAmountInstructionUnchecked({programId:e,keys:[r],data:n}){const s=(0,i.struct)([(0,i.u8)("instruction"),(0,i.blob)(n.length-1,"amount")]);return{programId:e,keys:{mint:r},data:s.decode(n)}}(e);if(I.instruction!==k._.UiAmountToAmount)throw new a.p7;if(!w)throw new a.rO;return{programId:r,keys:{mint:w},data:I}}function decodeInstruction(e,r=s.x5){if(!e.data.length)throw new a.LQ;const n=(0,i.u8)().decode(e.data);if(n===k._.InitializeMint)return decodeInitializeMintInstruction(e,r);if(n===k._.InitializeAccount)return decodeInitializeAccountInstruction(e,r);if(n===k._.InitializeMultisig)return decodeInitializeMultisigInstruction(e,r);if(n===k._.Transfer)return(0,kt.SC)(e,r);if(n===k._.Approve)return decodeApproveInstruction(e,r);if(n===k._.Revoke)return decodeRevokeInstruction(e,r);if(n===k._.SetAuthority)return decodeSetAuthorityInstruction(e,r);if(n===k._.MintTo)return decodeMintToInstruction(e,r);if(n===k._.Burn)return decodeBurnInstruction(e,r);if(n===k._.CloseAccount)return decodeCloseAccountInstruction(e,r);if(n===k._.FreezeAccount)return decodeFreezeAccountInstruction(e,r);if(n===k._.ThawAccount)return decodeThawAccountInstruction(e,r);if(n===k._.TransferChecked)return(0,Dt.Ly)(e,r);if(n===k._.ApproveChecked)return decodeApproveCheckedInstruction(e,r);if(n===k._.MintToChecked)return decodeMintToCheckedInstruction(e,r);if(n===k._.BurnChecked)return decodeBurnCheckedInstruction(e,r);if(n===k._.InitializeAccount2)return decodeInitializeAccount2Instruction(e,r);if(n===k._.SyncNative)return decodeSyncNativeInstruction(e,r);if(n===k._.InitializeAccount3)return decodeInitializeAccount3Instruction(e,r);if(n===k._.InitializeMint2)return decodeInitializeMint2Instruction(e,r);if(n===k._.AmountToUiAmount)return decodeAmountToUiAmountInstruction(e,r);if(n===k._.UiAmountToAmount)return decodeUiAmountToAmountInstruction(e,r);if(n===k._.InitializeMultisig2)throw new a.p7;throw new a.p7}},353594:(e,r,n)=>{n.d(r,{SC:()=>decodeTransferInstruction});var i=n(878918),s=n(692363),a=(n(398532),n(264142)),w=n(375236),k=n(749064);n(901048).Buffer;const I=(0,i.struct)([(0,i.u8)("instruction"),(0,s._l)("amount")]);function decodeTransferInstruction(e,r=a.x5){if(!e.programId.equals(r))throw new w.JK;if(e.data.length!==I.span)throw new w.LQ;const{keys:{source:n,destination:i,owner:s,multiSigners:we},data:Ae}=function decodeTransferInstructionUnchecked({programId:e,keys:[r,n,i,...s],data:a}){return{programId:e,keys:{source:r,destination:n,owner:i,multiSigners:s},data:I.decode(a)}}(e);if(Ae.instruction!==k._.Transfer)throw new w.p7;if(!n||!i||!s)throw new w.rO;return{programId:r,keys:{source:n,destination:i,owner:s,multiSigners:we},data:Ae}}},302407:(e,r,n)=>{n.d(r,{fl:()=>createTransferCheckedInstruction,Ly:()=>decodeTransferCheckedInstruction});var i=n(878918),s=n(692363),a=n(398532),w=n(264142),k=n(375236);var I=n(749064),we=n(901048).Buffer;const Ae=(0,i.struct)([(0,i.u8)("instruction"),(0,s._l)("amount"),(0,i.u8)("decimals")]);function createTransferCheckedInstruction(e,r,n,i,s,k,Ce=[],Be=w.x5){const ze=function addSigners(e,r,n){if(n.length){e.push({pubkey:r,isSigner:!1,isWritable:!1});for(const r of n)e.push({pubkey:r instanceof a.J3?r:r.publicKey,isSigner:!0,isWritable:!1})}else e.push({pubkey:r,isSigner:!0,isWritable:!1});return e}([{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0}],i,Ce),qe=we.alloc(Ae.span);return Ae.encode({instruction:I._.TransferChecked,amount:BigInt(s),decimals:k},qe),new a.fH({keys:ze,programId:Be,data:qe})}function decodeTransferCheckedInstruction(e,r=w.x5){if(!e.programId.equals(r))throw new k.JK;if(e.data.length!==Ae.span)throw new k.LQ;const{keys:{source:n,mint:i,destination:s,owner:a,multiSigners:we},data:Ce}=function decodeTransferCheckedInstructionUnchecked({programId:e,keys:[r,n,i,s,...a],data:w}){return{programId:e,keys:{source:r,mint:n,destination:i,owner:s,multiSigners:a},data:Ae.decode(w)}}(e);if(Ce.instruction!==I._.TransferChecked)throw new k.p7;if(!(n&&i&&s&&a))throw new k.rO;return{programId:r,keys:{source:n,mint:i,destination:s,owner:a,multiSigners:we},data:Ce}}},749064:(e,r,n)=>{var i;n.d(r,{_:()=>i}),function(e){e[e.InitializeMint=0]="InitializeMint",e[e.InitializeAccount=1]="InitializeAccount",e[e.InitializeMultisig=2]="InitializeMultisig",e[e.Transfer=3]="Transfer",e[e.Approve=4]="Approve",e[e.Revoke=5]="Revoke",e[e.SetAuthority=6]="SetAuthority",e[e.MintTo=7]="MintTo",e[e.Burn=8]="Burn",e[e.CloseAccount=9]="CloseAccount",e[e.FreezeAccount=10]="FreezeAccount",e[e.ThawAccount=11]="ThawAccount",e[e.TransferChecked=12]="TransferChecked",e[e.ApproveChecked=13]="ApproveChecked",e[e.MintToChecked=14]="MintToChecked",e[e.BurnChecked=15]="BurnChecked",e[e.InitializeAccount2=16]="InitializeAccount2",e[e.SyncNative=17]="SyncNative",e[e.InitializeAccount3=18]="InitializeAccount3",e[e.InitializeMultisig2=19]="InitializeMultisig2",e[e.InitializeMint2=20]="InitializeMint2",e[e.GetAccountDataSize=21]="GetAccountDataSize",e[e.InitializeImmutableOwner=22]="InitializeImmutableOwner",e[e.AmountToUiAmount=23]="AmountToUiAmount",e[e.UiAmountToAmount=24]="UiAmountToAmount",e[e.InitializeMintCloseAuthority=25]="InitializeMintCloseAuthority",e[e.TransferFeeExtension=26]="TransferFeeExtension",e[e.ConfidentialTransferExtension=27]="ConfidentialTransferExtension",e[e.DefaultAccountStateExtension=28]="DefaultAccountStateExtension",e[e.Reallocate=29]="Reallocate",e[e.MemoTransferExtension=30]="MemoTransferExtension",e[e.CreateNativeMint=31]="CreateNativeMint",e[e.InitializeNonTransferableMint=32]="InitializeNonTransferableMint",e[e.InterestBearingMintExtension=33]="InterestBearingMintExtension",e[e.CpiGuardExtension=34]="CpiGuardExtension",e[e.InitializePermanentDelegate=35]="InitializePermanentDelegate",e[e.TransferHookExtension=36]="TransferHookExtension",e[e.MetadataPointerExtension=39]="MetadataPointerExtension"}(i||(i={}))},483053:(e,r,n)=>{n.d(r,{Xt:()=>getAssociatedTokenAddressSync});var i=n(878918),s=n(692363),a=n(398532),w=n(264142),k=n(375236);n(901048).Buffer;const I=(0,i.struct)([(0,i.u32)("mintAuthorityOption"),(0,s.jE)("mintAuthority"),(0,s._l)("supply"),(0,i.u8)("decimals"),(0,s.lc)("isInitialized"),(0,i.u32)("freezeAuthorityOption"),(0,s.jE)("freezeAuthority")]);I.span;function getAssociatedTokenAddressSync(e,r,n=!1,i=w.x5,s=w.EK){if(!n&&!a.J3.isOnCurve(r.toBuffer()))throw new k.lu;const[I]=a.J3.findProgramAddressSync([r.toBuffer(),i.toBuffer(),e.toBuffer()],s);return I}},288297:(e,r,n)=>{function timeoutSignal(e){if(!Number.isInteger(e))throw new TypeError("Expected an integer");const r=new AbortController,n=setTimeout((()=>{r.abort()}),e);return n?.unref?.(),r.signal}n.d(r,{A:()=>timeoutSignal})}}]);